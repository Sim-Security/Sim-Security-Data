{
    "auditTitle": "Art Gobblers Security Review",
    "auditDate": "2022-10-28",
    "auditor": "Spearbit", 
    "project": {
      "name": "Art Gobblers",
      "repo": "https://github.com/art-gobblers/art-gobblers",  
      "website": "[MISSING - Please provide the Art Gobblers website]" 
    },
    "codebase": { 
      "files": [
        {
          "path": "/src/ArtGobblers.sol",
          "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\n\nimport {VRFConsumerBase} from \"chainlink/v0.8/VRFConsumerBase.sol\";\n\nimport {VRGDA} from \"./utils/vrgda/VRGDA.sol\";\nimport {LibString} from \"./utils/lib/LibString.sol\";\nimport {LogisticVRGDA} from \"./utils/vrgda/LogisticVRGDA.sol\";\nimport {MerkleProofLib} from \"./utils/lib/MerkleProofLib.sol\";\nimport {GobblersERC1155B} from \"./utils/token/GobblersERC1155B.sol\";\n\nimport {Goo} from \"./Goo.sol\";\n\n/// @title Art Gobblers NFT\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Art Gobblers scan the cosmos in search of art producing life.\ncontract ArtGobblers is GobblersERC1155B, LogisticVRGDA, VRFConsumerBase, Owned, ERC1155TokenReceiver {\n    using LibString for uint256;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                        ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Goo ERC20 token contract.\n    Goo public immutable goo;\n\n    /// @notice The address which receives gobblers reserved for the team.\n    address public immutable team;\n\n    /// @notice The address which receives gobblers reserved for the community.\n    address public immutable community;\n\n    /*//////////////////////////////////////////////////////////////\n                                    SUPPLY CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maximum number of mintable gobblers.\n    uint256 public constant MAX_SUPPLY = 10000;\n\n    /// @notice Maximum amount of gobblers mintable via mintlist.\n    uint256 public constant MINTLIST_SUPPLY = 2000;\n\n    /// @notice Maximum amount of mintable legendary gobblers.\n    uint256 public constant LEGENDARY_SUPPLY = 10;\n\n    /// @notice Maximum amount of gobblers split between the reserves.\n    /// @dev Set to compromise 20% of the sum of goo mintable gobblers + reserved gobblers.\n    uint256 public constant RESERVED_SUPPLY = (MAX_SUPPLY - MINTLIST_SUPPLY - LEGENDARY_SUPPLY) / 5;\n\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\n    // prettier-ignore\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY\n        - MINTLIST_SUPPLY\n        - LEGENDARY_SUPPLY\n        - RESERVED_SUPPLY;\n\n    /*//////////////////////////////////////////////////////////////\n                                  METADATA CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The name displayed for the contract on Etherscan.\n    string public constant name = \"Art Gobblers\";\n\n    /// @notice URI for gobblers that have yet to be revealed.\n    string public UNREVEALED_URI;\n\n    /// @notice Base URI for minted gobblers.\n    string public BASE_URI;\n\n    /*//////////////////////////////////////////////////////////////\n                                     VRF CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 internal immutable chainlinkKeyHash;\n\n    uint256 internal immutable chainlinkFee;\n\n    /*//////////////////////////////////////////////////////////////\n                                    MINTLIST STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Merkle root of mint mintlist.\n    bytes32 public immutable merkleRoot;\n\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\n    mapping(address => bool) public hasClaimedMintlistGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                                    VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable mintStart;\n\n    /// @notice Number of gobblers minted from goo.\n    uint128 public numMintedFromGoo;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STANDARD GOBBLER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Id of the most recently minted non legendary gobbler.\n    /// @dev Will be 0 if no non legendary gobblers have been minted yet.\n    uint128 public currentNonLegendaryId;\n\n    /// @notice The number of gobblers minted to the reserves.\n    uint256 public numMintedForReserves;\n\n    /*//////////////////////////////////////////////////////////////\n                               LEGENDARY GOBBLER AUCTION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The last LEGENDARY_SUPPLY ids are reserved for legendary gobblers.\n    uint256 public constant FIRST_LEGENDARY_GOBBLER_ID = MAX_SUPPLY - LEGENDARY_SUPPLY + 1;\n\n    /// @notice Legendary auctions begin each time a multiple of these many gobblers have been minted.\n    /// @dev We add 1 to LEGENDARY_SUPPLY because legendary auctions begin only after the first interval.\n    uint256 public constant LEGENDARY_AUCTION_INTERVAL = MAX_MINTABLE / (LEGENDARY_SUPPLY + 1);\n\n    /// @notice Struct holding data required for legendary gobbler auctions.\n    struct LegendaryGobblerAuctionData {\n        // Start price of current legendary gobbler auction.\n        uint128 startPrice;\n        // Number of legendary gobblers sold so far.\n        uint128 numSold;\n    }\n\n    /// @notice Data about the current legendary gobbler auction.\n    LegendaryGobblerAuctionData public legendaryGobblerAuctionData;\n\n    /*//////////////////////////////////////////////////////////////\n                                    GOBBLER REVEAL STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding data required for gobbler reveals.\n    struct GobblerRevealsData {\n        // Last random seed obtained from VRF.\n        uint64 randomSeed;\n        // Next reveal cannot happen before this timestamp.\n        uint64 nextRevealTimestamp;\n        // Id of latest gobbler which has been revealed so far.\n        uint56 lastRevealedId;\n        // Remaining gobblers to be revealed with the current seed.\n        uint56 toBeRevealed;\n        // Whether we are waiting to receive a seed from Chainlink.\n        bool waitingForSeed;\n    }\n\n    /// @notice Data about the current state of gobbler reveals.\n    GobblerRevealsData public gobblerRevealsData;\n\n    /*//////////////////////////////////////////////////////////////\n                                        EMISSION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding data required for goo emission calculations.\n    struct EmissionData {\n        // The sum of the multiples of all gobblers the user holds.\n        uint64 emissionMultiple;\n        // Balance at time of last deposit or withdrawal.\n        uint128 lastBalance;\n        // Timestamp of last deposit or withdrawal.\n        uint64 lastTimestamp;\n    }\n\n    /// @notice Maps user addresses to their emission data.\n    mapping(address => EmissionData) public getEmissionDataForUser;\n\n    /*//////////////////////////////////////////////////////////////\n                                     ART FEEDING STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps gobbler ids to NFT contracts and their ids to the # of those NFT ids fed to the gobbler.\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public getCopiesOfArtFedToGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                                            EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event GooAdded(address indexed user, uint256 gooAdded);\n    event GooRemoved(address indexed user, uint256 gooAdded);\n\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\n    event LegendaryGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\n    event ReservedGobblersMinted(address indexed user, uint256 lastMintedGobblerId, uint256 numGobblersEach);\n\n    event RandomnessRequested(address indexed user, uint256 toBeRevealed);\n    event RandomnessFulfilled(uint256 randomness);\n\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\n\n    event ArtFedToGobbler(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\n\n    /*//////////////////////////////////////////////////////////////\n                                            ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error InvalidProof();\n    error AlreadyClaimed();\n    error MintStartPending();\n\n    error SeedPending();\n    error RevealsPending();\n    error RequestTooEarly();\n    error ZeroToBeRevealed();\n\n    error ReserveImbalance();\n\n    error OwnerMismatch(address owner);\n\n    error NoRemainingLegendaryGobblers();\n    error IncorrectGobblerAmount(uint256 cost);\n    error CannotBurnLegendary(uint256 gobblerId);\n\n    error PriceExceededMax(uint256 currentPrice);\n\n    error NotEnoughRemainingToBeRevealed(uint256 totalRemainingToBeRevealed);\n\n    /*//////////////////////////////////////////////////////////////\n                                        CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        // Mint config:\n        bytes32 _merkleRoot,\n        uint256 _mintStart,\n        // Addresses:\n        Goo _goo,\n        address _team,\n        address _community,\n        // Chainlink:\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _chainlinkKeyHash,\n        uint256 _chainlinkFee,\n        // URIs:\n        string memory _baseUri,\n        string memory _unrevealedUri\n    )\n        VRGDA(\n            69.42e18, // Initial price.\n            0.31e18 // Per period price decrease.\n        )\n        LogisticVRGDA(\n            // Max mintable gobblers.\n            int256(MAX_MINTABLE * 1e18),\n            0.0023e18 // Time scale.\n        )\n        VRFConsumerBase(_vrfCoordinator, _linkToken)\n        Owned(msg.sender) // Deployer starts as owner.\n    {\n        mintStart = _mintStart;\n        merkleRoot = _merkleRoot;\n\n        goo = _goo;\n        team = _team;\n        community = _community;\n\n        chainlinkKeyHash = _chainlinkKeyHash;\n        chainlinkFee = _chainlinkFee;\n\n        BASE_URI = _baseUri;\n        UNREVEALED_URI = _unrevealedUri;\n\n        // Starting price for legendary gobblers is 69 gobblers.\n        legendaryGobblerAuctionData.startPrice = 69;\n\n        // Reveal for initial mint must wait 24 hours\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MINTLIST CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Claim from mintlist, using a merkle proof.\n    /// @param proof Merkle proof to verify the sender is mintlisted.\n    /// @return gobblerId The id of the gobbler that was claimed.\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\n        // If minting has not yet begun, revert.\n        if (mintStart > block.timestamp) revert MintStartPending();\n\n        // If the user has already claimed, revert.\n        if (hasClaimedMintlistGobbler[msg.sender]) revert AlreadyClaimed();\n\n        // If the user's proof is invalid, revert.\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert InvalidProof();\n\n        hasClaimedMintlistGobbler[msg.sender] = true; // Before mint to prevent reentrancy.\n\n        unchecked {\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLegendaryId);\n\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                     MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a gobbler with goo, burning the cost.\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintFromGoo(uint256 maxPrice) external returns (uint256 gobblerId) {\n        // No need to check mint cap, gobblerPrice()\n        // will revert due to overflow if we reach it.\n        // It will also revert prior to the mint start.\n        uint256 currentPrice = gobblerPrice();\n\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\n\n        goo.burnForGobblers(msg.sender, currentPrice);\n\n        unchecked {\n            ++numMintedFromGoo; // Before mint to prevent reentrancy.\n\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLegendaryId, currentPrice);\n\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n\n    /// @notice Gobbler pricing in terms of goo.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    function gobblerPrice() public view returns (uint256) {\n        // We need checked math here to cause overflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n\n        return getPrice(timeSinceStart, numMintedFromGoo);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               LEGENDARY GOBBLER AUCTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a legendary gobbler by burning multiple standard gobblers.\n    /// @param gobblerIds The ids of the standard gobblers to burn.\n    /// @return gobblerId The id of the legendary gobbler that was minted.\n    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\n        gobblerId = FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold; // Assign id.\n\n        // If the gobbler id would be greater than the max supply, there are no remaining legendaries.\n        if (gobblerId > MAX_SUPPLY) revert NoRemainingLegendaryGobblers();\n\n        // This will revert if the auction hasn't started yet, no need to check here as well.\n        uint256 cost = legendaryGobblerPrice();\n\n        if (gobblerIds.length != cost) revert IncorrectGobblerAmount(cost);\n\n        // Overflow should not occur in here, as most math is on emission multiples, which are inherently small.\n        unchecked {\n            uint256 burnedMultipleTotal; // The legendary's emissionMultiple will be 2x the sum of the gobblers burned.\n\n            /*//////////////////////////////////////////////////////////////\n                                            BATCH BURN LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            // Generate an amounts array locally to use in the event below.\n            uint256[] memory amounts = new uint256[](gobblerIds.length);\n\n            uint256 id; //