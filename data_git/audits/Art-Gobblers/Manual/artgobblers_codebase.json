{
  "codebase": {
    "files": [
      {
        "path": "/analysis/compute_emissions.py",
        "content": "from eth_abi import encode_single\nimport math\nimport argparse\n\ndef compute_emissions(time, initial_amount, staking_multiple): \n    t1 = math.sqrt(staking_multiple) * time + 2 * math.sqrt(initial_amount)\n    final_amount = 0.25 * t1 * t1\n\n    final_amount *= (10 ** 18)\n    encode_and_print(final_amount)\n\ndef encode_and_print(price):\n    enc = encode_single('uint256', int(price))\n    ## append 0x for FFI parsing \n    print(\"0x\" + enc.hex())\n\ndef parse_args(): \n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--time\", type=int)\n    parser.add_argument(\"--initial_amount\", type=int)\n    parser.add_argument(\"--emission_multiple\", type=int)\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    args = parse_args() \n    compute_emissions(\n        args.time / (10 ** 18)\n        , args.initial_amount / (10 ** 18)\n        , args.emission_multiple)\n\n================================================"
      },
      {
        "path": "/analysis/compute_price.py",
        "content": "from pricer import Pricer\nfrom eth_abi import encode_single\nimport argparse\n\ndef main(args): \n    if (args.type == 'gobblers'): \n        calculate_gobblers_price(args)\n    elif (args.type == 'pages'):\n        calculate_pages_price(args)\n    \ndef calculate_gobblers_price(args): \n    pricer = Pricer()\n    price = pricer.compute_gobbler_price(\n        args.time_since_start / (60 * 60 * 24), ## convert to seconds \n        args.num_sold, \n        args.initial_price / (10 ** 18), ## scale decimals \n        args.per_period_price_decrease / (10 ** 18), ## scale decimals \n        args.logistic_scale / (10 ** 18), ## scale decimals \n        args.time_scale / (10 ** 18), ## scale decimals \n        0\n    )\n    price *= (10 ** 18)\n    encode_and_print(price)\n\ndef calculate_pages_price(args): \n    pricer = Pricer()\n    price = pricer.compute_page_price(\n        args.time_since_start / (60 * 60 * 24), ## convert to seconds \n        args.num_sold, \n        args.initial_price / (10 ** 18), ## scale decimals \n        args.per_period_price_decrease / (10 ** 18), ## scale decimals \n        args.logistic_scale / (10 ** 18), ## scale decimals \n        args.time_scale / (10 ** 18), ## scale decimals \n        0,\n        args.per_period_post_switchover / (10 ** 18), ## scale decimals \n        args.switchover_time / (10 ** 18)\n    )\n    price *= (10 ** 18)\n    encode_and_print(price)\n\ndef encode_and_print(price):\n    enc = encode_single('uint256', int(price))\n    ## append 0x for FFI parsing \n    print(\"0x\" + enc.hex())\n\ndef parse_args(): \n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"type\", choices=[\"gobblers\", \"pages\"])\n    parser.add_argument(\"--time_since_start\", type=int)\n    parser.add_argument(\"--num_sold\", type=int)\n    parser.add_argument(\"--initial_price\", type=int)\n    parser.add_argument(\"--per_period_price_decrease\", type=int)\n    parser.add_argument(\"--logistic_scale\", type=int)\n    parser.add_argument(\"--time_scale\", type=int)\n    parser.add_argument(\"--per_period_post_switchover\", type=int)\n    parser.add_argument(\"--switchover_time\", type=int)\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    args = parse_args() \n    main(args)\n\n================================================"
      },
      {
        "path": "/analysis/pricer.py",
        "content": "import math\nimport numpy as np\n\n\nclass Pricer: \n    \n    def compute_gobbler_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift):\n       return self.compute_vrgda_price(time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift)\n\n    def compute_page_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift,  per_period_post_switchover, switchover_time):\n        initial_value = logistic_scale/ (1 +math.exp(time_scale * time_shift))\n        sold_by_switchover = logistic_scale / (1 + math.exp(-1 * time_scale * (switchover_time - time_shift))) - initial_value\n        if num_sold < sold_by_switchover:\n            return self.compute_vrgda_price(time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift)\n        else: \n            f_inv = (num_sold - sold_by_switchover) / per_period_post_switchover + switchover_time\n            return initial_price * math.exp(-math.log(1 - per_period_price_decrease) * (f_inv - time_since_start))\n\n    def compute_vrgda_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift):\n        initial_value = logistic_scale / (1 + math.exp(time_scale * time_shift))\n        logistic_value = num_sold + initial_value\n        price = (1 - per_period_price_decrease) ** (time_since_start - time_shift + (math.log(-1 + logistic_scale / logistic_value) / time_scale)) * initial_price\n        return price\n\n\n================================================"
      },
      {
        "path": "/src/Pages.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {VRGDA} from \"./utils/vrgda/VRGDA.sol\";\nimport {LibString} from \"./utils/lib/LibString.sol\";\nimport {PagesERC721} from \"./utils/token/PagesERC721.sol\";\nimport {LogisticVRGDA} from \"./utils/vrgda/LogisticVRGDA.sol\";\nimport {PostSwitchVRGDA} from \"./utils/vrgda/PostSwitchVRGDA.sol\";\n\nimport {Goo} from \"./Goo.sol\";\n\n/// @title Pages NFT\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Pages is an ERC721 that can hold custom art.\ncontract Pages is PagesERC721, LogisticVRGDA, PostSwitchVRGDA {\n    using LibString for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the goo ERC20 token contract.\n    Goo public immutable goo;\n\n    /// @notice The address which receives pages reserved for the community.\n    address public immutable community;\n\n    /*//////////////////////////////////////////////////////////////\n                                  URIS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Base URI for minted pages.\n    string public BASE_URI;\n\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Timestamp for the start of the VRGDA mint.\n    uint256 public immutable mintStart;\n\n    /// @notice Id of the most recently minted page.\n    /// @dev Will be 0 if no pages have been minted yet.\n    uint128 public currentId;\n\n    /*//////////////////////////////////////////////////////////////\n                          COMMUNITY PAGES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The number of pages minted to the community reserve.\n    uint128 public numMintedForCommunity;\n\n    /*//////////////////////////////////////////////////////////////\n                            PRICING CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev The day the switch from a logistic to translated linear VRGDA is targeted to occur.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal constant SWITCH_DAY_WAD = 270e18;\n\n    /// @notice The minimum amount of pages that must be sold for the VRGDA issuance\n    /// schedule to switch from logistic to the \"post switch\" translated linear formula.\n    /// @dev Computed off-chain by plugging the switch day into the uninverted pacing formula.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal constant SOLD_BY_SWITCH_WAD = 8598.35810341741976233e18;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PagePurchased(address indexed user, uint256 indexed pageId, uint256 price);\n\n    event CommunityPagesMinted(address indexed user, uint256 lastMintedPageId, uint256 numPages);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error ReserveImbalance();\n\n    error PriceExceededMax(uint256 currentPrice);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        // Mint config:\n        uint256 _mintStart,\n        // Addresses:\n        Goo _goo,\n        address _community,\n        address _artGobblers,\n        // URIs:\n        string memory _baseUri\n    )\n        VRGDA(\n            4.2069e18, // Initial price.\n            0.31e18 // Per period price decrease.\n        )\n        LogisticVRGDA(\n            9000e18, // Asymptote.\n            0.014e18 // Time scale.\n        )\n        PostSwitchVRGDA(\n            SOLD_BY_SWITCH_WAD, // Sold by switch.\n            SWITCH_DAY_WAD, // Target switch day.\n            10e18 // Pages to target per day.\n        )\n        PagesERC721(_artGobblers, \"Pages\", \"PAGE\")\n    {\n        mintStart = _mintStart;\n\n        goo = _goo;\n\n        community = _community;\n\n        BASE_URI = _baseUri;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a page with goo, burning the cost.\n    /// @param maxPrice Maximum price to pay to mint the page.\n    /// @return pageId The id of the page that was minted.\n    function mintFromGoo(uint256 maxPrice) external returns (uint256 pageId) {\n        // Will revert if prior to mint start.\n        uint256 currentPrice = pagePrice();\n\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\n\n        goo.burnForPages(msg.sender, currentPrice);\n\n        unchecked {\n            emit PagePurchased(msg.sender, pageId = ++currentId, currentPrice);\n\n            _mint(msg.sender, pageId);\n        }\n    }\n\n    /// @notice Calculate the mint cost of a page.\n    /// @dev If the number of sales is below a pre-defined threshold, we use the\n    /// VRGDA pricing algorithm, otherwise we use the post-switch pricing formula.\n    /// @dev Reverts due to underflow if minting hasn't started yet. Done to save gas.\n    function pagePrice() public view returns (uint256) {\n        // We need checked math here to cause overflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n\n        unchecked {\n            // The number of pages minted for the community reserve\n            // cannot ever exceed 10% of the total supply of pages.\n            return getPrice(timeSinceStart, currentId - numMintedForCommunity);\n        }\n    }\n\n    function getTargetDayForNextSale(int256 tokens)\n        internal\n        view\n        override(LogisticVRGDA, PostSwitchVRGDA)\n        returns (int256)\n    {\n        return\n            tokens < SOLD_BY_SWITCH_WAD\n                ? LogisticVRGDA.getTargetDayForNextSale(tokens)\n                : PostSwitchVRGDA.getTargetDayForNextSale(tokens);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      COMMUNITY PAGES MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a number of pages to the community reserve.\n    /// @param numPages The number of pages to mint to the reserve.\n    /// @dev Pages minted to the reserve cannot compromise more than 10% of the sum of the\n    /// supply of goo minted pages and the supply of pages minted to the community reserve.\n    function mintCommunityPages(uint256 numPages) external returns (uint256 lastMintedPageId) {\n        unchecked {\n            // Optimistically increment numMintedForCommunity, may be reverted below.\n            // Overflow in this calculation is possible but numPages would have to\n            // be so large that it would cause the loop to run out of gas quickly.\n            uint256 newNumMintedForCommunity = numMintedForCommunity += uint128(numPages);\n\n            // Ensure that after this mint pages minted to the community reserve won't compromise more than\n            // 10% of the new total page supply. currentId is equivalent to the current total supply of pages.\n            if (newNumMintedForCommunity > ((lastMintedPageId = currentId) + numPages) / 10) revert ReserveImbalance();\n\n            // Mint the pages to the community reserve while updating lastMintedPageId.\n            for (uint256 i = 0; i < numPages; i++) _mint(community, ++lastMintedPageId);\n\n            currentId = uint128(lastMintedPageId); // Update currentId with the last minted page id.\n\n            emit CommunityPagesMinted(msg.sender, lastMintedPageId, numPages);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             TOKEN URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns a pages's URI if it has been minted.\n    /// @param pageId The id of the page to get the URI for.\n    function tokenURI(uint256 pageId) public view virtual override returns (string memory) {\n        if (pageId > currentId) return \"\";\n\n        return string(abi.encodePacked(BASE_URI, pageId.toString()));\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/Goo.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title Goo Token (GOO)\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Goo is the in-game token for ArtGobblers. It's a standard ERC20\n/// token that can be burned and minted by the gobblers and pages contract.\ncontract Goo is ERC20(\"Goo\", \"GOO\", 18) {\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Art Gobblers contract.\n    address public immutable artGobblers;\n\n    /// @notice The address of the Pages contract.\n    address public immutable pages;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error Unauthorized();\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _artGobblers, address _pages) {\n        artGobblers = _artGobblers;\n        pages = _pages;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Requires caller address to match user address.\n    modifier only(address user) {\n        if (msg.sender != user) revert Unauthorized();\n\n        _;\n    }\n\n    /// @notice Mint any amount of goo to a user. Can only be called by ArtGobblers.\n    /// @param to The address of the user to mint goo to.\n    /// @param amount The amount of goo to mint.\n    function mintForGobblers(address to, uint256 amount) public only(artGobblers) {\n        _mint(to, amount);\n    }\n\n    /// @notice Burn any amount of goo from a user. Can only be called by ArtGobblers.\n    /// @param from The address of the user to burn goo from.\n    /// @param amount The amount of goo to burn.\n    function burnForGobblers(address from, uint256 amount) public only(artGobblers) {\n        _burn(from, amount);\n    }\n\n    /// @notice Burn any amount of goo from a user. Can only be called by Pages.\n    /// @param from The address of the user to burn goo from.\n    /// @param amount The amount of goo to burn.\n    function burnForPages(address from, uint256 amount) public only(pages) {\n        _burn(from, amount);\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/ArtGobblers.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\n\nimport {VRFConsumerBase} from \"chainlink/v0.8/VRFConsumerBase.sol\";\n\nimport {VRGDA} from \"./utils/vrgda/VRGDA.sol\";\nimport {LibString} from \"./utils/lib/LibString.sol\";\nimport {LogisticVRGDA} from \"./utils/vrgda/LogisticVRGDA.sol\";\nimport {MerkleProofLib} from \"./utils/lib/MerkleProofLib.sol\";\nimport {GobblersERC1155B} from \"./utils/token/GobblersERC1155B.sol\";\n\nimport {Goo} from \"./Goo.sol\";\n\n/// @title Art Gobblers NFT\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Art Gobblers scan the cosmos in search of art producing life.\ncontract ArtGobblers is GobblersERC1155B, LogisticVRGDA, VRFConsumerBase, Owned, ERC1155TokenReceiver {\n    using LibString for uint256;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Goo ERC20 token contract.\n    Goo public immutable goo;\n\n    /// @notice The address which receives gobblers reserved for the team.\n    address public immutable team;\n\n    /// @notice The address which receives gobblers reserved for the community.\n    address public immutable community;\n\n    /*//////////////////////////////////////////////////////////////\n                            SUPPLY CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maximum number of mintable gobblers.\n    uint256 public constant MAX_SUPPLY = 10000;\n\n    /// @notice Maximum amount of gobblers mintable via mintlist.\n    uint256 public constant MINTLIST_SUPPLY = 2000;\n\n    /// @notice Maximum amount of mintable legendary gobblers.\n    uint256 public constant LEGENDARY_SUPPLY = 10;\n\n    /// @notice Maximum amount of gobblers split between the reserves.\n    /// @dev Set to compromise 20% of the sum of goo mintable gobblers + reserved gobblers.\n    uint256 public constant RESERVED_SUPPLY = (MAX_SUPPLY - MINTLIST_SUPPLY - LEGENDARY_SUPPLY) / 5;\n\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\n    // prettier-ignore\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY\n        - MINTLIST_SUPPLY\n        - LEGENDARY_SUPPLY\n        - RESERVED_SUPPLY;\n\n    /*//////////////////////////////////////////////////////////////\n                           METADATA CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The name displayed for the contract on Etherscan.\n    string public constant name = \"Art Gobblers\";\n\n    /// @notice URI for gobblers that have yet to be revealed.\n    string public UNREVEALED_URI;\n\n    /// @notice Base URI for minted gobblers.\n    string public BASE_URI;\n\n    /*//////////////////////////////////////////////////////////////\n                              VRF CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 internal immutable chainlinkKeyHash;\n\n    uint256 internal immutable chainlinkFee;\n\n    /*//////////////////////////////////////////////////////////////\n                             MINTLIST STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Merkle root of mint mintlist.\n    bytes32 public immutable merkleRoot;\n\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\n    mapping(address => bool) public hasClaimedMintlistGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable mintStart;\n\n    /// @notice Number of gobblers minted from goo.\n    uint128 public numMintedFromGoo;\n\n    /*//////////////////////////////////////////////////////////////\n                         STANDARD GOBBLER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Id of the most recently minted non legendary gobbler.\n    /// @dev Will be 0 if no non legendary gobblers have been minted yet.\n    uint128 public currentNonLegendaryId;\n\n    /// @notice The number of gobblers minted to the reserves.\n    uint256 public numMintedForReserves;\n\n    /*//////////////////////////////////////////////////////////////\n                     LEGENDARY GOBBLER AUCTION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The last LEGENDARY_SUPPLY ids are reserved for legendary gobblers.\n    uint256 public constant FIRST_LEGENDARY_GOBBLER_ID = MAX_SUPPLY - LEGENDARY_SUPPLY + 1;\n\n    /// @notice Legendary auctions begin each time a multiple of these many gobblers have been minted.\n    /// @dev We add 1 to LEGENDARY_SUPPLY because legendary auctions begin only after the first interval.\n    uint256 public constant LEGENDARY_AUCTION_INTERVAL = MAX_MINTABLE / (LEGENDARY_SUPPLY + 1);\n\n    /// @notice Struct holding data required for legendary gobbler auctions.\n    struct LegendaryGobblerAuctionData {\n        // Start price of current legendary gobbler auction.\n        uint128 startPrice;\n        // Number of legendary gobblers sold so far.\n        uint128 numSold;\n    }\n\n    /// @notice Data about the current legendary gobbler auction.\n    LegendaryGobblerAuctionData public legendaryGobblerAuctionData;\n\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding data required for gobbler reveals.\n    struct GobblerRevealsData {\n        // Last random seed obtained from VRF.\n        uint64 randomSeed;\n        // Next reveal cannot happen before this timestamp.\n        uint64 nextRevealTimestamp;\n        // Id of latest gobbler which has been revealed so far.\n        uint56 lastRevealedId;\n        // Remaining gobblers to be revealed with the current seed.\n        uint56 toBeRevealed;\n        // Whether we are waiting to receive a seed from Chainlink.\n        bool waitingForSeed;\n    }\n\n    /// @notice Data about the current state of gobbler reveals.\n    GobblerRevealsData public gobblerRevealsData;\n\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding data required for goo emission calculations.\n    struct EmissionData {\n        // The sum of the multiples of all gobblers the user holds.\n        uint64 emissionMultiple;\n        // Balance at time of last deposit or withdrawal.\n        uint128 lastBalance;\n        // Timestamp of last deposit or withdrawal.\n        uint64 lastTimestamp;\n    }\n\n    /// @notice Maps user addresses to their emission data.\n    mapping(address => EmissionData) public getEmissionDataForUser;\n\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps gobbler ids to NFT contracts and their ids to the # of those NFT ids fed to the gobbler.\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public getCopiesOfArtFedToGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event GooAdded(address indexed user, uint256 gooAdded);\n    event GooRemoved(address indexed user, uint256 gooAdded);\n\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\n    event LegendaryGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\n    event ReservedGobblersMinted(address indexed user, uint256 lastMintedGobblerId, uint256 numGobblersEach);\n\n    event RandomnessRequested(address indexed user, uint256 toBeRevealed);\n    event RandomnessFulfilled(uint256 randomness);\n\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\n\n    event ArtFedToGobbler(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error InvalidProof();\n    error AlreadyClaimed();\n    error MintStartPending();\n\n    error SeedPending();\n    error RevealsPending();\n    error RequestTooEarly();\n    error ZeroToBeRevealed();\n\n    error ReserveImbalance();\n\n    error OwnerMismatch(address owner);\n\n    error NoRemainingLegendaryGobblers();\n    error IncorrectGobblerAmount(uint256 cost);\n    error CannotBurnLegendary(uint256 gobblerId);\n\n    error PriceExceededMax(uint256 currentPrice);\n\n    error NotEnoughRemainingToBeRevealed(uint256 totalRemainingToBeRevealed);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        // Mint config:\n        bytes32 _merkleRoot,\n        uint256 _mintStart,\n        // Addresses:\n        Goo _goo,\n        address _team,\n        address _community,\n        // Chainlink:\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _chainlinkKeyHash,\n        uint256 _chainlinkFee,\n        // URIs:\n        string memory _baseUri,\n        string memory _unrevealedUri\n    )\n        VRGDA(\n            69.42e18, // Initial price.\n            0.31e18 // Per period price decrease.\n        )\n        LogisticVRGDA(\n            // Max mintable gobblers.\n            int256(MAX_MINTABLE * 1e18),\n            0.0023e18 // Time scale.\n        )\n        VRFConsumerBase(_vrfCoordinator, _linkToken)\n        Owned(msg.sender) // Deployer starts as owner.\n    {\n        mintStart = _mintStart;\n        merkleRoot = _merkleRoot;\n\n        goo = _goo;\n        team = _team;\n        community = _community;\n\n        chainlinkKeyHash = _chainlinkKeyHash;\n        chainlinkFee = _chainlinkFee;\n\n        BASE_URI = _baseUri;\n        UNREVEALED_URI = _unrevealedUri;\n\n        // Starting price for legendary gobblers is 69 gobblers.\n        legendaryGobblerAuctionData.startPrice = 69;\n\n        // Reveal for initial mint must wait 24 hours\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          MINTLIST CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Claim from mintlist, using a merkle proof.\n    /// @param proof Merkle proof to verify the sender is mintlisted.\n    /// @return gobblerId The id of the gobbler that was claimed.\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\n        // If minting has not yet begun, revert.\n        if (mintStart > block.timestamp) revert MintStartPending();\n\n        // If the user has already claimed, revert.\n        if (hasClaimedMintlistGobbler[msg.sender]) revert AlreadyClaimed();\n\n        // If the user's proof is invalid, revert.\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert InvalidProof();\n\n        hasClaimedMintlistGobbler[msg.sender] = true; // Before mint to prevent reentrancy.\n\n        unchecked {\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLegendaryId);\n\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a gobbler with goo, burning the cost.\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintFromGoo(uint256 maxPrice) external returns (uint256 gobblerId) {\n        // No need to check mint cap, gobblerPrice()\n        // will revert due to overflow if we reach it.\n        // It will also revert prior to the mint start.\n        uint256 currentPrice = gobblerPrice();\n\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\n\n        goo.burnForGobblers(msg.sender, currentPrice);\n\n        unchecked {\n            ++numMintedFromGoo; // Before mint to prevent reentrancy.\n\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLegendaryId, currentPrice);\n\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n\n    /// @notice Gobbler pricing in terms of goo.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    function gobblerPrice() public view returns (uint256) {\n        // We need checked math here to cause overflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n\n        return getPrice(timeSinceStart, numMintedFromGoo);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     LEGENDARY GOBBLER AUCTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a legendary gobbler by burning multiple standard gobblers.\n    /// @param gobblerIds The ids of the standard gobblers to burn.\n    /// @return gobblerId The id of the legendary gobbler that was minted.\n    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\n        gobblerId = FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold; // Assign id.\n\n        // If the gobbler id would be greater than the max supply, there are no remaining legendaries.\n        if (gobblerId > MAX_SUPPLY) revert NoRemainingLegendaryGobblers();\n\n        // This will revert if the auction hasn't started yet, no need to check here as well.\n        uint256 cost = legendaryGobblerPrice();\n\n        if (gobblerIds.length != cost) revert IncorrectGobblerAmount(cost);\n\n        // Overflow should not occur in here, as most math is on emission multiples, which are inherently small.\n        unchecked {\n            uint256 burnedMultipleTotal; // The legendary's emissionMultiple will be 2x the sum of the gobblers burned.\n\n            /*//////////////////////////////////////////////////////////////\n                                    BATCH BURN LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            // Generate an amounts array locally to use in the event below.\n            uint256[] memory amounts = new uint256[](gobblerIds.length);\n\n            uint256 id; // Storing outside the loop saves ~7 gas per iteration.\n\n            for (uint256 i = 0; i < gobblerIds.length; ++i) {\n                id = gobblerIds[i];\n\n                if (id >= FIRST_LEGENDARY_GOBBLER_ID) revert CannotBurnLegendary(id);\n\n                require(getGobblerData[id].owner == msg.sender, \"WRONG_FROM\");\n\n                burnedMultipleTotal += getGobblerData[id].emissionMultiple;\n\n                getGobblerData[id].owner = address(0);\n\n                amounts[i] = 1;\n            }\n\n            emit TransferBatch(msg.sender, msg.sender, address(0), gobblerIds, amounts);\n\n            /*//////////////////////////////////////////////////////////////\n                                 LEGENDARY MINTING LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            // The shift right by 1 is equivalent to multiplication by 2, used to make\n            // the legendary's emissionMultiple 2x the sum of the multiples of the gobblers burned.\n            // Must be done before minting as the transfer hook will update the user's emissionMultiple.\n            getGobblerData[gobblerId].emissionMultiple = uint48(burnedMultipleTotal << 1);\n\n            // Update the user's emission data in one big batch. We add burnedMultipleTotal to their\n            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that\n            // were burned and hence should have their multiples subtracted from the user's total multiple.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender));\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[msg.sender].emissionMultiple += uint64(burnedMultipleTotal);\n\n            // New start price is the max of 69 and cost * 2. Left shift by 1 is like multiplication by 2.\n            legendaryGobblerAuctionData.startPrice = uint120(cost < 35 ? 69 : cost << 1);\n            legendaryGobblerAuctionData.numSold += 1; // Increment the # of legendaries sold.\n\n            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.\n            emit LegendaryGobblerMinted(msg.sender, gobblerId, gobblerIds);\n\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n\n    /// @notice Calculate the legendary gobbler price in terms of gobblers, according to a linear decay function.\n    /// @dev The price of a legendary gobbler decays as gobblers are minted. The first legendary auction begins when\n    /// 1 LEGENDARY_AUCTION_INTERVAL worth of gobblers are minted, and the price decays linearly while the next interval of\n    /// gobblers is minted. Every time an additional interval is minted, a new auction begins until all legendaries been sold.\n    function legendaryGobblerPrice() public view returns (uint256) {\n        // Retrieve and cache the auction's startPrice and numSold on the stack.\n        uint256 startPrice = legendaryGobblerAuctionData.startPrice;\n        uint256 numSold = legendaryGobblerAuctionData.numSold;\n\n        uint256 numMintedAtStart; // The number of gobblers minted at the start of the auction.\n\n        unchecked {\n            // The number of gobblers minted at the start of the auction is computed by multiplying the # of\n            // intervals that must pass before the next auction begins by the number of gobblers in each interval.\n            numMintedAtStart = (numSold + 1) * LEGENDARY_AUCTION_INTERVAL;\n        }\n\n        // How many gobblers where minted since auction began. Cannot be\n        // unchecked, we want this to revert if auction has not yet started.\n        uint256 numMintedSinceStart = numMintedFromGoo - numMintedAtStart;\n\n        unchecked {\n            // If we've minted the full interval or beyond it, the price has decayed to 0.\n            if (numMintedSinceStart >= LEGENDARY_AUCTION_INTERVAL) return 0;\n            // Otherwise decay the price linearly based on what fraction of the interval has been minted.\n            else return (startPrice * (LEGENDARY_AUCTION_INTERVAL - numMintedSinceStart)) / LEGENDARY_AUCTION_INTERVAL;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                VRF LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Request a new random seed for revealing gobblers.\n    /// @dev Can only be called every 24 hours at the earliest.\n    function requestRandomSeed() external returns (bytes32) {\n        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;\n\n        // A new random seed cannot be requested before the next reveal timestamp.\n        if (block.timestamp < nextRevealTimestamp) revert RequestTooEarly();\n\n        // A random seed can only be requested when all gobblers from the previous seed have been revealed.\n        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.\n        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();\n\n        unchecked {\n            // Prevent revealing while we wait for the seed.\n            gobblerRevealsData.waitingForSeed = true;\n\n            // Compute the number of gobblers to be revealed with the seed.\n            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;\n\n            // Ensure that there are more than 0 gobblers to be revealed,\n            // otherwise the contract could waste LINK revealing nothing.\n            if (toBeRevealed == 0) revert ZeroToBeRevealed();\n\n            // Lock in the number of gobblers to be revealed from seed.\n            gobblerRevealsData.toBeRevealed = uint56(toBeRevealed);\n\n            // We want at most one batch of reveals every 24 hours.\n            // Timestamp overflow is impossible on human timescales.\n            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);\n\n            emit RandomnessRequested(msg.sender, toBeRevealed);\n        }\n\n        // Will revert if we don't have enough LINK to afford the request.\n        return requestRandomness(chainlinkKeyHash, chainlinkFee);\n    }\n\n    /// @notice Callback from Chainlink VRF. Sets randomSeed.\n    function fulfillRandomness(bytes32, uint256 randomness) internal override {\n        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.\n        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.\n\n        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.\n\n        emit RandomnessFulfilled(randomness);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Knuth shuffle to progressively reveal gobblers using entropy from random seed.\n    /// @param numGobblers The number of gobblers to reveal.\n    function revealGobblers(uint256 numGobblers) external {\n        uint256 randomSeed = gobblerRevealsData.randomSeed;\n\n        uint256 lastRevealedId = gobblerRevealsData.lastRevealedId;\n\n        uint256 totalRemainingToBeRevealed = gobblerRevealsData.toBeRevealed;\n\n        // Can't reveal if we're still waiting for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert SeedPending();\n\n        // Can't reveal more gobblers than are currently remaining to be revealed with the seed.\n        if (numGobblers > totalRemainingToBeRevealed) revert NotEnoughRemainingToBeRevealed(totalRemainingToBeRevealed);\n\n        // Implements a Knuth shuffle. If something in\n        // here can overflow we've got bigger problems.\n        unchecked {\n            for (uint256 i = 0; i < numGobblers; ++i) {\n                /*//////////////////////////////////////////////////////////////\n                                      DETERMINE RANDOM SWAP\n                //////////////////////////////////////////////////////////////*/\n\n                // Number of ids that have not been revealed. Subtract 1\n                // because we don't want to include any legendaries in the swap.\n                uint256 remainingIds = FIRST_LEGENDARY_GOBBLER_ID - lastRevealedId - 1;\n\n                // Randomly pick distance for swap.\n                uint256 distance = randomSeed % remainingIds;\n\n                // Current id is consecutive to last reveal.\n                uint256 currentId = ++lastRevealedId;\n\n                // Select swap id, adding distance to next reveal id.\n                uint256 swapId = currentId + distance;\n\n                /*//////////////////////////////////////////////////////////////\n                                       GET INDICES FOR IDS\n                //////////////////////////////////////////////////////////////*/\n\n                // Get the index of the swap id.\n                uint48 swapIndex = getGobblerData[swapId].idx == 0\n                    ? uint48(swapId) // Hasn't been shuffled before.\n                    : getGobblerData[swapId].idx; // Shuffled before.\n\n                // Get the owner of the current id.\n                address currentIdOwner = getGobblerData[currentId].owner;\n\n                // Get the index of the current id.\n                uint48 currentIndex = getGobblerData[currentId].idx == 0\n                    ? uint48(currentId) // Hasn't been shuffled before.\n                    : getGobblerData[currentId].idx; // Shuffled before.\n\n                /*//////////////////////////////////////////////////////////////\n                                  SWAP INDICES AND SET MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n\n                // Determine the current id's new emission multiple.\n                uint256 newCurrentIdMultiple = 9; // For beyond 7963.\n\n                // The branchless expression below is equivalent to:\n                //      if (swapIndex <= 3054) newCurrentIdMultiple = 6;\n                // else if (swapIndex <= 5672) newCurrentIdMultiple = 7;\n                // else if (swapIndex <= 7963) newCurrentIdMultiple = 8;\n                assembly {\n                    // prettier-ignore\n                    newCurrentIdMultiple := sub(sub(sub(\n                        newCurrentIdMultiple,\n                        lt(swapIndex, 7964)),\n                        lt(swapIndex, 5673)),\n                        lt(swapIndex, 3055)\n                    )\n                }\n\n                // Swap the index and multiple of the current id.\n                getGobblerData[currentId].idx = swapIndex;\n                getGobblerData[currentId].emissionMultiple = uint48(newCurrentIdMultiple);\n\n                // Swap the index of the swap id.\n                getGobblerData[swapId].idx = currentIndex;\n\n                /*//////////////////////////////////////////////////////////////\n                                   UPDATE CURRENT ID MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n\n                // Update the emission data for the owner of the current id.\n                getEmissionDataForUser[currentIdOwner].lastBalance = uint128(gooBalance(currentIdOwner));\n                getEmissionDataForUser[currentIdOwner].lastTimestamp = uint64(block.timestamp);\n                getEmissionDataForUser[currentIdOwner].emissionMultiple += uint64(newCurrentIdMultiple);\n\n                // Update the random seed to choose a new distance for the next iteration.\n                // It is critical that we cast to uint64 here, as otherwise the random seed\n                // set after calling revealGobblers(1) thrice would differ from the seed set\n                // after calling revealGobblers(3) a single time. This would enable an attacker\n                // to choose from a number of different seeds and use whichever is most favorable.\n                // Equivalent to randomSeed = uint64(uint256(keccak256(abi.encodePacked(randomSeed))))\n                assembly {\n                    mstore(0, randomSeed) // Store the random seed in scratch space.\n\n                    // Moduloing by 1 << 64 (2 ** 64) is equivalent to a uint64 cast.\n                    randomSeed := mod(keccak256(0, 32), shl(64, 1))\n                }\n            }\n\n            // Update all relevant reveal state state.\n            gobblerRevealsData.randomSeed = uint64(randomSeed);\n            gobblerRevealsData.lastRevealedId = uint56(lastRevealedId);\n            gobblerRevealsData.toBeRevealed = uint56(totalRemainingToBeRevealed - numGobblers);\n\n            emit GobblersRevealed(msg.sender, numGobblers, lastRevealedId);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns a token's URI if it has been minted.\n    /// @param gobblerId The id of the token to get the URI for.\n    function uri(uint256 gobblerId) public view virtual override returns (string memory) {\n        // Between 0 and lastRevealed are revealed normal gobblers.\n        if (gobblerId <= gobblerRevealsData.lastRevealedId) {\n            // 0 is not a valid id:\n            if (gobblerId == 0) return \"\";\n\n            return string(abi.encodePacked(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString()));\n        }\n\n        // Between lastRevealed + 1 and currentNonLegendaryId are minted but not revealed.\n        if (gobblerId <= currentNonLegendaryId) return UNREVEALED_URI;\n\n        // Between currentNonLegendaryId and FIRST_LEGENDARY_GOBBLER_ID are unminted.\n        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID) return \"\";\n\n        // Between FIRST_LEGENDARY_GOBBLER_ID and FIRST_LEGENDARY_GOBBLER_ID + numSold are minted legendaries.\n        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold)\n            return string(abi.encodePacked(BASE_URI, gobblerId.toString()));\n\n        return \"\"; // Unminted legendaries and invalid token ids.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Feed a gobbler a work of art.\n    /// @param gobblerId The gobbler to feed the work of art.\n    /// @param nft The ERC721 or ERC1155 contract of the work of art.\n    /// @param id The id of the work of art.\n    /// @param isERC1155 Whether the work of art is an ERC1155 token.\n    function feedArt(\n        uint256 gobblerId,\n        address nft,\n        uint256 id,\n        bool isERC1155\n    ) external {\n        // Get the owner of the gobbler to feed.\n        address owner = getGobblerData[gobblerId].owner;\n\n        // The caller must own the gobbler they're feeding.\n        if (owner != msg.sender) revert OwnerMismatch(owner);\n\n        unchecked {\n            // Increment the number of copies fed to the gobbler.\n            // Counter overflow is unrealistic on human timescales.\n            ++getCopiesOfArtFedToGobbler[gobblerId][nft][id];\n        }\n\n        emit ArtFedToGobbler(msg.sender, gobblerId, nft, id);\n\n        isERC1155\n            ? ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, \"\")\n            : ERC721(nft).transferFrom(msg.sender, address(this), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculate a user's staked goo balance.\n    /// @param user The user to query balance for.\n    function gooBalance(address user) public view returns (uint256) {\n        // If a user's goo balance is greater than\n        // 2**256 - 1 we've got much bigger problems.\n        unchecked {\n            uint256 emissionMultiple = getEmissionDataForUser[user].emissionMultiple;\n            uint256 lastBalanceWad = getEmissionDataForUser[user].lastBalance;\n\n            // Stored with 18 decimals, such that if a day and a half elapsed this variable would equal 1.5e18.\n            uint256 daysElapsedWad = ((block.timestamp - getEmissionDataForUser[user].lastTimestamp) * 1e18) / 1 days;\n\n            uint256 daysElapsedSquaredWad = daysElapsedWad.mulWadDown(daysElapsedWad); // Need to use wad math here.\n\n            // prettier-ignore\n            return lastBalanceWad + // The last recorded balance.\n\n            // Don't need to do wad multiplication since we're\n            // multiplying by a plain integer with no decimals.\n            // Shift right by 2 is equivalent to division by 4.\n            ((emissionMultiple * daysElapsedSquaredWad) >> 2) +\n\n            daysElapsedWad.mulWadDown( // Terms are wads, so must mulWad.\n                // No wad multiplication for emissionMultiple * lastBalance\n                // because emissionMultiple is a plain integer with no decimals.\n                // We multiply the sqrt's radicand by 1e18 because it expects ints.\n                (emissionMultiple * lastBalanceWad * 1e18).sqrt()\n            );\n        }\n    }\n\n    /// @notice Add goo to your emission balance.\n    /// @param gooAmount The amount of goo to add.\n    function addGoo(uint256 gooAmount) external {\n        // Burn goo being added to gobbler.\n        goo.burnForGobblers(msg.sender, gooAmount);\n\n        unchecked {\n            // If a user has enough goo to overflow their balance we've got big problems.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender) + gooAmount);\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n        }\n\n        emit GooAdded(msg.sender, gooAmount);\n    }\n\n    /// @notice Remove goo from your emission balance.\n    /// @param gooAmount The amount of goo to remove.\n    function removeGoo(uint256 gooAmount) external {\n        // Will revert due to underflow if removed amount is larger than the user's current goo balance.\n        getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender) - gooAmount);\n        getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n\n        goo.mintForGobblers(msg.sender, gooAmount);\n\n        emit GooRemoved(msg.sender, gooAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     RESERVED GOBBLERS MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a number of gobblers to the reserves.\n    /// @param numGobblersEach The number of gobblers to mint to each reserve.\n    /// @dev Gobblers minted to reserves cannot compromise more than 20% of the sum of\n    /// the supply of goo minted gobblers and the supply of gobblers minted to reserves.\n    function mintReservedGobblers(uint256 numGobblersEach) external returns (uint256 lastMintedGobblerId) {\n        unchecked {\n            // Optimistically increment numMintedForReserves, may be reverted below. Overflow in this\n            // calculation is possible but numGobblersEach would have to be so large that it would cause the\n            // loop in _batchMint to run out of gas quickly. Shift left by 1 is equivalent to multiplying by 2.\n            uint256 newNumMintedForReserves = numMintedForReserves += (numGobblersEach << 1);\n\n            // Ensure that after this mint gobblers minted to reserves won't compromise more than 20% of\n            // the sum of the supply of goo minted gobblers and the supply of gobblers minted to reserves.\n            if (newNumMintedForReserves > (numMintedFromGoo + newNumMintedForReserves) / 5) revert ReserveImbalance();\n        }\n\n        // Mint numGobblersEach gobblers to both the team and community reserve.\n        lastMintedGobblerId = _batchMint(team, numGobblersEach, currentNonLegendaryId, \"\");\n        lastMintedGobblerId = _batchMint(community, numGobblersEach, lastMintedGobblerId, \"\");\n\n        // Note: There is reentrancy here. The _batchMint calls above can enable an\n        // adversary to reenter before currentNonLegendaryId is updated, but since we\n        // assume the reserves are both trusted addresses, we can safely ignore this risk.\n        currentNonLegendaryId = uint128(lastMintedGobblerId); // Set currentNonLegendaryId.\n\n        emit ReservedGobblersMinted(msg.sender, lastMintedGobblerId, numGobblersEach);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          CONVENIENCE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Convenience function to get emission emissionMultiple for a gobbler.\n    /// @param gobblerId The gobbler to get emissionMultiple for.\n    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {\n        return getGobblerData[gobblerId].emissionMultiple;\n    }\n\n    /// @notice Convenience function to get emission emissionMultiple for a user.\n    /// @param user The user to get emissionMultiple for.\n    function getUserEmissionMultiple(address user) external view returns (uint256) {\n        return getEmissionDataForUser[user].emissionMultiple;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155B LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public override {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        unchecked {\n            uint64 emissionsMultipleTotal; // Will use to set each user's multiple.\n\n            for (uint256 i = 0; i < ids.length; i++) {\n                id = ids[i];\n                amount = amounts[i];\n\n                // Can only transfer from the owner.\n                require(from == getGobblerData[id].owner, \"WRONG_FROM\");\n\n                // Can only transfer 1 with ERC1155B.\n                require(amount == 1, \"INVALID_AMOUNT\");\n\n                getGobblerData[id].owner = to;\n\n                emissionsMultipleTotal += getGobblerData[id].emissionMultiple;\n            }\n\n            transferUserEmissionMultiple(from, to, emissionsMultipleTotal);\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public override {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        require(from == getGobblerData[id].owner, \"WRONG_FROM\"); // Can only transfer from the owner.\n\n        // Can only transfer 1 with ERC1155B.\n        require(amount == 1, \"INVALID_AMOUNT\");\n\n        getGobblerData[id].owner = to;\n\n        transferUserEmissionMultiple(from, to, getGobblerData[id].emissionMultiple);\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Transfer an amount of a user's emission's multiple to another user.\n    /// @dev Should be done whenever a gobbler is transferred between two users.\n    /// @param from The user to transfer the amount of emission multiple from.\n    /// @param to The user to transfer the amount of emission multiple to.\n    /// @param emissionMultiple The amount of emission multiple to transfer.\n    function transferUserEmissionMultiple(\n        address from,\n        address to,\n        uint64 emissionMultiple\n    ) internal {\n        unchecked {\n            // Decrease the from user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[from].lastBalance = uint128(gooBalance(from));\n            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[from].emissionMultiple -= emissionMultiple;\n\n            // Increase the to user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[to].lastBalance = uint128(gooBalance(to));\n            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[to].emissionMultiple += emissionMultiple;\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/GobblerReserve.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\n\nimport {ArtGobblers} from \"../ArtGobblers.sol\";\n\n/// @title Gobbler Reserve\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Reserves gobblers for an owner while keeping any goo produced.\ncontract GobblerReserve is Owned, ERC1155TokenReceiver {\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n    ArtGobblers public artGobblers;\n\n    constructor(ArtGobblers _artGobblers, address _owner) Owned(_owner) {\n        artGobblers = _artGobblers;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Withdraw gobblers from the reserve.\n    /// @param to The address to transfer the gobblers to.\n    /// @param ids The ids of the gobblers to transfer.\n    function withdraw(address to, uint256[] calldata ids) public onlyOwner {\n        unchecked {\n            // Generating this in memory is pretty expensive\n            // but this is not a hot path so we can afford it.\n            uint256[] memory amounts = new uint256[](ids.length);\n            for (uint256 i = 0; i < ids.length; i++) amounts[i] = 1;\n\n            artGobblers.safeBatchTransferFrom(address(this), to, ids, amounts, \"\");\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/lib/SignedWadMath.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Signed Wad Math\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Efficient signed wad arithmetic.\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\n    assembly {\n        // Multiply x by 1e18.\n        r := mul(x, 1000000000000000000)\n    }\n}\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Multiply x by y and divide by 1e18.\n        r := sdiv(mul(x, y), 1000000000000000000)\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero and will\n/// not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Multiply x by 1e18 and divide it by y.\n        r := sdiv(mul(x, 1000000000000000000), y)\n    }\n}\n\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Store x * y in r for now.\n        r := mul(x, y)\n\n        // Equivalent to require(x == 0 || (x * y) / x == y)\n        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {\n            revert(0, 0)\n        }\n\n        // Scale the result down by 1e18.\n        r := sdiv(r, 1000000000000000000)\n    }\n}\n\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Store x * 1e18 in r for now.\n        r := mul(x, 1000000000000000000)\n\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\n            revert(0, 0)\n        }\n\n        // Divide r by y.\n        r := sdiv(r, y)\n    }\n}\n\nfunction wadExp(int256 x) pure returns (int256 r) {\n    unchecked {\n        // When the result is < 0.5 we return zero. This happens when\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n        if (x <= -42139678854452767551) return 0;\n\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n        if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n        // for more intermediate precision and a binary basis. This base conversion\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n        x = (x << 78) / 5**18;\n\n        // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n        x = x - k * 54916777467707473351141471128;\n\n        // k is in the range [-61, 195].\n\n        // Evaluate using a (6, 7)-term rational approximation.\n        // p is made monic, we'll multiply by a scale factor later.\n        int256 y = x + 1346386616545796478920950773328;\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\n        int256 p = y + x - 94201549194550492254356042504812;\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n        p = p * x + (4385272521454847904659076985693276 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        int256 q = x - 2855989394907223263936484059900;\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\n            // No scaling is necessary because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r should be in the range (0.09, 0.25) * 2**96.\n\n        // We now need to multiply r by:\n        // * the scale factor s = ~6.031367120.\n        // * the 2**k factor from the range reduction.\n        // * the 1e18 / 2**96 factor for base conversion.\n        // We do this all at once, with an intermediate result in 2**213\n        // basis, so the final right shift is always by a positive amount.\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n    }\n}\n\nfunction wadLn(int256 x) pure returns (int256 r) {\n    unchecked {\n        require(x > 0, \"UNDEFINED\");\n\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n        // We do this by multiplying by 2**96 / 10**18. But since\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n        // and add ln(2**96 / 10**18) at the end.\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n\n        // Reduce range of x to (1, 2) * 2**96\n        // ln(2^k * x) = k * ln(2) + ln(x)\n        int256 k = r - 96;\n        x <<= uint256(159 - k);\n        x = int256(uint256(x) >> 159);\n\n        // Evaluate using a (8, 8)-term rational approximation.\n        // p is made monic, we will multiply by a scale factor later.\n        int256 p = x + 3273285459638523848632254066296;\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\n        p = p * x - (795164235651350426258249787498 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        // q is monic by convention.\n        int256 q = x + 5573035233440673466300451813936;\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r is in the range (0, 0.125) * 2**96\n\n        // Finalization, we need to:\n        // * multiply by the scale factor s = 5.549\u2026\n        // * add ln(2**96 / 10**18)\n        // * add k * ln(2)\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n        r *= 1677202110996718588342820967067443963516166;\n        // add ln(2) * k * 5e18 * 2**192\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n        // base conversion: mul 2**18 / 2**192\n        r >>= 174;\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero.\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Divide x by y.\n        r := sdiv(x, y)\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/lib/MerkleProofLib.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized merkle proof verification library.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/MerkleProofLib.sol)\nlibrary MerkleProofLib {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool isValid) {\n        assembly {\n            let computedHash := leaf // The hash starts as the leaf hash.\n\n            // Initialize data to the offset of the proof in the calldata.\n            let data := proof.offset\n\n            // Iterate over proof elements to compute root hash.\n            for {\n                // Left shifting by 5 is like multiplying by 32.\n                let end := add(data, shl(5, proof.length))\n            } lt(data, end) {\n                data := add(data, 32) // Shift 1 word per cycle.\n            } {\n                // Load the current proof element.\n                let loadedData := calldataload(data)\n\n                // Slot where computedHash should be put in scratch space.\n                // If computedHash > loadedData: slot 32, otherwise: slot 0.\n                let computedHashSlot := shl(5, gt(computedHash, loadedData))\n\n                // Store elements to hash contiguously in scratch space.\n                // The xor puts loadedData in whichever slot computedHash is\n                // not occupying, so 0 if computedHashSlot is 32, 32 otherwise.\n                mstore(computedHashSlot, computedHash)\n                mstore(xor(computedHashSlot, 32), loadedData)\n\n                computedHash := keccak256(0, 64) // Hash both slots of scratch space.\n            }\n\n            isValid := eq(computedHash, root) // The proof is valid if the roots match.\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/lib/LibString.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 n) internal pure returns (string memory str) {\n        if (n == 0) return \"0\"; // Otherwise it'd output an empty string for 0.\n\n        assembly {\n            let k := 78 // Start with the max length a uint256 string could be.\n\n            // We'll store our string at the first chunk of free memory.\n            str := mload(0x40)\n\n            // The length of our string will start off at the max of 78.\n            mstore(str, k)\n\n            // Update the free memory pointer to prevent overriding our string.\n            // Add 128 to the str pointer instead of 78 because we want to maintain\n            // the Solidity convention of keeping the free memory pointer word aligned.\n            mstore(0x40, add(str, 128))\n\n            // We'll populate the string from right to left.\n            // prettier-ignore\n            for {} n {} {\n                // The ASCII digit offset for '0' is 48.\n                let char := add(48, mod(n, 10))\n\n                // Write the current character into str.\n                mstore(add(str, k), char)\n\n                k := sub(k, 1)\n                n := div(n, 10)\n            }\n\n            // Shift the pointer to the start of the string.\n            str := add(str, k)\n\n            // Set the length of the string to the correct value.\n            mstore(str, sub(78, k))\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/token/PagesERC721.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\n\n/// @notice ERC721 implementation optimized for Pages by pre-approving them to the ArtGobblers contract.\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract PagesERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable artGobblers;\n\n    constructor(\n        address _artGobblers,\n        string memory _name,\n        string memory _symbol\n    ) {\n        name = _name;\n        symbol = _symbol;\n        artGobblers = _artGobblers;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) internal _isApprovedForAll;\n\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool isApproved) {\n        if (operator == artGobblers) return true; // Skip approvals for the ArtGobblers contract.\n\n        return _isApprovedForAll[owner][operator];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        if (to.code.length != 0)\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        if (to.code.length != 0)\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        // Does not check the token has not been already minted\n        // or is being minted to address(0) because ids in Pages.sol\n        // are set using a monotonically increasing counter and only\n        // minted to safe addresses or msg.sender who cannot be zero.\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/token/GobblersERC1155B.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\n\n/// @notice ERC1155B implementation optimized for ArtGobblers by using the ownerOf storage slot to store attribute data.\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/tokens/ERC1155B.sol)\nabstract contract GobblersERC1155B {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                        GOBBLERS/ERC1155B STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding gobbler data.\n    struct GobblerData {\n        // The current owner of the gobbler.\n        address owner;\n        // Index of token after shuffle.\n        uint48 idx;\n        // Multiple on goo issuance.\n        uint48 emissionMultiple;\n    }\n\n    mapping(uint256 => GobblerData) public getGobblerData;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        return getGobblerData[id].owner;\n    }\n\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 bal) {\n        address idOwner = getGobblerData[id].owner;\n\n        assembly {\n            // We avoid branching by using assembly to take\n            // the bool output of eq() and use it as a uint.\n            bal := eq(idOwner, owner)\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual;\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf(owners[i], ids[i]);\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           INTERNAL MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        getGobblerData[id].owner = to;\n\n        // Does not check if the token was already minted because new ids in\n        // ArtGobblers.sol are set using a monotonically increasing counter.\n\n        emit TransferSingle(msg.sender, address(0), to, id, 1);\n\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, 1, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n\n    function _batchMint(\n        address to,\n        uint256 amount,\n        uint256 lastMintedId,\n        bytes memory data\n    ) internal returns (uint256) {\n        // Allocate arrays before entering the loop.\n        uint256[] memory ids = new uint256[](amount);\n        uint256[] memory amounts = new uint256[](amount);\n\n        // Counter overflow is unrealistic on human timescales.\n        unchecked {\n            for (uint256 i = 0; i < amount; ++i) {\n                ids[i] = ++lastMintedId; // Increment id while setting.\n\n                amounts[i] = 1; // ERC1155B amounts are always 1.\n\n                getGobblerData[lastMintedId].owner = to;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n\n        return lastMintedId; // Return the new last minted id.\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/vrgda/PostSwitchVRGDA.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {unsafeWadDiv} from \"../lib/SignedWadMath.sol\";\n\nimport {VRGDA} from \"./VRGDA.sol\";\n\n/// @title \"Post Switch\" Variable Rate Gradual Dutch Auction\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Abstract VRGDA with a (translated) linear issuance curve.\nabstract contract PostSwitchVRGDA is VRGDA {\n    /*//////////////////////////////////////////////////////////////\n                           PRICING PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev The number of tokens sold at the time of the switch.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable soldBySwitch;\n\n    /// @dev The day soldBySwitch tokens were targeted to sell by.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable switchDay;\n\n    /// @dev The total number of tokens to target selling each day.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable perDay;\n\n    constructor(\n        int256 _soldBySwitch,\n        int256 _switchDay,\n        int256 _perDay\n    ) {\n        soldBySwitch = _soldBySwitch;\n        switchDay = _switchDay;\n        perDay = _perDay;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function getTargetDayForNextSale(int256 sold) internal view virtual override returns (int256) {\n        unchecked {\n            return unsafeWadDiv(sold - soldBySwitch, perDay) + switchDay;\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/vrgda/LogisticVRGDA.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {wadExp, wadLn, unsafeDiv, unsafeWadDiv} from \"../lib/SignedWadMath.sol\";\n\nimport {VRGDA} from \"./VRGDA.sol\";\n\n/// @title Logistic Variable Rate Gradual Dutch Auction\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Abstract VRGDA with a logistic issuance curve.\nabstract contract LogisticVRGDA is VRGDA {\n    /*//////////////////////////////////////////////////////////////\n                           PRICING PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Controls the curve's maximum value which\n    /// controls the maximum number of tokens to sell.\n    /// @dev Represented as a 36 decimal fixed point number.\n    int256 internal immutable logisticScale;\n\n    /// @dev Time scale controls the steepness of the logistic curve,\n    /// which effects how quickly we will reach the curve's asymptote.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable timeScale;\n\n    /// @dev The initial value the uninverted logistic formula would output.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable initialLogisticValue;\n\n    constructor(int256 _maxMintable, int256 _timeScale) {\n        // We need to double _maxMintable to account for initialLogisticValue\n        // and use 18 decimals to avoid wad multiplication in getTargetSaleDay.\n        logisticScale = _maxMintable * 2e18;\n\n        initialLogisticValue = _maxMintable;\n\n        timeScale = _timeScale;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function getTargetDayForNextSale(int256 sold) internal view virtual override returns (int256) {\n        unchecked {\n            return -unsafeWadDiv(wadLn(unsafeDiv(logisticScale, sold + initialLogisticValue) - 1e18), timeScale);\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/vrgda/VRGDA.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {wadExp, wadLn, wadMul, unsafeWadMul, toWadUnsafe} from \"../lib/SignedWadMath.sol\";\n\n/// @title Variable Rate Gradual Dutch Auction\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Sell tokens roughly according to an issuance schedule.\nabstract contract VRGDA {\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initial price of each token, to be scaled according to sales rate.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 public immutable initialPrice;Directory structure:\n\u2514\u2500\u2500 artgobblers-art-gobblers\n    \u251c\u2500\u2500 .prettierrc\n    \u251c\u2500\u2500 analysis\n    \u2502   \u251c\u2500\u2500 compute_emissions.py\n    \u2502   \u251c\u2500\u2500 compute_price.py\n    \u2502   \u251c\u2500\u2500 requirements.txt\n    \u2502   \u251c\u2500\u2500 pricer.py\n    \u2502   \u2514\u2500\u2500 README.md\n    \u251c\u2500\u2500 .prettierignore\n    \u251c\u2500\u2500 .gas-snapshot\n    \u251c\u2500\u2500 remappings.txt\n    \u251c\u2500\u2500 .github\n    \u2502   \u2514\u2500\u2500 workflows\n    \u2502       \u2514\u2500\u2500 tests.yml\n    \u251c\u2500\u2500 assets\n    \u2502   \u2514\u2500\u2500 state-machines\n    \u251c\u2500\u2500 .solhint.json\n    \u251c\u2500\u2500 test\n    \u2502   \u251c\u2500\u2500 Optimizations.t.sol\n    \u2502   \u251c\u2500\u2500 deploy\n    \u2502   \u2502   \u2514\u2500\u2500 DeployRinkeby.t.sol\n    \u2502   \u251c\u2500\u2500 GobblerReserve.t.sol\n    \u2502   \u251c\u2500\u2500 MerkleProofLib.t.sol\n    \u2502   \u251c\u2500\u2500 Pages.t.sol\n    \u2502   \u251c\u2500\u2500 SignedWadMath.t.sol\n    \u2502   \u251c\u2500\u2500 correctness\n    \u2502   \u2502   \u251c\u2500\u2500 GobblersCorrectness.t.sol\n    \u2502   \u2502   \u251c\u2500\u2500 PagesCorrectness.t.sol\n    \u2502   \u2502   \u2514\u2500\u2500 EmissionCorrectness.t.sol\n    \u2502   \u251c\u2500\u2500 LibString.t.sol\n    \u2502   \u251c\u2500\u2500 Benchmarks.t.sol\n    \u2502   \u251c\u2500\u2500 Goo.t.sol\n    \u2502   \u251c\u2500\u2500 ArtGobblers.t.sol\n    \u2502   \u251c\u2500\u2500 utils\n    \u2502   \u2502   \u251c\u2500\u2500 LibRLP.sol\n    \u2502   \u2502   \u251c\u2500\u2500 Console.sol\n    \u2502   \u2502   \u251c\u2500\u2500 mocks\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 MockGooCalculator.sol\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 LinkToken.sol\n    \u2502   \u2502   \u2514\u2500\u2500 Utilities.sol\n    \u2502   \u2514\u2500\u2500 VRGDAs.t.sol\n    \u251c\u2500\u2500 .gitmodules\n    \u251c\u2500\u2500 lib\n    \u2502   \u251c\u2500\u2500 chainlink\n    \u2502   \u251c\u2500\u2500 ds-test\n    \u2502   \u251c\u2500\u2500 forge-std\n    \u2502   \u2514\u2500\u2500 solmate\n    \u251c\u2500\u2500 script\n    \u2502   \u2514\u2500\u2500 deploy\n    \u2502       \u251c\u2500\u2500 DeployRinkeby.s.sol\n    \u2502       \u2514\u2500\u2500 DeployBase.s.sol\n    \u251c\u2500\u2500 foundry.toml\n    \u251c\u2500\u2500 package.json\n    \u251c\u2500\u2500 README.md\n    \u2514\u2500\u2500 src\n        \u251c\u2500\u2500 Pages.sol\n        \u251c\u2500\u2500 Goo.sol\n        \u251c\u2500\u2500 ArtGobblers.sol\n        \u2514\u2500\u2500 utils\n            \u251c\u2500\u2500 GobblerReserve.sol\n            \u251c\u2500\u2500 lib\n            \u2502   \u251c\u2500\u2500 SignedWadMath.sol\n            \u2502   \u251c\u2500\u2500 MerkleProofLib.sol\n            \u2502   \u2514\u2500\u2500 LibString.sol\n            \u251c\u2500\u2500 token\n            \u2502   \u251c\u2500\u2500 PagesERC721.sol\n            \u2502   \u2514\u2500\u2500 GobblersERC1155B.sol\n            \u2514\u2500\u2500 vrgda\n                \u251c\u2500\u2500 PostSwitchVRGDA.sol\n                \u251c\u2500\u2500 LogisticVRGDA.sol\n                \u2514\u2500\u2500 VRGDA.sol\n\n\nFiles Content:\n\n================================================"
      },
      {
        "path": "/analysis/compute_emissions.py",
        "content": "from eth_abi import encode_single\nimport math\nimport argparse\n\ndef compute_emissions(time, initial_amount, staking_multiple): \n    t1 = math.sqrt(staking_multiple) * time + 2 * math.sqrt(initial_amount)\n    final_amount = 0.25 * t1 * t1\n\n    final_amount *= (10 ** 18)\n    encode_and_print(final_amount)\n\ndef encode_and_print(price):\n    enc = encode_single('uint256', int(price))\n    ## append 0x for FFI parsing \n    print(\"0x\" + enc.hex())\n\ndef parse_args(): \n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--time\", type=int)\n    parser.add_argument(\"--initial_amount\", type=int)\n    parser.add_argument(\"--emission_multiple\", type=int)\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    args = parse_args() \n    compute_emissions(\n        args.time / (10 ** 18)\n        , args.initial_amount / (10 ** 18)\n        , args.emission_multiple)\n\n================================================"
      },
      {
        "path": "/analysis/compute_price.py",
        "content": "from pricer import Pricer\nfrom eth_abi import encode_single\nimport argparse\n\ndef main(args): \n    if (args.type == 'gobblers'): \n        calculate_gobblers_price(args)\n    elif (args.type == 'pages'):\n        calculate_pages_price(args)\n    \ndef calculate_gobblers_price(args): \n    pricer = Pricer()\n    price = pricer.compute_gobbler_price(\n        args.time_since_start / (60 * 60 * 24), ## convert to seconds \n        args.num_sold, \n        args.initial_price / (10 ** 18), ## scale decimals \n        args.per_period_price_decrease / (10 ** 18), ## scale decimals \n        args.logistic_scale / (10 ** 18), ## scale decimals \n        args.time_scale / (10 ** 18), ## scale decimals \n        0\n    )\n    price *= (10 ** 18)\n    encode_and_print(price)\n\ndef calculate_pages_price(args): \n    pricer = Pricer()\n    price = pricer.compute_page_price(\n        args.time_since_start / (60 * 60 * 24), ## convert to seconds \n        args.num_sold, \n        args.initial_price / (10 ** 18), ## scale decimals \n        args.per_period_price_decrease / (10 ** 18), ## scale decimals \n        args.logistic_scale / (10 ** 18), ## scale decimals \n        args.time_scale / (10 ** 18), ## scale decimals \n        0,\n        args.per_period_post_switchover / (10 ** 18), ## scale decimals \n        args.switchover_time / (10 ** 18)\n    )\n    price *= (10 ** 18)\n    encode_and_print(price)\n\ndef encode_and_print(price):\n    enc = encode_single('uint256', int(price))\n    ## append 0x for FFI parsing \n    print(\"0x\" + enc.hex())\n\ndef parse_args(): \n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"type\", choices=[\"gobblers\", \"pages\"])\n    parser.add_argument(\"--time_since_start\", type=int)\n    parser.add_argument(\"--num_sold\", type=int)\n    parser.add_argument(\"--initial_price\", type=int)\n    parser.add_argument(\"--per_period_price_decrease\", type=int)\n    parser.add_argument(\"--logistic_scale\", type=int)\n    parser.add_argument(\"--time_scale\", type=int)\n    parser.add_argument(\"--per_period_post_switchover\", type=int)\n    parser.add_argument(\"--switchover_time\", type=int)\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    args = parse_args() \n    main(args)\n\n================================================"
      },
      {
        "path": "/analysis/pricer.py",
        "content": "import math\nimport numpy as np\n\n\nclass Pricer: \n    \n    def compute_gobbler_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift):\n       return self.compute_vrgda_price(time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift)\n\n    def compute_page_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift,  per_period_post_switchover, switchover_time):\n        initial_value = logistic_scale/ (1 +math.exp(time_scale * time_shift))\n        sold_by_switchover = logistic_scale / (1 + math.exp(-1 * time_scale * (switchover_time - time_shift))) - initial_value\n        if num_sold < sold_by_switchover:\n            return self.compute_vrgda_price(time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift)\n        else: \n            f_inv = (num_sold - sold_by_switchover) / per_period_post_switchover + switchover_time\n            return initial_price * math.exp(-math.log(1 - per_period_price_decrease) * (f_inv - time_since_start))\n\n    def compute_vrgda_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift):\n        initial_value = logistic_scale / (1 + math.exp(time_scale * time_shift))\n        logistic_value = num_sold + initial_value\n        price = (1 - per_period_price_decrease) ** (time_since_start - time_shift + (math.log(-1 + logistic_scale / logistic_value) / time_scale)) * initial_price\n        return price\n\n\n================================================"
      },
      {
        "path": "/src/Pages.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {VRGDA} from \"./utils/vrgda/VRGDA.sol\";\nimport {LibString} from \"./utils/lib/LibString.sol\";\nimport {PagesERC721} from \"./utils/token/PagesERC721.sol\";\nimport {LogisticVRGDA} from \"./utils/vrgda/LogisticVRGDA.sol\";\nimport {PostSwitchVRGDA} from \"./utils/vrgda/PostSwitchVRGDA.sol\";\n\nimport {Goo} from \"./Goo.sol\";\n\n/// @title Pages NFT\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Pages is an ERC721 that can hold custom art.\ncontract Pages is PagesERC721, LogisticVRGDA, PostSwitchVRGDA {\n    using LibString for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the goo ERC20 token contract.\n    Goo public immutable goo;\n\n    /// @notice The address which receives pages reserved for the community.\n    address public immutable community;\n\n    /*//////////////////////////////////////////////////////////////\n                                  URIS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Base URI for minted pages.\n    string public BASE_URI;\n\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Timestamp for the start of the VRGDA mint.\n    uint256 public immutable mintStart;\n\n    /// @notice Id of the most recently minted page.\n    /// @dev Will be 0 if no pages have been minted yet.\n    uint128 public currentId;\n\n    /*//////////////////////////////////////////////////////////////\n                          COMMUNITY PAGES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The number of pages minted to the community reserve.\n    uint128 public numMintedForCommunity;\n\n    /*//////////////////////////////////////////////////////////////\n                            PRICING CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev The day the switch from a logistic to translated linear VRGDA is targeted to occur.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal constant SWITCH_DAY_WAD = 270e18;\n\n    /// @notice The minimum amount of pages that must be sold for the VRGDA issuance\n    /// schedule to switch from logistic to the \"post switch\" translated linear formula.\n    /// @dev Computed off-chain by plugging the switch day into the uninverted pacing formula.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal constant SOLD_BY_SWITCH_WAD = 8598.35810341741976233e18;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PagePurchased(address indexed user, uint256 indexed pageId, uint256 price);\n\n    event CommunityPagesMinted(address indexed user, uint256 lastMintedPageId, uint256 numPages);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error ReserveImbalance();\n\n    error PriceExceededMax(uint256 currentPrice);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        // Mint config:\n        uint256 _mintStart,\n        // Addresses:\n        Goo _goo,\n        address _community,\n        address _artGobblers,\n        // URIs:\n        string memory _baseUri\n    )\n        VRGDA(\n            4.2069e18, // Initial price.\n            0.31e18 // Per period price decrease.\n        )\n        LogisticVRGDA(\n            9000e18, // Asymptote.\n            0.014e18 // Time scale.\n        )\n        PostSwitchVRGDA(\n            SOLD_BY_SWITCH_WAD, // Sold by switch.\n            SWITCH_DAY_WAD, // Target switch day.\n            10e18 // Pages to target per day.\n        )\n        PagesERC721(_artGobblers, \"Pages\", \"PAGE\")\n    {\n        mintStart = _mintStart;\n\n        goo = _goo;\n\n        community = _community;\n\n        BASE_URI = _baseUri;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a page with goo, burning the cost.\n    /// @param maxPrice Maximum price to pay to mint the page.\n    /// @return pageId The id of the page that was minted.\n    function mintFromGoo(uint256 maxPrice) external returns (uint256 pageId) {\n        // Will revert if prior to mint start.\n        uint256 currentPrice = pagePrice();\n\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\n\n        goo.burnForPages(msg.sender, currentPrice);\n\n        unchecked {\n            emit PagePurchased(msg.sender, pageId = ++currentId, currentPrice);\n\n            _mint(msg.sender, pageId);\n        }\n    }\n\n    /// @notice Calculate the mint cost of a page.\n    /// @dev If the number of sales is below a pre-defined threshold, we use the\n    /// VRGDA pricing algorithm, otherwise we use the post-switch pricing formula.\n    /// @dev Reverts due to underflow if minting hasn't started yet. Done to save gas.\n    function pagePrice() public view returns (uint256) {\n        // We need checked math here to cause overflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n\n        unchecked {\n            // The number of pages minted for the community reserve\n            // cannot ever exceed 10% of the total supply of pages.\n            return getPrice(timeSinceStart, currentId - numMintedForCommunity);\n        }\n    }\n\n    function getTargetDayForNextSale(int256 tokens)\n        internal\n        view\n        override(LogisticVRGDA, PostSwitchVRGDA)\n        returns (int256)\n    {\n        return\n            tokens < SOLD_BY_SWITCH_WAD\n                ? LogisticVRGDA.getTargetDayForNextSale(tokens)\n                : PostSwitchVRGDA.getTargetDayForNextSale(tokens);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      COMMUNITY PAGES MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a number of pages to the community reserve.\n    /// @param numPages The number of pages to mint to the reserve.\n    /// @dev Pages minted to the reserve cannot compromise more than 10% of the sum of the\n    /// supply of goo minted pages and the supply of pages minted to the community reserve.\n    function mintCommunityPages(uint256 numPages) external returns (uint256 lastMintedPageId) {\n        unchecked {\n            // Optimistically increment numMintedForCommunity, may be reverted below.\n            // Overflow in this calculation is possible but numPages would have to\n            // be so large that it would cause the loop to run out of gas quickly.\n            uint256 newNumMintedForCommunity = numMintedForCommunity += uint128(numPages);\n\n            // Ensure that after this mint pages minted to the community reserve won't compromise more than\n            // 10% of the new total page supply. currentId is equivalent to the current total supply of pages.\n            if (newNumMintedForCommunity > ((lastMintedPageId = currentId) + numPages) / 10) revert ReserveImbalance();\n\n            // Mint the pages to the community reserve while updating lastMintedPageId.\n            for (uint256 i = 0; i < numPages; i++) _mint(community, ++lastMintedPageId);\n\n            currentId = uint128(lastMintedPageId); // Update currentId with the last minted page id.\n\n            emit CommunityPagesMinted(msg.sender, lastMintedPageId, numPages);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             TOKEN URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns a pages's URI if it has been minted.\n    /// @param pageId The id of the page to get the URI for.\n    function tokenURI(uint256 pageId) public view virtual override returns (string memory) {\n        if (pageId > currentId) return \"\";\n\n        return string(abi.encodePacked(BASE_URI, pageId.toString()));\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/Goo.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title Goo Token (GOO)\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Goo is the in-game token for ArtGobblers. It's a standard ERC20\n/// token that can be burned and minted by the gobblers and pages contract.\ncontract Goo is ERC20(\"Goo\", \"GOO\", 18) {\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Art Gobblers contract.\n    address public immutable artGobblers;\n\n    /// @notice The address of the Pages contract.\n    address public immutable pages;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error Unauthorized();\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _artGobblers, address _pages) {\n        artGobblers = _artGobblers;\n        pages = _pages;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Requires caller address to match user address.\n    modifier only(address user) {\n        if (msg.sender != user) revert Unauthorized();\n\n        _;\n    }\n\n    /// @notice Mint any amount of goo to a user. Can only be called by ArtGobblers.\n    /// @param to The address of the user to mint goo to.\n    /// @param amount The amount of goo to mint.\n    function mintForGobblers(address to, uint256 amount) public only(artGobblers) {\n        _mint(to, amount);\n    }\n\n    /// @notice Burn any amount of goo from a user. Can only be called by ArtGobblers.\n    /// @param from The address of the user to burn goo from.\n    /// @param amount The amount of goo to burn.\n    function burnForGobblers(address from, uint256 amount) public only(artGobblers) {\n        _burn(from, amount);\n    }\n\n    /// @notice Burn any amount of goo from a user. Can only be called by Pages.\n    /// @param from The address of the user to burn goo from.\n    /// @param amount The amount of goo to burn.\n    function burnForPages(address from, uint256 amount) public only(pages) {\n        _burn(from, amount);\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/ArtGobblers.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\n\nimport {VRFConsumerBase} from \"chainlink/v0.8/VRFConsumerBase.sol\";\n\nimport {VRGDA} from \"./utils/vrgda/VRGDA.sol\";\nimport {LibString} from \"./utils/lib/LibString.sol\";\nimport {LogisticVRGDA} from \"./utils/vrgda/LogisticVRGDA.sol\";\nimport {MerkleProofLib} from \"./utils/lib/MerkleProofLib.sol\";\nimport {GobblersERC1155B} from \"./utils/token/GobblersERC1155B.sol\";\n\nimport {Goo} from \"./Goo.sol\";\n\n/// @title Art Gobblers NFT\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Art Gobblers scan the cosmos in search of art producing life.\ncontract ArtGobblers is GobblersERC1155B, LogisticVRGDA, VRFConsumerBase, Owned, ERC1155TokenReceiver {\n    using LibString for uint256;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Goo ERC20 token contract.\n    Goo public immutable goo;\n\n    /// @notice The address which receives gobblers reserved for the team.\n    address public immutable team;\n\n    /// @notice The address which receives gobblers reserved for the community.\n    address public immutable community;\n\n    /*//////////////////////////////////////////////////////////////\n                            SUPPLY CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maximum number of mintable gobblers.\n    uint256 public constant MAX_SUPPLY = 10000;\n\n    /// @notice Maximum amount of gobblers mintable via mintlist.\n    uint256 public constant MINTLIST_SUPPLY = 2000;\n\n    /// @notice Maximum amount of mintable legendary gobblers.\n    uint256 public constant LEGENDARY_SUPPLY = 10;\n\n    /// @notice Maximum amount of gobblers split between the reserves.\n    /// @dev Set to compromise 20% of the sum of goo mintable gobblers + reserved gobblers.\n    uint256 public constant RESERVED_SUPPLY = (MAX_SUPPLY - MINTLIST_SUPPLY - LEGENDARY_SUPPLY) / 5;\n\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\n    // prettier-ignore\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY\n        - MINTLIST_SUPPLY\n        - LEGENDARY_SUPPLY\n        - RESERVED_SUPPLY;\n\n    /*//////////////////////////////////////////////////////////////\n                           METADATA CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The name displayed for the contract on Etherscan.\n    string public constant name = \"Art Gobblers\";\n\n    /// @notice URI for gobblers that have yet to be revealed.\n    string public UNREVEALED_URI;\n\n    /// @notice Base URI for minted gobblers.\n    string public BASE_URI;\n\n    /*//////////////////////////////////////////////////////////////\n                              VRF CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 internal immutable chainlinkKeyHash;\n\n    uint256 internal immutable chainlinkFee;\n\n    /*//////////////////////////////////////////////////////////////\n                             MINTLIST STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Merkle root of mint mintlist.\n    bytes32 public immutable merkleRoot;\n\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\n    mapping(address => bool) public hasClaimedMintlistGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable mintStart;\n\n    /// @notice Number of gobblers minted from goo.\n    uint128 public numMintedFromGoo;\n\n    /*//////////////////////////////////////////////////////////////\n                         STANDARD GOBBLER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Id of the most recently minted non legendary gobbler.\n    /// @dev Will be 0 if no non legendary gobblers have been minted yet.\n    uint128 public currentNonLegendaryId;\n\n    /// @notice The number of gobblers minted to the reserves.\n    uint256 public numMintedForReserves;\n\n    /*//////////////////////////////////////////////////////////////\n                     LEGENDARY GOBBLER AUCTION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The last LEGENDARY_SUPPLY ids are reserved for legendary gobblers.\n    uint256 public constant FIRST_LEGENDARY_GOBBLER_ID = MAX_SUPPLY - LEGENDARY_SUPPLY + 1;\n\n    /// @notice Legendary auctions begin each time a multiple of these many gobblers have been minted.\n    /// @dev We add 1 to LEGENDARY_SUPPLY because legendary auctions begin only after the first interval.\n    uint256 public constant LEGENDARY_AUCTION_INTERVAL = MAX_MINTABLE / (LEGENDARY_SUPPLY + 1);\n\n    /// @notice Struct holding data required for legendary gobbler auctions.\n    struct LegendaryGobblerAuctionData {\n        // Start price of current legendary gobbler auction.\n        uint128 startPrice;\n        // Number of legendary gobblers sold so far.\n        uint128 numSold;\n    }\n\n    /// @notice Data about the current legendary gobbler auction.\n    LegendaryGobblerAuctionData public legendaryGobblerAuctionData;\n\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding data required for gobbler reveals.\n    struct GobblerRevealsData {\n        // Last random seed obtained from VRF.\n        uint64 randomSeed;\n        // Next reveal cannot happen before this timestamp.\n        uint64 nextRevealTimestamp;\n        // Id of latest gobbler which has been revealed so far.\n        uint56 lastRevealedId;\n        // Remaining gobblers to be revealed with the current seed.\n        uint56 toBeRevealed;\n        // Whether we are waiting to receive a seed from Chainlink.\n        bool waitingForSeed;\n    }\n\n    /// @notice Data about the current state of gobbler reveals.\n    GobblerRevealsData public gobblerRevealsData;\n\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding data required for goo emission calculations.\n    struct EmissionData {\n        // The sum of the multiples of all gobblers the user holds.\n        uint64 emissionMultiple;\n        // Balance at time of last deposit or withdrawal.\n        uint128 lastBalance;\n        // Timestamp of last deposit or withdrawal.\n        uint64 lastTimestamp;\n    }\n\n    /// @notice Maps user addresses to their emission data.\n    mapping(address => EmissionData) public getEmissionDataForUser;\n\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps gobbler ids to NFT contracts and their ids to the # of those NFT ids fed to the gobbler.\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public getCopiesOfArtFedToGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event GooAdded(address indexed user, uint256 gooAdded);\n    event GooRemoved(address indexed user, uint256 gooAdded);\n\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\n    event LegendaryGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\n    event ReservedGobblersMinted(address indexed user, uint256 lastMintedGobblerId, uint256 numGobblersEach);\n\n    event RandomnessRequested(address indexed user, uint256 toBeRevealed);\n    event RandomnessFulfilled(uint256 randomness);\n\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\n\n    event ArtFedToGobbler(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error InvalidProof();\n    error AlreadyClaimed();\n    error MintStartPending();\n\n    error SeedPending();\n    error RevealsPending();\n    error RequestTooEarly();\n    error ZeroToBeRevealed();\n\n    error ReserveImbalance();\n\n    error OwnerMismatch(address owner);\n\n    error NoRemainingLegendaryGobblers();\n    error IncorrectGobblerAmount(uint256 cost);\n    error CannotBurnLegendary(uint256 gobblerId);\n\n    error PriceExceededMax(uint256 currentPrice);\n\n    error NotEnoughRemainingToBeRevealed(uint256 totalRemainingToBeRevealed);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        // Mint config:\n        bytes32 _merkleRoot,\n        uint256 _mintStart,\n        // Addresses:\n        Goo _goo,\n        address _team,\n        address _community,\n        // Chainlink:\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _chainlinkKeyHash,\n        uint256 _chainlinkFee,\n        // URIs:\n        string memory _baseUri,\n        string memory _unrevealedUri\n    )\n        VRGDA(\n            69.42e18, // Initial price.\n            0.31e18 // Per period price decrease.\n        )\n        LogisticVRGDA(\n            // Max mintable gobblers.\n            int256(MAX_MINTABLE * 1e18),\n            0.0023e18 // Time scale.\n        )\n        VRFConsumerBase(_vrfCoordinator, _linkToken)\n        Owned(msg.sender) // Deployer starts as owner.\n    {\n        mintStart = _mintStart;\n        merkleRoot = _merkleRoot;\n\n        goo = _goo;\n        team = _team;\n        community = _community;\n\n        chainlinkKeyHash = _chainlinkKeyHash;\n        chainlinkFee = _chainlinkFee;\n\n        BASE_URI = _baseUri;\n        UNREVEALED_URI = _unrevealedUri;\n\n        // Starting price for legendary gobblers is 69 gobblers.\n        legendaryGobblerAuctionData.startPrice = 69;\n\n        // Reveal for initial mint must wait 24 hours\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          MINTLIST CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Claim from mintlist, using a merkle proof.\n    /// @param proof Merkle proof to verify the sender is mintlisted.\n    /// @return gobblerId The id of the gobbler that was claimed.\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\n        // If minting has not yet begun, revert.\n        if (mintStart > block.timestamp) revert MintStartPending();\n\n        // If the user has already claimed, revert.\n        if (hasClaimedMintlistGobbler[msg.sender]) revert AlreadyClaimed();\n\n        // If the user's proof is invalid, revert.\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert InvalidProof();\n\n        hasClaimedMintlistGobbler[msg.sender] = true; // Before mint to prevent reentrancy.\n\n        unchecked {\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLegendaryId);\n\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a gobbler with goo, burning the cost.\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintFromGoo(uint256 maxPrice) external returns (uint256 gobblerId) {\n        // No need to check mint cap, gobblerPrice()\n        // will revert due to overflow if we reach it.\n        // It will also revert prior to the mint start.\n        uint256 currentPrice = gobblerPrice();\n\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\n\n        goo.burnForGobblers(msg.sender, currentPrice);\n\n        unchecked {\n            ++numMintedFromGoo; // Before mint to prevent reentrancy.\n\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLegendaryId, currentPrice);\n\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n\n    /// @notice Gobbler pricing in terms of goo.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    function gobblerPrice() public view returns (uint256) {\n        // We need checked math here to cause overflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n\n        return getPrice(timeSinceStart, numMintedFromGoo);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     LEGENDARY GOBBLER AUCTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a legendary gobbler by burning multiple standard gobblers.\n    /// @param gobblerIds The ids of the standard gobblers to burn.\n    /// @return gobblerId The id of the legendary gobbler that was minted.\n    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\n        gobblerId = FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold; // Assign id.\n\n        // If the gobbler id would be greater than the max supply, there are no remaining legendaries.\n        if (gobblerId > MAX_SUPPLY) revert NoRemainingLegendaryGobblers();\n\n        // This will revert if the auction hasn't started yet, no need to check here as well.\n        uint256 cost = legendaryGobblerPrice();\n\n        if (gobblerIds.length != cost) revert IncorrectGobblerAmount(cost);\n\n        // Overflow should not occur in here, as most math is on emission multiples, which are inherently small.\n        unchecked {\n            uint256 burnedMultipleTotal; // The legendary's emissionMultiple will be 2x the sum of the gobblers burned.\n\n            /*//////////////////////////////////////////////////////////////\n                                    BATCH BURN LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            // Generate an amounts array locally to use in the event below.\n            uint256[] memory amounts = new uint256[](gobblerIds.length);\n\n            uint256 id; // Storing outside the loop saves ~7 gas per iteration.\n\n            for (uint256 i = 0; i < gobblerIds.length; ++i) {\n                id = gobblerIds[i];\n\n                if (id >= FIRST_LEGENDARY_GOBBLER_ID) revert CannotBurnLegendary(id);\n\n                require(getGobblerData[id].owner == msg.sender, \"WRONG_FROM\");\n\n                burnedMultipleTotal += getGobblerData[id].emissionMultiple;\n\n                getGobblerData[id].owner = address(0);\n\n                amounts[i] = 1;\n            }\n\n            emit TransferBatch(msg.sender, msg.sender, address(0), gobblerIds, amounts);\n\n            /*//////////////////////////////////////////////////////////////\n                                 LEGENDARY MINTING LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            // The shift right by 1 is equivalent to multiplication by 2, used to make\n            // the legendary's emissionMultiple 2x the sum of the multiples of the gobblers burned.\n            // Must be done before minting as the transfer hook will update the user's emissionMultiple.\n            getGobblerData[gobblerId].emissionMultiple = uint48(burnedMultipleTotal << 1);\n\n            // Update the user's emission data in one big batch. We add burnedMultipleTotal to their\n            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that\n            // were burned and hence should have their multiples subtracted from the user's total multiple.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender));\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[msg.sender].emissionMultiple += uint64(burnedMultipleTotal);\n\n            // New start price is the max of 69 and cost * 2. Left shift by 1 is like multiplication by 2.\n            legendaryGobblerAuctionData.startPrice = uint120(cost < 35 ? 69 : cost << 1);\n            legendaryGobblerAuctionData.numSold += 1; // Increment the # of legendaries sold.\n\n            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.\n            emit LegendaryGobblerMinted(msg.sender, gobblerId, gobblerIds);\n\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n\n    /// @notice Calculate the legendary gobbler price in terms of gobblers, according to a linear decay function.\n    /// @dev The price of a legendary gobbler decays as gobblers are minted. The first legendary auction begins when\n    /// 1 LEGENDARY_AUCTION_INTERVAL worth of gobblers are minted, and the price decays linearly while the next interval of\n    /// gobblers is minted. Every time an additional interval is minted, a new auction begins until all legendaries been sold.\n    function legendaryGobblerPrice() public view returns (uint256) {\n        // Retrieve and cache the auction's startPrice and numSold on the stack.\n        uint256 startPrice = legendaryGobblerAuctionData.startPrice;\n        uint256 numSold = legendaryGobblerAuctionData.numSold;\n\n        uint256 numMintedAtStart; // The number of gobblers minted at the start of the auction.\n\n        unchecked {\n            // The number of gobblers minted at the start of the auction is computed by multiplying the # of\n            // intervals that must pass before the next auction begins by the number of gobblers in each interval.\n            numMintedAtStart = (numSold + 1) * LEGENDARY_AUCTION_INTERVAL;\n        }\n\n        // How many gobblers where minted since auction began. Cannot be\n        // unchecked, we want this to revert if auction has not yet started.\n        uint256 numMintedSinceStart = numMintedFromGoo - numMintedAtStart;\n\n        unchecked {\n            // If we've minted the full interval or beyond it, the price has decayed to 0.\n            if (numMintedSinceStart >= LEGENDARY_AUCTION_INTERVAL) return 0;\n            // Otherwise decay the price linearly based on what fraction of the interval has been minted.\n            else return (startPrice * (LEGENDARY_AUCTION_INTERVAL - numMintedSinceStart)) / LEGENDARY_AUCTION_INTERVAL;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                VRF LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Request a new random seed for revealing gobblers.\n    /// @dev Can only be called every 24 hours at the earliest.\n    function requestRandomSeed() external returns (bytes32) {\n        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;\n\n        // A new random seed cannot be requested before the next reveal timestamp.\n        if (block.timestamp < nextRevealTimestamp) revert RequestTooEarly();\n\n        // A random seed can only be requested when all gobblers from the previous seed have been revealed.\n        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.\n        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();\n\n        unchecked {\n            // Prevent revealing while we wait for the seed.\n            gobblerRevealsData.waitingForSeed = true;\n\n            // Compute the number of gobblers to be revealed with the seed.\n            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;\n\n            // Ensure that there are more than 0 gobblers to be revealed,\n            // otherwise the contract could waste LINK revealing nothing.\n            if (toBeRevealed == 0) revert ZeroToBeRevealed();\n\n            // Lock in the number of gobblers to be revealed from seed.\n            gobblerRevealsData.toBeRevealed = uint56(toBeRevealed);\n\n            // We want at most one batch of reveals every 24 hours.\n            // Timestamp overflow is impossible on human timescales.\n            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);\n\n            emit RandomnessRequested(msg.sender, toBeRevealed);\n        }\n\n        // Will revert if we don't have enough LINK to afford the request.\n        return requestRandomness(chainlinkKeyHash, chainlinkFee);\n    }\n\n    /// @notice Callback from Chainlink VRF. Sets randomSeed.\n    function fulfillRandomness(bytes32, uint256 randomness) internal override {\n        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.\n        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.\n\n        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.\n\n        emit RandomnessFulfilled(randomness);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Knuth shuffle to progressively reveal gobblers using entropy from random seed.\n    /// @param numGobblers The number of gobblers to reveal.\n    function revealGobblers(uint256 numGobblers) external {\n        uint256 randomSeed = gobblerRevealsData.randomSeed;\n\n        uint256 lastRevealedId = gobblerRevealsData.lastRevealedId;\n\n        uint256 totalRemainingToBeRevealed = gobblerRevealsData.toBeRevealed;\n\n        // Can't reveal if we're still waiting for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert SeedPending();\n\n        // Can't reveal more gobblers than are currently remaining to be revealed with the seed.\n        if (numGobblers > totalRemainingToBeRevealed) revert NotEnoughRemainingToBeRevealed(totalRemainingToBeRevealed);\n\n        // Implements a Knuth shuffle. If something in\n        // here can overflow we've got bigger problems.\n        unchecked {\n            for (uint256 i = 0; i < numGobblers; ++i) {\n                /*//////////////////////////////////////////////////////////////\n                                      DETERMINE RANDOM SWAP\n                //////////////////////////////////////////////////////////////*/\n\n                // Number of ids that have not been revealed. Subtract 1\n                // because we don't want to include any legendaries in the swap.\n                uint256 remainingIds = FIRST_LEGENDARY_GOBBLER_ID - lastRevealedId - 1;\n\n                // Randomly pick distance for swap.\n                uint256 distance = randomSeed % remainingIds;\n\n                // Current id is consecutive to last reveal.\n                uint256 currentId = ++lastRevealedId;\n\n                // Select swap id, adding distance to next reveal id.\n                uint256 swapId = currentId + distance;\n\n                /*//////////////////////////////////////////////////////////////\n                                       GET INDICES FOR IDS\n                //////////////////////////////////////////////////////////////*/\n\n                // Get the index of the swap id.\n                uint48 swapIndex = getGobblerData[swapId].idx == 0\n                    ? uint48(swapId) // Hasn't been shuffled before.\n                    : getGobblerData[swapId].idx; // Shuffled before.\n\n                // Get the owner of the current id.\n                address currentIdOwner = getGobblerData[currentId].owner;\n\n                // Get the index of the current id.\n                uint48 currentIndex = getGobblerData[currentId].idx == 0\n                    ? uint48(currentId) // Hasn't been shuffled before.\n                    : getGobblerData[currentId].idx; // Shuffled before.\n\n                /*//////////////////////////////////////////////////////////////\n                                  SWAP INDICES AND SET MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n\n                // Determine the current id's new emission multiple.\n                uint256 newCurrentIdMultiple = 9; // For beyond 7963.\n\n                // The branchless expression below is equivalent to:\n                //      if (swapIndex <= 3054) newCurrentIdMultiple = 6;\n                // else if (swapIndex <= 5672) newCurrentIdMultiple = 7;\n                // else if (swapIndex <= 7963) newCurrentIdMultiple = 8;\n                assembly {\n                    // prettier-ignore\n                    newCurrentIdMultiple := sub(sub(sub(\n                        newCurrentIdMultiple,\n                        lt(swapIndex, 7964)),\n                        lt(swapIndex, 5673)),\n                        lt(swapIndex, 3055)\n                    )\n                }\n\n                // Swap the index and multiple of the current id.\n                getGobblerData[currentId].idx = swapIndex;\n                getGobblerData[currentId].emissionMultiple = uint48(newCurrentIdMultiple);\n\n                // Swap the index of the swap id.\n                getGobblerData[swapId].idx = currentIndex;\n\n                /*//////////////////////////////////////////////////////////////\n                                   UPDATE CURRENT ID MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n\n                // Update the emission data for the owner of the current id.\n                getEmissionDataForUser[currentIdOwner].lastBalance = uint128(gooBalance(currentIdOwner));\n                getEmissionDataForUser[currentIdOwner].lastTimestamp = uint64(block.timestamp);\n                getEmissionDataForUser[currentIdOwner].emissionMultiple += uint64(newCurrentIdMultiple);\n\n                // Update the random seed to choose a new distance for the next iteration.\n                // It is critical that we cast to uint64 here, as otherwise the random seed\n                // set after calling revealGobblers(1) thrice would differ from the seed set\n                // after calling revealGobblers(3) a single time. This would enable an attacker\n                // to choose from a number of different seeds and use whichever is most favorable.\n                // Equivalent to randomSeed = uint64(uint256(keccak256(abi.encodePacked(randomSeed))))\n                assembly {\n                    mstore(0, randomSeed) // Store the random seed in scratch space.\n\n                    // Moduloing by 1 << 64 (2 ** 64) is equivalent to a uint64 cast.\n                    randomSeed := mod(keccak256(0, 32), shl(64, 1))\n                }\n            }\n\n            // Update all relevant reveal state state.\n            gobblerRevealsData.randomSeed = uint64(randomSeed);\n            gobblerRevealsData.lastRevealedId = uint56(lastRevealedId);\n            gobblerRevealsData.toBeRevealed = uint56(totalRemainingToBeRevealed - numGobblers);\n\n            emit GobblersRevealed(msg.sender, numGobblers, lastRevealedId);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns a token's URI if it has been minted.\n    /// @param gobblerId The id of the token to get the URI for.\n    function uri(uint256 gobblerId) public view virtual override returns (string memory) {\n        // Between 0 and lastRevealed are revealed normal gobblers.\n        if (gobblerId <= gobblerRevealsData.lastRevealedId) {\n            // 0 is not a valid id:\n            if (gobblerId == 0) return \"\";\n\n            return string(abi.encodePacked(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString()));\n        }\n\n        // Between lastRevealed + 1 and currentNonLegendaryId are minted but not revealed.\n        if (gobblerId <= currentNonLegendaryId) return UNREVEALED_URI;\n\n        // Between currentNonLegendaryId and FIRST_LEGENDARY_GOBBLER_ID are unminted.\n        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID) return \"\";\n\n        // Between FIRST_LEGENDARY_GOBBLER_ID and FIRST_LEGENDARY_GOBBLER_ID + numSold are minted legendaries.\n        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold)\n            return string(abi.encodePacked(BASE_URI, gobblerId.toString()));\n\n        return \"\"; // Unminted legendaries and invalid token ids.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Feed a gobbler a work of art.\n    /// @param gobblerId The gobbler to feed the work of art.\n    /// @param nft The ERC721 or ERC1155 contract of the work of art.\n    /// @param id The id of the work of art.\n    /// @param isERC1155 Whether the work of art is an ERC1155 token.\n    function feedArt(\n        uint256 gobblerId,\n        address nft,\n        uint256 id,\n        bool isERC1155\n    ) external {\n        // Get the owner of the gobbler to feed.\n        address owner = getGobblerData[gobblerId].owner;\n\n        // The caller must own the gobbler they're feeding.\n        if (owner != msg.sender) revert OwnerMismatch(owner);\n\n        unchecked {\n            // Increment the number of copies fed to the gobbler.\n            // Counter overflow is unrealistic on human timescales.\n            ++getCopiesOfArtFedToGobbler[gobblerId][nft][id];\n        }\n\n        emit ArtFedToGobbler(msg.sender, gobblerId, nft, id);\n\n        isERC1155\n            ? ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, \"\")\n            : ERC721(nft).transferFrom(msg.sender, address(this), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculate a user's staked goo balance.\n    /// @param user The user to query balance for.\n    function gooBalance(address user) public view returns (uint256) {\n        // If a user's goo balance is greater than\n        // 2**256 - 1 we've got much bigger problems.\n        unchecked {\n            uint256 emissionMultiple = getEmissionDataForUser[user].emissionMultiple;\n            uint256 lastBalanceWad = getEmissionDataForUser[user].lastBalance;\n\n            // Stored with 18 decimals, such that if a day and a half elapsed this variable would equal 1.5e18.\n            uint256 daysElapsedWad = ((block.timestamp - getEmissionDataForUser[user].lastTimestamp) * 1e18) / 1 days;\n\n            uint256 daysElapsedSquaredWad = daysElapsedWad.mulWadDown(daysElapsedWad); // Need to use wad math here.\n\n            // prettier-ignore\n            return lastBalanceWad + // The last recorded balance.\n\n            // Don't need to do wad multiplication since we're\n            // multiplying by a plain integer with no decimals.\n            // Shift right by 2 is equivalent to division by 4.\n            ((emissionMultiple * daysElapsedSquaredWad) >> 2) +\n\n            daysElapsedWad.mulWadDown( // Terms are wads, so must mulWad.\n                // No wad multiplication for emissionMultiple * lastBalance\n                // because emissionMultiple is a plain integer with no decimals.\n                // We multiply the sqrt's radicand by 1e18 because it expects ints.\n                (emissionMultiple * lastBalanceWad * 1e18).sqrt()\n            );\n        }\n    }\n\n    /// @notice Add goo to your emission balance.\n    /// @param gooAmount The amount of goo to add.\n    function addGoo(uint256 gooAmount) external {\n        // Burn goo being added to gobbler.\n        goo.burnForGobblers(msg.sender, gooAmount);\n\n        unchecked {\n            // If a user has enough goo to overflow their balance we've got big problems.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender) + gooAmount);\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n        }\n\n        emit GooAdded(msg.sender, gooAmount);\n    }\n\n    /// @notice Remove goo from your emission balance.\n    /// @param gooAmount The amount of goo to remove.\n    function removeGoo(uint256 gooAmount) external {\n        // Will revert due to underflow if removed amount is larger than the user's current goo balance.\n        getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender) - gooAmount);\n        getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n\n        goo.mintForGobblers(msg.sender, gooAmount);\n\n        emit GooRemoved(msg.sender, gooAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     RESERVED GOBBLERS MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a number of gobblers to the reserves.\n    /// @param numGobblersEach The number of gobblers to mint to each reserve.\n    /// @dev Gobblers minted to reserves cannot compromise more than 20% of the sum of\n    /// the supply of goo minted gobblers and the supply of gobblers minted to reserves.\n    function mintReservedGobblers(uint256 numGobblersEach) external returns (uint256 lastMintedGobblerId) {\n        unchecked {\n            // Optimistically increment numMintedForReserves, may be reverted below. Overflow in this\n            // calculation is possible but numGobblersEach would have to be so large that it would cause the\n            // loop in _batchMint to run out of gas quickly. Shift left by 1 is equivalent to multiplying by 2.\n            uint256 newNumMintedForReserves = numMintedForReserves += (numGobblersEach << 1);\n\n            // Ensure that after this mint gobblers minted to reserves won't compromise more than 20% of\n            // the sum of the supply of goo minted gobblers and the supply of gobblers minted to reserves.\n            if (newNumMintedForReserves > (numMintedFromGoo + newNumMintedForReserves) / 5) revert ReserveImbalance();\n        }\n\n        // Mint numGobblersEach gobblers to both the team and community reserve.\n        lastMintedGobblerId = _batchMint(team, numGobblersEach, currentNonLegendaryId, \"\");\n        lastMintedGobblerId = _batchMint(community, numGobblersEach, lastMintedGobblerId, \"\");\n\n        // Note: There is reentrancy here. The _batchMint calls above can enable an\n        // adversary to reenter before currentNonLegendaryId is updated, but since we\n        // assume the reserves are both trusted addresses, we can safely ignore this risk.\n        currentNonLegendaryId = uint128(lastMintedGobblerId); // Set currentNonLegendaryId.\n\n        emit ReservedGobblersMinted(msg.sender, lastMintedGobblerId, numGobblersEach);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          CONVENIENCE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Convenience function to get emission emissionMultiple for a gobbler.\n    /// @param gobblerId The gobbler to get emissionMultiple for.\n    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {\n        return getGobblerData[gobblerId].emissionMultiple;\n    }\n\n    /// @notice Convenience function to get emission emissionMultiple for a user.\n    /// @param user The user to get emissionMultiple for.\n    function getUserEmissionMultiple(address user) external view returns (uint256) {\n        return getEmissionDataForUser[user].emissionMultiple;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155B LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public override {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        unchecked {\n            uint64 emissionsMultipleTotal; // Will use to set each user's multiple.\n\n            for (uint256 i = 0; i < ids.length; i++) {\n                id = ids[i];\n                amount = amounts[i];\n\n                // Can only transfer from the owner.\n                require(from == getGobblerData[id].owner, \"WRONG_FROM\");\n\n                // Can only transfer 1 with ERC1155B.\n                require(amount == 1, \"INVALID_AMOUNT\");\n\n                getGobblerData[id].owner = to;\n\n                emissionsMultipleTotal += getGobblerData[id].emissionMultiple;\n            }\n\n            transferUserEmissionMultiple(from, to, emissionsMultipleTotal);\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public override {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        require(from == getGobblerData[id].owner, \"WRONG_FROM\"); // Can only transfer from the owner.\n\n        // Can only transfer 1 with ERC1155B.\n        require(amount == 1, \"INVALID_AMOUNT\");\n\n        getGobblerData[id].owner = to;\n\n        transferUserEmissionMultiple(from, to, getGobblerData[id].emissionMultiple);\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Transfer an amount of a user's emission's multiple to another user.\n    /// @dev Should be done whenever a gobbler is transferred between two users.\n    /// @param from The user to transfer the amount of emission multiple from.\n    /// @param to The user to transfer the amount of emission multiple to.\n    /// @param emissionMultiple The amount of emission multiple to transfer.\n    function transferUserEmissionMultiple(\n        address from,\n        address to,\n        uint64 emissionMultiple\n    ) internal {\n        unchecked {\n            // Decrease the from user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[from].lastBalance = uint128(gooBalance(from));\n            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[from].emissionMultiple -= emissionMultiple;\n\n            // Increase the to user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[to].lastBalance = uint128(gooBalance(to));\n            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[to].emissionMultiple += emissionMultiple;\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/GobblerReserve.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\n\nimport {ArtGobblers} from \"../ArtGobblers.sol\";\n\n/// @title Gobbler Reserve\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Reserves gobblers for an owner while keeping any goo produced.\ncontract GobblerReserve is Owned, ERC1155TokenReceiver {\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n    ArtGobblers public artGobblers;\n\n    constructor(ArtGobblers _artGobblers, address _owner) Owned(_owner) {\n        artGobblers = _artGobblers;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Withdraw gobblers from the reserve.\n    /// @param to The address to transfer the gobblers to.\n    /// @param ids The ids of the gobblers to transfer.\n    function withdraw(address to, uint256[] calldata ids) public onlyOwner {\n        unchecked {\n            // Generating this in memory is pretty expensive\n            // but this is not a hot path so we can afford it.\n            uint256[] memory amounts = new uint256[](ids.length);\n            for (uint256 i = 0; i < ids.length; i++) amounts[i] = 1;\n\n            artGobblers.safeBatchTransferFrom(address(this), to, ids, amounts, \"\");\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/lib/SignedWadMath.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Signed Wad Math\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Efficient signed wad arithmetic.\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\n    assembly {\n        // Multiply x by 1e18.\n        r := mul(x, 1000000000000000000)\n    }\n}\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Multiply x by y and divide by 1e18.\n        r := sdiv(mul(x, y), 1000000000000000000)\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero and will\n/// not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Multiply x by 1e18 and divide it by y.\n        r := sdiv(mul(x, 1000000000000000000), y)\n    }\n}\n\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Store x * y in r for now.\n        r := mul(x, y)\n\n        // Equivalent to require(x == 0 || (x * y) / x == y)\n        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {\n            revert(0, 0)\n        }\n\n        // Scale the result down by 1e18.\n        r := sdiv(r, 1000000000000000000)\n    }\n}\n\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Store x * 1e18 in r for now.\n        r := mul(x, 1000000000000000000)\n\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\n            revert(0, 0)\n        }\n\n        // Divide r by y.\n        r := sdiv(r, y)\n    }\n}\n\nfunction wadExp(int256 x) pure returns (int256 r) {\n    unchecked {\n        // When the result is < 0.5 we return zero. This happens when\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n        if (x <= -42139678854452767551) return 0;\n\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n        if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n        // for more intermediate precision and a binary basis. This base conversion\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n        x = (x << 78) / 5**18;\n\n        // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n        x = x - k * 54916777467707473351141471128;\n\n        // k is in the range [-61, 195].\n\n        // Evaluate using a (6, 7)-term rational approximation.\n        // p is made monic, we'll multiply by a scale factor later.\n        int256 y = x + 1346386616545796478920950773328;\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\n        int256 p = y + x - 94201549194550492254356042504812;\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n        p = p * x + (4385272521454847904659076985693276 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        int256 q = x - 2855989394907223263936484059900;\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\n            // No scaling is necessary because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r should be in the range (0.09, 0.25) * 2**96.\n\n        // We now need to multiply r by:\n        // * the scale factor s = ~6.031367120.\n        // * the 2**k factor from the range reduction.\n        // * the 1e18 / 2**96 factor for base conversion.\n        // We do this all at once, with an intermediate result in 2**213\n        // basis, so the final right shift is always by a positive amount.\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n    }\n}\n\nfunction wadLn(int256 x) pure returns (int256 r) {\n    unchecked {\n        require(x > 0, \"UNDEFINED\");\n\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n        // We do this by multiplying by 2**96 / 10**18. But since\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n        // and add ln(2**96 / 10**18) at the end.\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n\n        // Reduce range of x to (1, 2) * 2**96\n        // ln(2^k * x) = k * ln(2) + ln(x)\n        int256 k = r - 96;\n        x <<= uint256(159 - k);\n        x = int256(uint256(x) >> 159);\n\n        // Evaluate using a (8, 8)-term rational approximation.\n        // p is made monic, we will multiply by a scale factor later.\n        int256 p = x + 3273285459638523848632254066296;\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\n        p = p * x - (795164235651350426258249787498 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        // q is monic by convention.\n        int256 q = x + 5573035233440673466300451813936;\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r is in the range (0, 0.125) * 2**96\n\n        // Finalization, we need to:\n        // * multiply by the scale factor s = 5.549\u2026\n        // * add ln(2**96 / 10**18)\n        // * add k * ln(2)\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n        r *= 1677202110996718588342820967067443963516166;\n        // add ln(2) * k * 5e18 * 2**192\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n        // base conversion: mul 2**18 / 2**192\n        r >>= 174;\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero.\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Divide x by y.\n        r := sdiv(x, y)\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/lib/MerkleProofLib.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized merkle proof verification library.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/MerkleProofLib.sol)\nlibrary MerkleProofLib {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool isValid) {\n        assembly {\n            let computedHash := leaf // The hash starts as the leaf hash.\n\n            // Initialize data to the offset of the proof in the calldata.\n            let data := proof.offset\n\n            // Iterate over proof elements to compute root hash.\n            for {\n                // Left shifting by 5 is like multiplying by 32.\n                let end := add(data, shl(5, proof.length))\n            } lt(data, end) {\n                data := add(data, 32) // Shift 1 word per cycle.\n            } {\n                // Load the current proof element.\n                let loadedData := calldataload(data)\n\n                // Slot where computedHash should be put in scratch space.\n                // If computedHash > loadedData: slot 32, otherwise: slot 0.\n                let computedHashSlot := shl(5, gt(computedHash, loadedData))\n\n                // Store elements to hash contiguously in scratch space.\n                // The xor puts loadedData in whichever slot computedHash is\n                // not occupying, so 0 if computedHashSlot is 32, 32 otherwise.\n                mstore(computedHashSlot, computedHash)\n                mstore(xor(computedHashSlot, 32), loadedData)\n\n                computedHash := keccak256(0, 64) // Hash both slots of scratch space.\n            }\n\n            isValid := eq(computedHash, root) // The proof is valid if the roots match.\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/lib/LibString.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 n) internal pure returns (string memory str) {\n        if (n == 0) return \"0\"; // Otherwise it'd output an empty string for 0.\n\n        assembly {\n            let k := 78 // Start with the max length a uint256 string could be.\n\n            // We'll store our string at the first chunk of free memory.\n            str := mload(0x40)\n\n            // The length of our string will start off at the max of 78.\n            mstore(str, k)\n\n            // Update the free memory pointer to prevent overriding our string.\n            // Add 128 to the str pointer instead of 78 because we want to maintain\n            // the Solidity convention of keeping the free memory pointer word aligned.\n            mstore(0x40, add(str, 128))\n\n            // We'll populate the string from right to left.\n            // prettier-ignore\n            for {} n {} {\n                // The ASCII digit offset for '0' is 48.\n                let char := add(48, mod(n, 10))\n\n                // Write the current character into str.\n                mstore(add(str, k), char)\n\n                k := sub(k, 1)\n                n := div(n, 10)\n            }\n\n            // Shift the pointer to the start of the string.\n            str := add(str, k)\n\n            // Set the length of the string to the correct value.\n            mstore(str, sub(78, k))\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/token/PagesERC721.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\n\n/// @notice ERC721 implementation optimized for Pages by pre-approving them to the ArtGobblers contract.\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract PagesERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable artGobblers;\n\n    constructor(\n        address _artGobblers,\n        string memory _name,\n        string memory _symbol\n    ) {\n        name = _name;\n        symbol = _symbol;\n        artGobblers = _artGobblers;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) internal _isApprovedForAll;\n\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool isApproved) {\n        if (operator == artGobblers) return true; // Skip approvals for the ArtGobblers contract.\n\n        return _isApprovedForAll[owner][operator];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        if (to.code.length != 0)\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        if (to.code.length != 0)\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        // Does not check the token has not been already minted\n        // or is being minted to address(0) because ids in Pages.sol\n        // are set using a monotonically increasing counter and only\n        // minted to safe addresses or msg.sender who cannot be zero.\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/token/GobblersERC1155B.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\n\n/// @notice ERC1155B implementation optimized for ArtGobblers by using the ownerOf storage slot to store attribute data.\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/tokens/ERC1155B.sol)\nabstract contract GobblersERC1155B {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                        GOBBLERS/ERC1155B STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding gobbler data.\n    struct GobblerData {\n        // The current owner of the gobbler.\n        address owner;\n        // Index of token after shuffle.\n        uint48 idx;\n        // Multiple on goo issuance.\n        uint48 emissionMultiple;\n    }\n\n    mapping(uint256 => GobblerData) public getGobblerData;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        return getGobblerData[id].owner;\n    }\n\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 bal) {\n        address idOwner = getGobblerData[id].owner;\n\n        assembly {\n            // We avoid branching by using assembly to take\n            // the bool output of eq() and use it as a uint.\n            bal := eq(idOwner, owner)\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual;\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf(owners[i], ids[i]);\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           INTERNAL MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        getGobblerData[id].owner = to;\n\n        // Does not check if the token was already minted because new ids in\n        // ArtGobblers.sol are set using a monotonically increasing counter.\n\n        emit TransferSingle(msg.sender, address(0), to, id, 1);\n\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, 1, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n\n    function _batchMint(\n        address to,\n        uint256 amount,\n        uint256 lastMintedId,\n        bytes memory data\n    ) internal returns (uint256) {\n        // Allocate arrays before entering the loop.\n        uint256[] memory ids = new uint256[](amount);\n        uint256[] memory amounts = new uint256[](amount);\n\n        // Counter overflow is unrealistic on human timescales.\n        unchecked {\n            for (uint256 i = 0; i < amount; ++i) {\n                ids[i] = ++lastMintedId; // Increment id while setting.\n\n                amounts[i] = 1; // ERC1155B amounts are always 1.\n\n                getGobblerData[lastMintedId].owner = to;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n\n        return lastMintedId; // Return the new last minted id.\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/vrgda/PostSwitchVRGDA.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {unsafeWadDiv} from \"../lib/SignedWadMath.sol\";\n\nimport {VRGDA} from \"./VRGDA.sol\";\n\n/// @title \"Post Switch\" Variable Rate Gradual Dutch Auction\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Abstract VRGDA with a (translated) linear issuance curve.\nabstract contract PostSwitchVRGDA is VRGDA {\n    /*//////////////////////////////////////////////////////////////\n                           PRICING PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev The number of tokens sold at the time of the switch.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable soldBySwitch;\n\n    /// @dev The day soldBySwitch tokens were targeted to sell by.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable switchDay;\n\n    /// @dev The total number of tokens to target selling each day.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable perDay;\n\n    constructor(\n        int256 _soldBySwitch,\n        int256 _switchDay,\n        int256 _perDay\n    ) {\n        soldBySwitch = _soldBySwitch;\n        switchDay = _switchDay;\n        perDay = _perDay;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function getTargetDayForNextSale(int256 sold) internal view virtual override returns (int256) {\n        unchecked {\n            return unsafeWadDiv(sold - soldBySwitch, perDay) + switchDay;\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/vrgda/LogisticVRGDA.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {wadExp, wadLn, unsafeDiv, unsafeWadDiv} from \"../lib/SignedWadMath.sol\";\n\nimport {VRGDA} from \"./VRGDA.sol\";\n\n/// @title Logistic Variable Rate Gradual Dutch Auction\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Abstract VRGDA with a logistic issuance curve.\nabstract contract LogisticVRGDA is VRGDA {\n    /*//////////////////////////////////////////////////////////////\n                           PRICING PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Controls the curve's maximum value which\n    /// controls the maximum number of tokens to sell.\n    /// @dev Represented as a 36 decimal fixed point number.\n    int256 internal immutable logisticScale;\n\n    /// @dev Time scale controls the steepness of the logistic curve,\n    /// which effects how quickly we will reach the curve's asymptote.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable timeScale;\n\n    /// @dev The initial value the uninverted logistic formula would output.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable initialLogisticValue;\n\n    constructor(int256 _maxMintable, int256 _timeScale) {\n        // We need to double _maxMintable to account for initialLogisticValue\n        // and use 18 decimals to avoid wad multiplication in getTargetSaleDay.\n        logisticScale = _maxMintable * 2e18;\n\n        initialLogisticValue = _maxMintable;\n\n        timeScale = _timeScale;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function getTargetDayForNextSale(int256 sold) internal view virtual override returns (int256) {\n        unchecked {\n            return -unsafeWadDiv(wadLn(unsafeDiv(logisticScale, sold + initialLogisticValue) - 1e18), timeScale);\n        }\n    }\n}\n\n\n================================================"
      },
      {
        "path": "/src/utils/vrgda/VRGDA.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {wadExp, wadLn, wadMul, unsafeWadMul, toWadUnsafe} from \"../lib/SignedWadMath.sol\";\n\n/// @title Variable Rate Gradual Dutch Auction\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Sell tokens roughly according to an issuance schedule.\nabstract contract VRGDA {\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initial price of each token, to be scaled according to sales rate.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 public immutable initialPrice;\n\n    /// @dev Precomputed constant that allows us to rewrite a pow() as an exp().\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable decayConstant;\n\n    constructor(int256 _initialPrice, int256 periodPriceDecrease) {\n        initialPrice = _initialPrice;\n\n        decayConstant = wadLn(1e18 - periodPriceDecrease);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculate the price of a token according to the VRGDA formula.\n    /// @param timeSinceStart The time since actions began, in seconds.\n    /// @param sold The number of tokens that have been sold so far.\n    function getPrice(uint256 timeSinceStart, uint256 sold) public view returns (uint256) {\n        unchecked {\n            // prettier-ignore\n            return uint256(wadMul(initialPrice, wadExp(unsafeWadMul(decayConstant,\n                // Theoretically calling toWadUnsafe with timeSinceStart and sold can overflow without\n                // detection, but under any reasonable circumstance they will never be large enough.\n                (toWadUnsafe(timeSinceStart) / 1 days) - getTargetDayForNextSale(toWadUnsafe(sold))\n            ))));\n        }\n    }\n\n    /// @dev Given the number of tokens sold so far, return the target day the next token should be sold by.\n    /// @param sold The number of tokens that have been sold so far, where 0 means none, scaled by 1e18.\n    /// @return The target day that the next token should be sold by, scaled by 1e18, where the day\n    /// is relative, such that 0 means the token should be sold immediately when auctions begin.\n    function getTargetDayForNextSale(int256 sold) internal view virtual returns (int256);\n}\n\n\n\n    /// @notice Calculate the price of a token according to the VRGDA formula.\n    /// @param timeSinceStart The time since actions began, in seconds.\n    /// @param sold The number of tokens that have been sold so far.\n    function getPrice(uint256 timeSinceStart, uint256 sold) public view returns (uint256) {\n        unchecked {\n            // prettier-ignore\n            return uint256(wadMul(initialPrice, wadExp(unsafeWadMul(decayConstant,\n                // Theoretically calling toWadUnsafe with timeSinceStart and sold can overflow without\n                // detection, but under any reasonable circumstance they will never be large enough.\n                (toWadUnsafe(timeSinceStart) / 1 days) - getTargetDayForNextSale(toWadUnsafe(sold))\n            ))));\n        }\n    }\n\n    /// @dev Given the number of tokens sold so far, return the target day the next token should be sold by.\n    /// @param sold The number of tokens that have been sold so far, where 0 means none, scaled by 1e18.\n    /// @return The target day that the next token should be sold by, scaled by 1e18, where the day\n    /// is relative, such that 0 means the token should be sold immediately when auctions begin.\n    function getTargetDayForNextSale(int256 sold) internal view virtual returns (int256);\n}"
      }
    ]
  }
}