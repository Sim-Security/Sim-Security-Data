Directory structure:
└── artgobblers-art-gobblers
    ├── .prettierrc
    ├── analysis
    │   ├── compute_emissions.py
    │   ├── compute_price.py
    │   ├── requirements.txt
    │   ├── pricer.py
    │   └── README.md
    ├── .prettierignore
    ├── .gas-snapshot
    ├── remappings.txt
    ├── .github
    │   └── workflows
    │       └── tests.yml
    ├── assets
    │   └── state-machines
    ├── .solhint.json
    ├── test
    │   ├── Optimizations.t.sol
    │   ├── deploy
    │   │   └── DeployRinkeby.t.sol
    │   ├── GobblerReserve.t.sol
    │   ├── MerkleProofLib.t.sol
    │   ├── Pages.t.sol
    │   ├── SignedWadMath.t.sol
    │   ├── correctness
    │   │   ├── GobblersCorrectness.t.sol
    │   │   ├── PagesCorrectness.t.sol
    │   │   └── EmissionCorrectness.t.sol
    │   ├── LibString.t.sol
    │   ├── Benchmarks.t.sol
    │   ├── Goo.t.sol
    │   ├── ArtGobblers.t.sol
    │   ├── utils
    │   │   ├── LibRLP.sol
    │   │   ├── Console.sol
    │   │   ├── mocks
    │   │   │   ├── MockGooCalculator.sol
    │   │   │   └── LinkToken.sol
    │   │   └── Utilities.sol
    │   └── VRGDAs.t.sol
    ├── .gitmodules
    ├── lib
    │   ├── chainlink
    │   ├── ds-test
    │   ├── forge-std
    │   └── solmate
    ├── script
    │   └── deploy
    │       ├── DeployRinkeby.s.sol
    │       └── DeployBase.s.sol
    ├── foundry.toml
    ├── package.json
    ├── README.md
    └── src
        ├── Pages.sol
        ├── Goo.sol
        ├── ArtGobblers.sol
        └── utils
            ├── GobblerReserve.sol
            ├── lib
            │   ├── SignedWadMath.sol
            │   ├── MerkleProofLib.sol
            │   └── LibString.sol
            ├── token
            │   ├── PagesERC721.sol
            │   └── GobblersERC1155B.sol
            └── vrgda
                ├── PostSwitchVRGDA.sol
                ├── LogisticVRGDA.sol
                └── VRGDA.sol


Files Content:

================================================
File: /.prettierrc
================================================
{
  "tabWidth": 2,
  "printWidth": 100,

  "overrides": [
    {
      "files": "*.sol",
      "options": {
        "tabWidth": 4,
        "printWidth": 120
      }
    }
  ]
}


================================================
File: /analysis/compute_emissions.py
================================================
from eth_abi import encode_single
import math
import argparse

def compute_emissions(time, initial_amount, staking_multiple): 
    t1 = math.sqrt(staking_multiple) * time + 2 * math.sqrt(initial_amount)
    final_amount = 0.25 * t1 * t1

    final_amount *= (10 ** 18)
    encode_and_print(final_amount)

def encode_and_print(price):
    enc = encode_single('uint256', int(price))
    ## append 0x for FFI parsing 
    print("0x" + enc.hex())

def parse_args(): 
    parser = argparse.ArgumentParser()
    parser.add_argument("--time", type=int)
    parser.add_argument("--initial_amount", type=int)
    parser.add_argument("--emission_multiple", type=int)
    return parser.parse_args()

if __name__ == '__main__':
    args = parse_args() 
    compute_emissions(
        args.time / (10 ** 18)
        , args.initial_amount / (10 ** 18)
        , args.emission_multiple)

================================================
File: /analysis/compute_price.py
================================================
from pricer import Pricer
from eth_abi import encode_single
import argparse

def main(args): 
    if (args.type == 'gobblers'): 
        calculate_gobblers_price(args)
    elif (args.type == 'pages'):
        calculate_pages_price(args)
    
def calculate_gobblers_price(args): 
    pricer = Pricer()
    price = pricer.compute_gobbler_price(
        args.time_since_start / (60 * 60 * 24), ## convert to seconds 
        args.num_sold, 
        args.initial_price / (10 ** 18), ## scale decimals 
        args.per_period_price_decrease / (10 ** 18), ## scale decimals 
        args.logistic_scale / (10 ** 18), ## scale decimals 
        args.time_scale / (10 ** 18), ## scale decimals 
        0
    )
    price *= (10 ** 18)
    encode_and_print(price)

def calculate_pages_price(args): 
    pricer = Pricer()
    price = pricer.compute_page_price(
        args.time_since_start / (60 * 60 * 24), ## convert to seconds 
        args.num_sold, 
        args.initial_price / (10 ** 18), ## scale decimals 
        args.per_period_price_decrease / (10 ** 18), ## scale decimals 
        args.logistic_scale / (10 ** 18), ## scale decimals 
        args.time_scale / (10 ** 18), ## scale decimals 
        0,
        args.per_period_post_switchover / (10 ** 18), ## scale decimals 
        args.switchover_time / (10 ** 18)
    )
    price *= (10 ** 18)
    encode_and_print(price)

def encode_and_print(price):
    enc = encode_single('uint256', int(price))
    ## append 0x for FFI parsing 
    print("0x" + enc.hex())

def parse_args(): 
    parser = argparse.ArgumentParser()
    parser.add_argument("type", choices=["gobblers", "pages"])
    parser.add_argument("--time_since_start", type=int)
    parser.add_argument("--num_sold", type=int)
    parser.add_argument("--initial_price", type=int)
    parser.add_argument("--per_period_price_decrease", type=int)
    parser.add_argument("--logistic_scale", type=int)
    parser.add_argument("--time_scale", type=int)
    parser.add_argument("--per_period_post_switchover", type=int)
    parser.add_argument("--switchover_time", type=int)
    return parser.parse_args()

if __name__ == '__main__':
    args = parse_args() 
    main(args)

================================================
File: /analysis/requirements.txt
================================================
cytoolz==0.11.2
eth-abi==3.0.0
eth-hash==0.3.2
eth-typing==3.0.0
eth-utils==2.0.0
numpy==1.22.3
parsimonious==0.8.1
six==1.16.0
toolz==0.11.2


================================================
File: /analysis/pricer.py
================================================
import math
import numpy as np


class Pricer: 
    
    def compute_gobbler_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift):
       return self.compute_vrgda_price(time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift)

    def compute_page_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift,  per_period_post_switchover, switchover_time):
        initial_value = logistic_scale/ (1 +math.exp(time_scale * time_shift))
        sold_by_switchover = logistic_scale / (1 + math.exp(-1 * time_scale * (switchover_time - time_shift))) - initial_value
        if num_sold < sold_by_switchover:
            return self.compute_vrgda_price(time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift)
        else: 
            f_inv = (num_sold - sold_by_switchover) / per_period_post_switchover + switchover_time
            return initial_price * math.exp(-math.log(1 - per_period_price_decrease) * (f_inv - time_since_start))

    def compute_vrgda_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift):
        initial_value = logistic_scale / (1 + math.exp(time_scale * time_shift))
        logistic_value = num_sold + initial_value
        price = (1 - per_period_price_decrease) ** (time_since_start - time_shift + (math.log(-1 + logistic_scale / logistic_value) / time_scale)) * initial_price
        return price


================================================
File: /analysis/README.md
================================================
# Gobblers Analysis

Directory for gobbler economy modeling.

## Running

In order to run correctness tests, first install requirements with

```
pip install -r requirements.txt
```

Then run FFI tests with

```
forge test -vvv --ffi --match-test FFI
```


================================================
File: /.prettierignore
================================================
lib

================================================
File: /.gas-snapshot
================================================
ArtGobblersTest:testCanMintMultipleReserved() (gas: 1287959)
ArtGobblersTest:testCanMintReserved() (gas: 613727)
ArtGobblersTest:testCannotMintLegendaryWithLegendary() (gas: 76482119)
ArtGobblersTest:testCannotReuseSeedForReveal() (gas: 260127)
ArtGobblersTest:testCannotRevealMoreGobblersThanRemainingToBeRevealed() (gas: 268922)
ArtGobblersTest:testCantFeed1155As721() (gas: 1730262)
ArtGobblersTest:testCantFeed721As1155() (gas: 215902)
ArtGobblersTest:testCantFeedArtToUnownedGobbler() (gas: 114952)
ArtGobblersTest:testCantFeedUnownedArt() (gas: 120521)
ArtGobblersTest:testCantMintTooFastReserved() (gas: 1191218)
ArtGobblersTest:testCantMintTooFastReservedOneByOne() (gas: 6313459)
ArtGobblersTest:testCantRemoveGoo() (gas: 198003)
ArtGobblersTest:testCantSetRandomSeedWithoutRevealing() (gas: 270452)
ArtGobblersTest:testDoesNotAllowRevealingZero() (gas: 16298)
ArtGobblersTest:testEmissionMultipleUpdatesAfterTransfer() (gas: 231430)
ArtGobblersTest:testFeeding1155() (gas: 1739560)
ArtGobblersTest:testFeedingArt() (gas: 238976)
ArtGobblersTest:testFeedingMultiple1155Copies() (gas: 1781012)
ArtGobblersTest:testGobblerBalancesAfterTransfer() (gas: 235410)
ArtGobblersTest:testGooAddition() (gas: 228896)
ArtGobblersTest:testGooRemoval() (gas: 244664)
ArtGobblersTest:testInitialGobblerPrice() (gas: 9994)
ArtGobblersTest:testLegendaryGobblerFinalPrice() (gas: 73832294)
ArtGobblersTest:testLegendaryGobblerInitialPrice() (gas: 36930528)
ArtGobblersTest:testLegendaryGobblerMidPrice() (gas: 55349188)
ArtGobblersTest:testLegendaryGobblerMinStartPrice() (gas: 73881145)
ArtGobblersTest:testLegendaryGobblerMintBeforeStart() (gas: 20751)
ArtGobblersTest:testLegendaryGobblerPastFinalPrice() (gas: 67861384)
ArtGobblersTest:testMintFreeLegendaryGobbler() (gas: 73884453)
ArtGobblersTest:testMintFreeLegendaryGobblerPastInterval() (gas: 110790416)
ArtGobblersTest:testMintFromGoo() (gas: 93859)
ArtGobblersTest:testMintFromMintlist() (gas: 85518)
ArtGobblersTest:testMintFromMintlistBeforeMintingStarts() (gas: 13832)
ArtGobblersTest:testMintInsufficientBalance() (gas: 22757)
ArtGobblersTest:testMintLegendaryGobbler() (gas: 39932016)
ArtGobblersTest:testMintLegendaryGobblerWithUnownedId() (gas: 39781071)
ArtGobblersTest:testMintLegendaryGobblerWithWrongLength() (gas: 39741318)
ArtGobblersTest:testMintLegendaryGobblersExpectedIds() (gas: 249746540)
ArtGobblersTest:testMintNotInMintlist() (gas: 11203)
ArtGobblersTest:testMintPriceExceededMax() (gas: 71957)
ArtGobblersTest:testMintReservedGobblersFailsWithNoMints() (gas: 32683)
ArtGobblersTest:testMintedLegendaryURI() (gas: 73891311)
ArtGobblersTest:testMintingFromMintlistTwiceFails() (gas: 86043)
ArtGobblersTest:testMultiReveal() (gas: 8285801)
ArtGobblersTest:testPricingBasic() (gas: 54164622)
ArtGobblersTest:testRevealDelayInitialMint() (gas: 95506)
ArtGobblersTest:testRevealDelayRecurring() (gas: 244916)
ArtGobblersTest:testRevealedUri() (gas: 202251)
ArtGobblersTest:testSimpleRewards() (gas: 200238)
ArtGobblersTest:testUnmintedLegendaryUri() (gas: 19275)
ArtGobblersTest:testUnmintedUri() (gas: 11341)
ArtGobblersTest:testUnrevealedUri() (gas: 99913)
BenchmarksTest:testAddGoo() (gas: 28507)
BenchmarksTest:testBatchTransferGobblers() (gas: 697629)
BenchmarksTest:testGobblerPrice() (gas: 8982)
BenchmarksTest:testGooBalance() (gas: 8650)
BenchmarksTest:testLegendaryGobblersPrice() (gas: 9907)
BenchmarksTest:testMintCommunityPages() (gas: 58998)
BenchmarksTest:testMintGobbler() (gas: 55850)
BenchmarksTest:testMintLegendaryGobbler() (gas: 410870)
BenchmarksTest:testMintPage() (gas: 58713)
BenchmarksTest:testMintReservedGobblers() (gas: 91179)
BenchmarksTest:testPagePrice() (gas: 9110)
BenchmarksTest:testRemoveGoo() (gas: 28566)
BenchmarksTest:testRevealGobblers() (gas: 2840727)
GobblerReserveTest:testCanWithdraw() (gas: 760498)
GooTest:testBurnAllowed() (gas: 56314)
GooTest:testBurnNotAllowed() (gas: 56354)
GooTest:testMintByAuthority() (gas: 53601)
GooTest:testMintByNonAuthority() (gas: 13113)
GooTest:testSetPages() (gas: 64071)
LibStringTest:testToString() (gas: 10927)
MerkleProofLibTest:testValidProofSupplied() (gas: 2217)
MerkleProofLibTest:testVerifyEmptyMerkleProofSuppliedLeafAndRootDifferent() (gas: 1498)
MerkleProofLibTest:testVerifyEmptyMerkleProofSuppliedLeafAndRootSame() (gas: 1492)
MerkleProofLibTest:testVerifyInvalidProofSupplied() (gas: 2236)
PagesTest:testCanMintCommunity() (gas: 650527)
PagesTest:testCanMintMultipleCommunity() (gas: 1234368)
PagesTest:testCantMintTooFastCommunity() (gas: 1172707)
PagesTest:testCantMintTooFastCommunityOneByOne() (gas: 5916760)
PagesTest:testInitialPrice() (gas: 10023)
PagesTest:testInsufficientBalance() (gas: 20515)
PagesTest:testMintBeforeSetMint() (gas: 20528)
PagesTest:testMintBeforeStart() (gas: 11767)
PagesTest:testMintCommunityPagesFailsWithNoMints() (gas: 30572)
PagesTest:testMintPriceExceededMax() (gas: 69218)
PagesTest:testPagePricingPricingAfterSwitch() (gas: 360680811)
PagesTest:testPagePricingPricingBeforeSwitch() (gas: 224252486)
PagesTest:testRegularMint() (gas: 108635)
VRGDAsTest:testGobblerPriceStrictlyIncreasesForMostGobblers() (gas: 4120666)
VRGDAsTest:testPagePriceStrictlyIncreasesFor8465Pages() (gas: 20446362)
DeployRinkebyTest:testColdWallet() (gas: 21773)
DeployRinkebyTest:testGooAddressCorrectness() (gas: 18214)
DeployRinkebyTest:testMerkleRoot() (gas: 88127)
DeployRinkebyTest:testPagesAddressCorrectness() (gas: 18235)
DeployRinkebyTest:testURIs() (gas: 48605)


================================================
File: /remappings.txt
================================================
ds-test/=lib/ds-test/src/
solmate/=lib/solmate/src/
forge-std/=lib/forge-std/src/
openzeppelin/=lib/openzeppelin-contracts/contracts/
chainlink/=lib/chainlink/contracts/src/

================================================
File: /.github/workflows/tests.yml
================================================
name: Tests

on: [push, pull_request]

jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2

      - name: Install dev dependencies
        run: npm install

      - name: Install Foundry
        uses: onbjerg/foundry-toolchain@v1
        with:
          version: nightly

      - name: Run lint check
        run: npm run lint:check

      - name: Install dependencies
        run: forge install

      - name: Check contract sizes
        run: forge build --sizes

      - name: Check gas snapshots
        run: forge snapshot --check

      - name: Run tests
        run: forge test
        env:
          # Only fuzz intensely if we're running this action on a push to master or for a PR going into master:
          FOUNDRY_PROFILE: ${{ (github.ref == 'refs/heads/master' || github.base_ref == 'master') && 'intense' }}


================================================
File: /.solhint.json
================================================
{
  "extends": "solhint:recommended", 
  "rules": {
    "compiler-version": ["error",">=0.8.0"], 
    "avoid-low-level-calls": "off"
  }
}


================================================
File: /test/Optimizations.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";

contract OptimizationsTest is DSTestPlus {
    function testFuzzCurrentIdMultipleBranchlessOptimization(uint256 swapIndex) public {
        /*//////////////////////////////////////////////////////////////
                                  BRANCHLESS
        //////////////////////////////////////////////////////////////*/

        uint256 newCurrentIdMultipleBranchless = 9; // For beyond 7963.
        assembly {
            // prettier-ignore
            newCurrentIdMultipleBranchless := sub(sub(sub(newCurrentIdMultipleBranchless,
                lt(swapIndex, 7964)), lt(swapIndex, 5673)), lt(swapIndex, 3055)
            )
        }

        /*//////////////////////////////////////////////////////////////
                                  BRANCHED
        //////////////////////////////////////////////////////////////*/

        uint256 newCurrentIdMultipleBranched = 9; // For beyond 7963.
        if (swapIndex <= 3054) newCurrentIdMultipleBranched = 6;
        else if (swapIndex <= 5672) newCurrentIdMultipleBranched = 7;
        else if (swapIndex <= 7963) newCurrentIdMultipleBranched = 8;

        /*//////////////////////////////////////////////////////////////
                                EQUIVALENCE
        //////////////////////////////////////////////////////////////*/

        assertEq(newCurrentIdMultipleBranchless, newCurrentIdMultipleBranched);
    }
}


================================================
File: /test/deploy/DeployRinkeby.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {DeployRinkeby} from "../../script/deploy/DeployRinkeby.s.sol";
import {Vm} from "forge-std/Vm.sol";
import {console} from "forge-std/console.sol";

import {Pages} from "../../src/Pages.sol";
import {ArtGobblers} from "../../src/ArtGobblers.sol";

contract DeployRinkebyTest is DSTestPlus {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    DeployRinkeby deployScript;

    function setUp() public {
        deployScript = new DeployRinkeby();
        deployScript.run();
    }

    /// @notice Test goo addresses where correctly set.
    function testGooAddressCorrectness() public {
        assertEq(deployScript.goo().artGobblers(), address(deployScript.artGobblers()));
        assertEq(address(deployScript.goo().pages()), address(deployScript.pages()));
    }

    /// @notice Test page addresses where correctly set.
    function testPagesAddressCorrectness() public {
        assertEq(deployScript.pages().artGobblers(), address(deployScript.artGobblers()));
        assertEq(address(deployScript.pages().goo()), address(deployScript.goo()));
    }

    /// @notice Test that merkle root was correctly set.
    function testMerkleRoot() public {
        vm.warp(deployScript.mintStart());
        // Use merkle root as user to test simple proof.
        address user = deployScript.root();
        bytes32[] memory proof;
        ArtGobblers gobblers = deployScript.artGobblers();
        vm.prank(user);
        gobblers.claimGobbler(proof);
        // Verify gobbler ownership.
        assertEq(gobblers.ownerOf(1), user);
    }

    /// @notice Test cold wallet was appropriately set.
    function testColdWallet() public {
        address coldWallet = deployScript.coldWallet();
        address communityOwner = deployScript.teamReserve().owner();
        address teamOwner = deployScript.communityReserve().owner();
        assertEq(coldWallet, communityOwner);
        assertEq(coldWallet, teamOwner);
    }

    /// @notice Test URIs are correctly set.
    function testURIs() public {
        ArtGobblers gobblers = deployScript.artGobblers();
        assertEq(gobblers.BASE_URI(), deployScript.gobblerBaseUri());
        assertEq(gobblers.UNREVEALED_URI(), deployScript.gobblerUnrevealedUri());
        Pages pages = deployScript.pages();
        assertEq(pages.BASE_URI(), deployScript.pagesBaseUri());
    }
}


================================================
File: /test/GobblerReserve.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";
import {Utilities} from "./utils/Utilities.sol";
import {console} from "./utils/Console.sol";
import {Vm} from "forge-std/Vm.sol";
import {stdError} from "forge-std/Test.sol";
import {ArtGobblers} from "../src/ArtGobblers.sol";
import {Goo} from "../src/Goo.sol";
import {Pages} from "../src/Pages.sol";
import {GobblerReserve} from "../src/utils/GobblerReserve.sol";
import {LinkToken} from "./utils/mocks/LinkToken.sol";
import {VRFCoordinatorMock} from "chainlink/v0.8/mocks/VRFCoordinatorMock.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {MockERC1155} from "solmate/test/utils/mocks/MockERC1155.sol";
import {LibString} from "../src/utils/lib/LibString.sol";

/// @notice Unit test for the Gobbler Reserve contract.
contract GobblerReserveTest is DSTestPlus, ERC1155TokenReceiver {
    using LibString for uint256;

    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    Utilities internal utils;
    address payable[] internal users;

    ArtGobblers internal gobblers;
    VRFCoordinatorMock internal vrfCoordinator;
    LinkToken internal linkToken;
    Goo internal goo;
    Pages internal pages;
    GobblerReserve internal team;
    GobblerReserve internal community;

    bytes32 private keyHash;
    uint256 private fee;

    uint256[] ids;

    /*//////////////////////////////////////////////////////////////
                                  SETUP
    //////////////////////////////////////////////////////////////*/

    function setUp() public {
        utils = new Utilities();
        users = utils.createUsers(5);
        linkToken = new LinkToken();
        vrfCoordinator = new VRFCoordinatorMock(address(linkToken));

        team = new GobblerReserve(ArtGobblers(utils.predictContractAddress(address(this), 3)), address(this));
        community = new GobblerReserve(ArtGobblers(utils.predictContractAddress(address(this), 2)), address(this));

        goo = new Goo(
            // Gobblers:
            utils.predictContractAddress(address(this), 1),
            // Pages:
            utils.predictContractAddress(address(this), 2)
        );

        gobblers = new ArtGobblers(
            keccak256(abi.encodePacked(users[0])),
            block.timestamp,
            goo,
            address(team),
            address(community),
            address(vrfCoordinator),
            address(linkToken),
            keyHash,
            fee,
            "base",
            ""
        );

        pages = new Pages(block.timestamp, goo, address(0xBEEF), address(gobblers), "");
    }

    /*//////////////////////////////////////////////////////////////
                            WITHDRAWAL TESTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Tests that a reserve can be withdrawn from.
    function testCanWithdraw() public {
        mintGobblerToAddress(users[0], 9);

        gobblers.mintReservedGobblers(1);

        assertEq(gobblers.ownerOf(10), address(team));
        assertEq(gobblers.ownerOf(11), address(community));

        uint256[] memory idsToWithdraw = new uint256[](1);

        idsToWithdraw[0] = 10;
        team.withdraw(address(this), idsToWithdraw);

        idsToWithdraw[0] = 11;
        community.withdraw(address(this), idsToWithdraw);

        assertEq(gobblers.ownerOf(10), address(this));
        assertEq(gobblers.ownerOf(11), address(this));
    }

    /*//////////////////////////////////////////////////////////////
                                 HELPERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a number of gobblers to the given address
    function mintGobblerToAddress(address addr, uint256 num) internal {
        for (uint256 i = 0; i < num; i++) {
            vm.startPrank(address(gobblers));
            goo.mintForGobblers(addr, gobblers.gobblerPrice());
            vm.stopPrank();

            vm.prank(addr);
            gobblers.mintFromGoo(type(uint256).max);
        }
    }
}


================================================
File: /test/MerkleProofLib.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";

import {MerkleProofLib} from "../src/utils/lib/MerkleProofLib.sol";

contract MerkleProofLibTest is DSTestPlus {
    function testVerifyEmptyMerkleProofSuppliedLeafAndRootSame() public {
        bytes32[] memory proof;
        assertBoolEq(this.verify(proof, 0x00, 0x00), true);
    }

    function testVerifyEmptyMerkleProofSuppliedLeafAndRootDifferent() public {
        bytes32[] memory proof;
        bytes32 leaf = "a";
        assertBoolEq(this.verify(proof, 0x00, leaf), false);
    }

    function testValidProofSupplied() public {
        // Merkle tree created from leaves ['a', 'b', 'c'].
        // Leaf is 'a'.
        bytes32[] memory proof = new bytes32[](2);
        proof[0] = 0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5510;
        proof[1] = 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2;
        bytes32 root = 0x5842148bc6ebeb52af882a317c765fccd3ae80589b21a9b8cbf21abb630e46a7;
        bytes32 leaf = 0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb;
        assertBoolEq(this.verify(proof, root, leaf), true);
    }

    function testVerifyInvalidProofSupplied() public {
        // Merkle tree created from leaves ['a', 'b', 'c'].
        // Leaf is 'a'.
        // Proof is same as testValidProofSupplied but last byte of first element is modified.
        bytes32[] memory proof = new bytes32[](2);
        proof[0] = 0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5511;
        proof[1] = 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2;
        bytes32 root = 0x5842148bc6ebeb52af882a317c765fccd3ae80589b21a9b8cbf21abb630e46a7;
        bytes32 leaf = 0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb;
        assertBoolEq(this.verify(proof, root, leaf), false);
    }

    function verify(
        bytes32[] calldata proof,
        bytes32 root,
        bytes32 leaf
    ) external pure returns (bool) {
        return MerkleProofLib.verify(proof, root, leaf);
    }
}


================================================
File: /test/Pages.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {Utilities} from "./utils/Utilities.sol";
import {Vm} from "forge-std/Vm.sol";
import {stdError} from "forge-std/Test.sol";
import {Goo} from "../src/Goo.sol";
import {Pages} from "../src/Pages.sol";
import {console} from "./utils/Console.sol";

contract PagesTest is DSTestPlus {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);
    Utilities internal utils;
    address payable[] internal users;
    address internal mintAuth;

    address internal user;
    Goo internal goo;
    Pages internal pages;
    uint256 mintStart;

    address internal community = address(0xBEEF);

    function setUp() public {
        // Avoid starting at timestamp at 0 for ease of testing.
        vm.warp(block.timestamp + 1);

        utils = new Utilities();
        users = utils.createUsers(5);

        goo = new Goo(
            // Gobblers:
            address(this),
            // Pages:
            utils.predictContractAddress(address(this), 1)
        );

        pages = new Pages(block.timestamp, goo, community, address(this), "");

        user = users[1];
    }

    function testMintBeforeSetMint() public {
        vm.expectRevert(stdError.arithmeticError);
        vm.prank(user);
        pages.mintFromGoo(type(uint256).max);
    }

    function testMintBeforeStart() public {
        vm.warp(block.timestamp - 1);

        vm.expectRevert(stdError.arithmeticError);
        vm.prank(user);
        pages.mintFromGoo(type(uint256).max);
    }

    function testRegularMint() public {
        goo.mintForGobblers(user, pages.pagePrice());
        vm.prank(user);
        pages.mintFromGoo(type(uint256).max);
        assertEq(user, pages.ownerOf(1));
    }

    function testInitialPrice() public {
        uint256 cost = pages.pagePrice();
        uint256 maxDelta = 5; // 0.000000000000000005

        assertApproxEq(cost, uint256(pages.initialPrice()), maxDelta);
    }

    function testMintCommunityPagesFailsWithNoMints() public {
        vm.expectRevert(Pages.ReserveImbalance.selector);
        pages.mintCommunityPages(1);
    }

    function testCanMintCommunity() public {
        mintPageToAddress(user, 9);

        pages.mintCommunityPages(1);
        assertEq(pages.ownerOf(10), address(community));
    }

    function testCanMintMultipleCommunity() public {
        mintPageToAddress(user, 18);

        pages.mintCommunityPages(2);
        assertEq(pages.ownerOf(19), address(community));
        assertEq(pages.ownerOf(20), address(community));
    }

    function testCantMintTooFastCommunity() public {
        mintPageToAddress(user, 18);

        vm.expectRevert(Pages.ReserveImbalance.selector);
        pages.mintCommunityPages(3);
    }

    function testCantMintTooFastCommunityOneByOne() public {
        mintPageToAddress(user, 90);

        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);

        vm.expectRevert(Pages.ReserveImbalance.selector);
        pages.mintCommunityPages(1);
    }

    /// @notice Test that page pricing matches expected behavior before switch.
    function testPagePricingPricingBeforeSwitch() public {
        // Expected sales rate according to mathematical formula.
        uint256 timeDelta = 60 days;
        uint256 numMint = 3572;

        vm.warp(block.timestamp + timeDelta);

        uint256 initialPrice = uint256(pages.initialPrice());

        for (uint256 i = 0; i < numMint; i++) {
            uint256 price = pages.pagePrice();
            goo.mintForGobblers(user, price);
            vm.prank(user);
            pages.mintFromGoo(price);
        }

        uint256 finalPrice = pages.pagePrice();

        // If selling at target rate, final price should equal starting price.
        assertRelApproxEq(initialPrice, finalPrice, 0.01e18);
    }

    /// @notice Test that page pricing matches expected behavior after switch.
    function testPagePricingPricingAfterSwitch() public {
        uint256 timeDelta = 360 days;
        uint256 numMint = 9498;

        vm.warp(block.timestamp + timeDelta);

        uint256 initialPrice = uint256(pages.initialPrice());

        for (uint256 i = 0; i < numMint; i++) {
            uint256 price = pages.pagePrice();
            goo.mintForGobblers(user, price);
            vm.prank(user);
            pages.mintFromGoo(price);
        }

        uint256 finalPrice = pages.pagePrice();

        // If selling at target rate, final price should equal starting price.
        assertRelApproxEq(initialPrice, finalPrice, 0.02e18);
    }

    function testInsufficientBalance() public {
        vm.prank(user);
        vm.expectRevert(stdError.arithmeticError);
        pages.mintFromGoo(type(uint256).max);
    }

    function testMintPriceExceededMax() public {
        uint256 cost = pages.pagePrice();
        goo.mintForGobblers(user, cost);
        vm.prank(user);
        vm.expectRevert(abi.encodeWithSelector(Pages.PriceExceededMax.selector, cost));
        pages.mintFromGoo(cost - 1);
    }

    /// @notice Mint a number of pages to the given address
    function mintPageToAddress(address addr, uint256 num) internal {
        for (uint256 i = 0; i < num; i++) {
            goo.mintForGobblers(addr, pages.pagePrice());

            vm.prank(addr);
            pages.mintFromGoo(type(uint256).max);
        }
    }
}


================================================
File: /test/SignedWadMath.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";

import {wadMul, wadDiv} from "../src/utils/lib/SignedWadMath.sol";

contract SignedWadMathTest is DSTestPlus {
    function testWadMul(
        uint256 x,
        uint256 y,
        bool negX,
        bool negY
    ) public {
        x = bound(x, 0, 99999999999999e18);
        y = bound(x, 0, 99999999999999e18);

        int256 xPrime = negX ? -int256(x) : int256(x);
        int256 yPrime = negY ? -int256(y) : int256(y);

        assertEq(wadMul(xPrime, yPrime), (xPrime * yPrime) / 1e18);
    }

    function testFailWadMulOverflow(int256 x, int256 y) public pure {
        // Ignore cases where x * y does not overflow.
        unchecked {
            if ((x * y) / x == y) revert();
        }

        wadMul(x, y);
    }

    function testWadDiv(
        uint256 x,
        uint256 y,
        bool negX,
        bool negY
    ) public {
        x = bound(x, 0, 99999999e18);
        y = bound(x, 1, 99999999e18);

        int256 xPrime = negX ? -int256(x) : int256(x);
        int256 yPrime = negY ? -int256(y) : int256(y);

        assertEq(wadDiv(xPrime, yPrime), (xPrime * 1e18) / yPrime);
    }

    function testFailWadDivOverflow(int256 x, int256 y) public pure {
        // Ignore cases where x * WAD does not overflow or y is 0.
        unchecked {
            if (y == 0 || (x * 1e18) / 1e18 == x) revert();
        }

        wadDiv(x, y);
    }

    function testFailWadDivZeroDenominator(int256 x) public pure {
        wadDiv(x, 0);
    }
}


================================================
File: /test/correctness/GobblersCorrectness.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {Vm} from "forge-std/Vm.sol";
import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {LibString} from "../../src/utils/lib/LibString.sol";
import {ArtGobblers} from "../../src/ArtGobblers.sol";
import {Goo} from "../../src/Goo.sol";

contract GobblersCorrectnessTest is DSTestPlus {
    using LibString for uint256;

    uint256 internal immutable TWENTY_YEARS = 7300 days;

    uint256 internal MAX_MINTABLE;

    int256 internal LOGISTIC_SCALE;

    int256 internal immutable INITIAL_PRICE = 69.42e18;

    int256 internal immutable PER_PERIOD_PRICE_DECREASE = 0.31e18;

    int256 internal immutable TIME_SCALE = 0.0023e18;

    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    ArtGobblers internal gobblers;

    function setUp() public {
        gobblers = new ArtGobblers(
            "root",
            block.timestamp,
            Goo(address(0)),
            address(0),
            address(0),
            address(0),
            address(0),
            0,
            0,
            "",
            ""
        );

        MAX_MINTABLE = gobblers.MAX_MINTABLE();
        LOGISTIC_SCALE = int256(MAX_MINTABLE * 2e18);
    }

    function testFFICorrectness(uint256 timeSinceStart, uint256 numSold) public {
        // Limit num sold to max mint.
        numSold = bound(numSold, 0, MAX_MINTABLE);

        // Limit mint time to 20 years.
        timeSinceStart = bound(timeSinceStart, 0, TWENTY_YEARS);

        // Calculate actual price from VRGDA.
        try gobblers.getPrice(timeSinceStart, numSold) returns (uint256 actualPrice) {
            // Calculate expected price from python script.
            uint256 expectedPrice = calculatePrice(
                timeSinceStart,
                numSold,
                INITIAL_PRICE,
                PER_PERIOD_PRICE_DECREASE,
                LOGISTIC_SCALE,
                TIME_SCALE
            );

            if (expectedPrice < 0.0000000000001e18) return; // For really small prices we can't expect them to be equal.

            // Equal within 1 percent.
            assertRelApproxEq(actualPrice, expectedPrice, 0.01e18);
        } catch {
            // If it reverts that's fine, there are some bounds on the function, they are tested in VRGDAs.t.sol
        }
    }

    function calculatePrice(
        uint256 _timeSinceStart,
        uint256 _numSold,
        int256 _initialPrice,
        int256 _perPeriodPriceDecrease,
        int256 _logisticScale,
        int256 _timeScale
    ) private returns (uint256) {
        string[] memory inputs = new string[](15);
        inputs[0] = "python3";
        inputs[1] = "analysis/compute_price.py";
        inputs[2] = "gobblers";
        inputs[3] = "--time_since_start";
        inputs[4] = _timeSinceStart.toString();
        inputs[5] = "--num_sold";
        inputs[6] = _numSold.toString();
        inputs[7] = "--initial_price";
        inputs[8] = uint256(_initialPrice).toString();
        inputs[9] = "--per_period_price_decrease";
        inputs[10] = uint256(_perPeriodPriceDecrease).toString();
        inputs[11] = "--logistic_scale";
        inputs[12] = uint256(_logisticScale).toString();
        inputs[13] = "--time_scale";
        inputs[14] = uint256(_timeScale).toString();

        return abi.decode(vm.ffi(inputs), (uint256));
    }
}


================================================
File: /test/correctness/PagesCorrectness.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {Vm} from "forge-std/Vm.sol";
import {LibString} from "../../src/utils/lib/LibString.sol";
import {console} from "../utils/Console.sol";
import {Pages} from "../../src/Pages.sol";
import {Goo} from "../../src/Goo.sol";

contract PageCorrectnessTest is DSTestPlus {
    using LibString for uint256;

    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    uint256 internal immutable TWENTY_YEARS = 7300 days;

    uint256 internal immutable MAX_MINTABLE = 9000;

    int256 internal LOGISTIC_SCALE;

    int256 internal immutable INITIAL_PRICE = 4.2069e18;

    int256 internal immutable PER_PERIOD_PRICE_DECREASE = 0.31e18;

    int256 internal immutable TIME_SCALE = 0.014e18;

    int256 internal immutable SWITCHOVER_TIME = 207e18;

    int256 internal immutable PER_PERIOD_POST_SWITCHOVER = 10e18;

    Pages internal pages;

    function setUp() public {
        pages = new Pages(block.timestamp, Goo(address(0)), address(0), address(0), "");

        LOGISTIC_SCALE = int256(MAX_MINTABLE * 2e18);
    }

    function testFFICorrectness(uint256 timeSinceStart, uint256 numSold) public {
        // Limit num sold to max mint.
        numSold = bound(numSold, 0, 10000);

        // Limit mint time to 20 years.
        timeSinceStart = bound(timeSinceStart, 0, TWENTY_YEARS);

        // Calculate actual price from VRGDA.
        try pages.getPrice(timeSinceStart, numSold) returns (uint256 actualPrice) {
            // Calculate expected price from python script.
            uint256 expectedPrice = calculatePrice(
                timeSinceStart,
                numSold,
                INITIAL_PRICE,
                PER_PERIOD_PRICE_DECREASE,
                LOGISTIC_SCALE,
                TIME_SCALE,
                PER_PERIOD_POST_SWITCHOVER,
                SWITCHOVER_TIME
            );

            if (expectedPrice < 0.0000000000001e18) return; // For really small prices we can't expect them to be equal.

            // Equal within 1 percent.
            assertRelApproxEq(actualPrice, expectedPrice, 0.01e18);
        } catch {
            // If it reverts that's fine, there are some bounds on the function, they are tested in VRGDAs.t.sol
        }
    }

    function calculatePrice(
        uint256 _timeSinceStart,
        uint256 _numSold,
        int256 _initialPrice,
        int256 _PER_PERIOD_PRICE_DECREASE,
        int256 _logisticScale,
        int256 _timeScale,
        int256 _perPeriodPostSwitchover,
        int256 _switchoverTime
    ) private returns (uint256) {
        string[] memory inputs = new string[](19);
        inputs[0] = "python3";
        inputs[1] = "analysis/compute_price.py";
        inputs[2] = "pages";
        inputs[3] = "--time_since_start";
        inputs[4] = _timeSinceStart.toString();
        inputs[5] = "--num_sold";
        inputs[6] = _numSold.toString();
        inputs[7] = "--initial_price";
        inputs[8] = uint256(_initialPrice).toString();
        inputs[9] = "--per_period_price_decrease";
        inputs[10] = uint256(_PER_PERIOD_PRICE_DECREASE).toString();
        inputs[11] = "--logistic_scale";
        inputs[12] = uint256(_logisticScale).toString();
        inputs[13] = "--time_scale";
        inputs[14] = uint256(_timeScale).toString();
        inputs[15] = "--per_period_post_switchover";
        inputs[16] = uint256(_perPeriodPostSwitchover).toString();
        inputs[17] = "--switchover_time";
        inputs[18] = uint256(_switchoverTime).toString();

        return abi.decode(vm.ffi(inputs), (uint256));
    }
}


================================================
File: /test/correctness/EmissionCorrectness.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {MockGooCalculator} from "../utils/mocks/MockGooCalculator.sol";
import {Vm} from "forge-std/Vm.sol";
import {LibString} from "../../src/utils/lib/LibString.sol";

contract EmissionCorrectnessTest is DSTestPlus {
    using LibString for uint256;

    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    MockGooCalculator immutable gooCalculator = new MockGooCalculator();

    function testFFIEmissionCorrectness(
        uint256 daysElapsedWad,
        uint256 lastBalanceWad,
        uint256 emissionMultiple
    ) public {
        emissionMultiple = bound(emissionMultiple, 0, 100);

        daysElapsedWad = bound(daysElapsedWad, 0, 7300 days * 1e18);

        lastBalanceWad = bound(lastBalanceWad, 0, 1e36);

        uint256 expectedBalance = calculateBalance(daysElapsedWad, lastBalanceWad, emissionMultiple);

        uint256 actualBalance = gooCalculator.computeGooBalance(emissionMultiple, lastBalanceWad, daysElapsedWad);

        if (expectedBalance < 0.0000000000001e18) return; // For really small balances we can't expect them to be equal.

        // Equal within 1 percent.
        assertRelApproxEq(actualBalance, expectedBalance, 0.01e18);
    }

    function calculateBalance(
        uint256 _emissionTime,
        uint256 _initialAmount,
        uint256 _emissionMultiple
    ) private returns (uint256) {
        string[] memory inputs = new string[](8);
        inputs[0] = "python3";
        inputs[1] = "analysis/compute_emissions.py";
        inputs[2] = "--time";
        inputs[3] = _emissionTime.toString();
        inputs[4] = "--initial_amount";
        inputs[5] = _initialAmount.toString();
        inputs[6] = "--emission_multiple";
        inputs[7] = _emissionMultiple.toString();

        return abi.decode(vm.ffi(inputs), (uint256));
    }
}


================================================
File: /test/LibString.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";

import {LibString} from "../src/utils/lib/LibString.sol";

contract LibStringTest is DSTestPlus {
    function testToString() public {
        assertEq(LibString.toString(0), "0");
        assertEq(LibString.toString(1), "1");
        assertEq(LibString.toString(17), "17");
        assertEq(LibString.toString(99999999), "99999999");
        assertEq(LibString.toString(99999999999), "99999999999");
        assertEq(LibString.toString(2342343923423), "2342343923423");
        assertEq(LibString.toString(98765685434567), "98765685434567");
    }

    function testDifferentiallyFuzzToString(uint256 value, bytes calldata brutalizeWith)
        public
        brutalizeMemory(brutalizeWith)
    {
        string memory libString = LibString.toString(value);
        string memory oz = toStringOZ(value);

        assertEq(bytes(libString).length, bytes(oz).length);
        assertEq(libString, oz);
    }
}

function toStringOZ(uint256 value) pure returns (string memory) {
    if (value == 0) {
        return "0";
    }
    uint256 temp = value;
    uint256 digits;
    while (temp != 0) {
        digits++;
        temp /= 10;
    }
    bytes memory buffer = new bytes(digits);
    while (value != 0) {
        digits -= 1;
        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
        value /= 10;
    }
    return string(buffer);
}


================================================
File: /test/Benchmarks.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTest} from "ds-test/test.sol";
import {ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";
import {Utilities} from "./utils/Utilities.sol";
import {console} from "./utils/Console.sol";
import {Vm} from "forge-std/Vm.sol";
import {ArtGobblers} from "../src/ArtGobblers.sol";
import {Goo} from "../src/Goo.sol";
import {Pages} from "../src/Pages.sol";
import {LinkToken} from "./utils/mocks/LinkToken.sol";
import {VRFCoordinatorMock} from "chainlink/v0.8/mocks/VRFCoordinatorMock.sol";

contract BenchmarksTest is DSTest, ERC1155TokenReceiver {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    Utilities internal utils;
    address payable[] internal users;

    ArtGobblers private gobblers;
    VRFCoordinatorMock private vrfCoordinator;
    LinkToken private linkToken;

    Goo goo;
    Pages pages;

    uint256 legendaryCost;

    bytes32 private keyHash;
    uint256 private fee;

    function setUp() public {
        vm.warp(1); // Otherwise mintStart will be set to 0 and brick pages.mintFromGoo(type(uint256).max)

        utils = new Utilities();
        users = utils.createUsers(5);
        linkToken = new LinkToken();
        vrfCoordinator = new VRFCoordinatorMock(address(linkToken));

        goo = new Goo(
            // Gobblers:
            utils.predictContractAddress(address(this), 1),
            // Pages:
            utils.predictContractAddress(address(this), 2)
        );

        gobblers = new ArtGobblers(
            keccak256(abi.encodePacked(users[0])),
            block.timestamp,
            goo,
            address(0xBEEF),
            address(0xBEEF),
            address(vrfCoordinator),
            address(linkToken),
            keyHash,
            fee,
            "base",
            ""
        );

        pages = new Pages(block.timestamp, goo, address(0xBEEF), address(gobblers), "");

        vm.prank(address(gobblers));
        goo.mintForGobblers(address(this), type(uint128).max);

        gobblers.addGoo(1e18);

        mintPageToAddress(address(this), 9);
        mintGobblerToAddress(address(this), gobblers.LEGENDARY_AUCTION_INTERVAL());

        vm.warp(block.timestamp + 30 days);

        legendaryCost = gobblers.legendaryGobblerPrice();

        bytes32 requestId = gobblers.requestRandomSeed();
        uint256 randomness = uint256(keccak256(abi.encodePacked("seed")));
        vrfCoordinator.callBackWithRandomness(requestId, randomness, address(gobblers));
    }

    function testPagePrice() public view {
        pages.pagePrice();
    }

    function testGobblerPrice() public view {
        gobblers.gobblerPrice();
    }

    function testLegendaryGobblersPrice() public view {
        gobblers.legendaryGobblerPrice();
    }

    function testGooBalance() public view {
        gobblers.gooBalance(address(this));
    }

    function testMintPage() public {
        pages.mintFromGoo(type(uint256).max);
    }

    function testMintGobbler() public {
        gobblers.mintFromGoo(type(uint256).max);
    }

    function testBatchTransferGobblers() public {
        uint256[] memory ids = new uint256[](100);
        uint256[] memory amounts = new uint256[](100);
        for (uint256 i = 0; i < 100; i++) {
            ids[i] = i + 1;
            amounts[i] = 1;
        }

        gobblers.safeBatchTransferFrom(address(this), address(0xBEEF), ids, amounts, "");
    }

    function testAddGoo() public {
        gobblers.addGoo(1e18);
    }

    function testRemoveGoo() public {
        gobblers.removeGoo(1e18);
    }

    function testRevealGobblers() public {
        gobblers.revealGobblers(100);
    }

    function testMintLegendaryGobbler() public {
        uint256 legendaryGobblerCost = legendaryCost;

        uint256[] memory ids = new uint256[](legendaryGobblerCost);
        for (uint256 i = 0; i < legendaryGobblerCost; i++) ids[i] = i + 1;

        gobblers.mintLegendaryGobbler(ids);
    }

    function testMintReservedGobblers() public {
        gobblers.mintReservedGobblers(1);
    }

    function testMintCommunityPages() public {
        pages.mintCommunityPages(1);
    }

    function mintGobblerToAddress(address addr, uint256 num) internal {
        for (uint256 i = 0; i < num; i++) {
            vm.startPrank(address(gobblers));
            goo.mintForGobblers(addr, gobblers.gobblerPrice());
            vm.stopPrank();

            vm.prank(addr);
            gobblers.mintFromGoo(type(uint256).max);
        }
    }

    function mintPageToAddress(address addr, uint256 num) internal {
        for (uint256 i = 0; i < num; i++) {
            vm.startPrank(address(gobblers));
            goo.mintForGobblers(addr, pages.pagePrice());
            vm.stopPrank();

            vm.prank(addr);
            pages.mintFromGoo(type(uint256).max);
        }
    }
}


================================================
File: /test/Goo.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTest} from "ds-test/test.sol";
import {Utilities} from "./utils/Utilities.sol";
import {Vm} from "forge-std/Vm.sol";
import {stdError} from "forge-std/Test.sol";
import {Goo} from "../src/Goo.sol";

contract GooTest is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);
    Utilities internal utils;
    address payable[] internal users;
    Goo internal goo;

    function setUp() public {
        utils = new Utilities();
        users = utils.createUsers(5);
        goo = new Goo(address(this), users[0]);
    }

    function testMintByAuthority() public {
        uint256 initialSupply = goo.totalSupply();
        uint256 mintAmount = 100000;
        goo.mintForGobblers(address(this), mintAmount);
        uint256 finalSupply = goo.totalSupply();
        assertEq(finalSupply, initialSupply + mintAmount);
    }

    function testMintByNonAuthority() public {
        uint256 mintAmount = 100000;
        vm.prank(users[0]);
        vm.expectRevert(Goo.Unauthorized.selector);
        goo.mintForGobblers(address(this), mintAmount);
    }

    function testSetPages() public {
        goo.mintForGobblers(address(this), 1000000);
        uint256 initialSupply = goo.totalSupply();
        uint256 burnAmount = 100000;
        vm.prank(users[0]);
        goo.burnForPages(address(this), burnAmount);
        uint256 finalSupply = goo.totalSupply();
        assertEq(finalSupply, initialSupply - burnAmount);
    }

    function testBurnAllowed() public {
        uint256 mintAmount = 100000;
        goo.mintForGobblers(address(this), mintAmount);
        uint256 burnAmount = 30000;
        goo.burnForGobblers(address(this), burnAmount);
        uint256 finalBalance = goo.balanceOf(address(this));
        assertEq(finalBalance, mintAmount - burnAmount);
    }

    function testBurnNotAllowed() public {
        uint256 mintAmount = 100000;
        goo.mintForGobblers(address(this), mintAmount);
        uint256 burnAmount = 200000;
        vm.expectRevert(stdError.arithmeticError);
        goo.burnForGobblers(address(this), burnAmount);
    }
}


================================================
File: /test/ArtGobblers.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";
import {Utilities} from "./utils/Utilities.sol";
import {console} from "./utils/Console.sol";
import {Vm} from "forge-std/Vm.sol";
import {stdError} from "forge-std/Test.sol";
import {ArtGobblers} from "../src/ArtGobblers.sol";
import {Goo} from "../src/Goo.sol";
import {Pages} from "../src/Pages.sol";
import {GobblerReserve} from "../src/utils/GobblerReserve.sol";
import {LinkToken} from "./utils/mocks/LinkToken.sol";
import {VRFCoordinatorMock} from "chainlink/v0.8/mocks/VRFCoordinatorMock.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {MockERC1155} from "solmate/test/utils/mocks/MockERC1155.sol";
import {LibString} from "../src/utils/lib/LibString.sol";

/// @notice Unit test for Art Gobbler Contract.
contract ArtGobblersTest is DSTestPlus, ERC1155TokenReceiver {
    using LibString for uint256;

    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    Utilities internal utils;
    address payable[] internal users;

    ArtGobblers internal gobblers;
    VRFCoordinatorMock internal vrfCoordinator;
    LinkToken internal linkToken;
    Goo internal goo;
    Pages internal pages;
    GobblerReserve internal team;
    GobblerReserve internal community;

    bytes32 private keyHash;
    uint256 private fee;

    uint256[] ids;

    /*//////////////////////////////////////////////////////////////
                                  SETUP
    //////////////////////////////////////////////////////////////*/

    function setUp() public {
        utils = new Utilities();
        users = utils.createUsers(5);
        linkToken = new LinkToken();
        vrfCoordinator = new VRFCoordinatorMock(address(linkToken));

        team = new GobblerReserve(ArtGobblers(utils.predictContractAddress(address(this), 3)), address(this));
        community = new GobblerReserve(ArtGobblers(utils.predictContractAddress(address(this), 2)), address(this));

        goo = new Goo(
            // Gobblers:
            utils.predictContractAddress(address(this), 1),
            // Pages:
            utils.predictContractAddress(address(this), 2)
        );

        gobblers = new ArtGobblers(
            keccak256(abi.encodePacked(users[0])),
            block.timestamp,
            goo,
            address(team),
            address(community),
            address(vrfCoordinator),
            address(linkToken),
            keyHash,
            fee,
            "base",
            ""
        );

        pages = new Pages(block.timestamp, goo, address(0xBEEF), address(gobblers), "");
    }

    /*//////////////////////////////////////////////////////////////
                               MINT TESTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Test that minting from the mintlist before minting starts fails.
    function testMintFromMintlistBeforeMintingStarts() public {
        vm.warp(block.timestamp - 1);

        address user = users[0];
        bytes32[] memory proof;
        vm.prank(user);
        vm.expectRevert(ArtGobblers.MintStartPending.selector);
        gobblers.claimGobbler(proof);
    }

    /// @notice Test that you can mint from mintlist successfully.
    function testMintFromMintlist() public {
        address user = users[0];
        bytes32[] memory proof;
        vm.prank(user);
        gobblers.claimGobbler(proof);
        // verify gobbler ownership
        assertEq(gobblers.ownerOf(1), user);
    }

    /// @notice Test that minting from the mintlist twice fails.
    function testMintingFromMintlistTwiceFails() public {
        address user = users[0];
        bytes32[] memory proof;
        vm.startPrank(user);
        gobblers.claimGobbler(proof);

        vm.expectRevert(ArtGobblers.AlreadyClaimed.selector);
        gobblers.claimGobbler(proof);
    }

    /// @notice Test that an invalid mintlist proof reverts.
    function testMintNotInMintlist() public {
        bytes32[] memory proof;
        vm.expectRevert(ArtGobblers.InvalidProof.selector);
        gobblers.claimGobbler(proof);
    }

    /// @notice Test that you can successfully mint from goo.
    function testMintFromGoo() public {
        uint256 cost = gobblers.gobblerPrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(users[0], cost);
        vm.prank(users[0]);
        gobblers.mintFromGoo(type(uint256).max);
        assertEq(gobblers.ownerOf(1), users[0]);
    }

    /// @notice Test that trying to mint with insufficient balance reverts.
    function testMintInsufficientBalance() public {
        vm.prank(users[0]);
        vm.expectRevert(stdError.arithmeticError);
        gobblers.mintFromGoo(type(uint256).max);
    }

    /// @notice Test that if mint price exceeds max it reverts.
    function testMintPriceExceededMax() public {
        uint256 cost = gobblers.gobblerPrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(users[0], cost);
        vm.prank(users[0]);
        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.PriceExceededMax.selector, cost));
        gobblers.mintFromGoo(cost - 1);
    }

    /// @notice Test that initial gobbler price is what we expect.
    function testInitialGobblerPrice() public {
        uint256 cost = gobblers.gobblerPrice();
        uint256 maxDelta = 0.000000000000000070e18;
        assertApproxEq(cost, uint256(gobblers.initialPrice()), maxDelta);
    }

    /// @notice Test that minting reserved gobblers fails if there are no mints.
    function testMintReservedGobblersFailsWithNoMints() public {
        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);
        gobblers.mintReservedGobblers(1);
    }

    /// @notice Test that reserved gobblers can be minted under fair circumstances.
    function testCanMintReserved() public {
        mintGobblerToAddress(users[0], 8);

        gobblers.mintReservedGobblers(1);
        assertEq(gobblers.ownerOf(9), address(team));
        assertEq(gobblers.ownerOf(10), address(community));
    }

    /// @notice Test multiple reserved gobblers can be minted under fair circumstances.
    function testCanMintMultipleReserved() public {
        mintGobblerToAddress(users[0], 18);

        gobblers.mintReservedGobblers(2);
        assertEq(gobblers.ownerOf(19), address(team));
        assertEq(gobblers.ownerOf(20), address(team));
        assertEq(gobblers.ownerOf(21), address(community));
        assertEq(gobblers.ownerOf(22), address(community));
    }

    /// @notice Test minting reserved gobblers fails if not enough have gobblers been minted.
    function testCantMintTooFastReserved() public {
        mintGobblerToAddress(users[0], 18);

        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);
        gobblers.mintReservedGobblers(3);
    }

    /// @notice Test minting reserved gobblers fails one by one if not enough have gobblers been minted.
    function testCantMintTooFastReservedOneByOne() public {
        mintGobblerToAddress(users[0], 90);

        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);

        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);
        gobblers.mintReservedGobblers(1);
    }

    /*//////////////////////////////////////////////////////////////
                              PRICING TESTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Test VRGDA behavior when selling at target rate.
    function testPricingBasic() public {
        // VRGDA targets this number of mints at given time.
        uint256 timeDelta = 120 days;
        uint256 numMint = 877;

        vm.warp(block.timestamp + timeDelta);

        for (uint256 i = 0; i < numMint; i++) {
            vm.startPrank(address(gobblers));
            uint256 price = gobblers.gobblerPrice();
            goo.mintForGobblers(users[0], price);
            vm.stopPrank();
            vm.prank(users[0]);
            gobblers.mintFromGoo(price);
        }

        uint256 initialPrice = uint256(gobblers.initialPrice());
        uint256 finalPrice = gobblers.gobblerPrice();

        // Equal within 3 percent since num mint is rounded from true decimal amount.
        assertRelApproxEq(initialPrice, finalPrice, 0.03e18);
    }

    /*//////////////////////////////////////////////////////////////
                           LEGENDARY GOBBLERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Test that attempting to mint before start time reverts.
    function testLegendaryGobblerMintBeforeStart() public {
        vm.expectRevert(stdError.arithmeticError);
        vm.prank(users[0]);
        gobblers.mintLegendaryGobbler(ids);
    }

    /// @notice Test that Legendary Gobbler initial price is what we expect.
    function testLegendaryGobblerInitialPrice() public {
        // Start of initial auction after initial interval is minted.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
        uint256 cost = gobblers.legendaryGobblerPrice();
        // Initial auction should start at a cost of 69.
        assertEq(cost, 69);
    }

    /// @notice Test that auction ends at a price of 0.
    function testLegendaryGobblerFinalPrice() public {
        // Mint 2 full intervals.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);
        uint256 cost = gobblers.legendaryGobblerPrice();
        // Auction price should be 0 after full interval decay.
        assertEq(cost, 0);
    }

    /// @notice Test that auction ends at a price of 0 even after the interval.
    function testLegendaryGobblerPastFinalPrice() public {
        // Mint 3 full intervals.
        vm.warp(block.timestamp + 600 days);
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 3);
        uint256 cost = gobblers.legendaryGobblerPrice();
        // Auction price should be 0 after full interval decay.
        assertEq(cost, 0);
    }

    /// @notice Test that mid price happens when we expect.
    function testLegendaryGobblerMidPrice() public {
        // Mint first interval and half of second interval.
        mintGobblerToAddress(users[0], (gobblers.LEGENDARY_AUCTION_INTERVAL() * 3) / 2);
        uint256 cost = gobblers.legendaryGobblerPrice();
        // Auction price should be cut by half mid way through auction.
        assertEq(cost, 34);
    }

    /// @notice Test that initial price does't fall below what we expect.
    function testLegendaryGobblerMinStartPrice() public {
        // Mint two full intervals, such that price of first auction goes to zero.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);
        // Empty id list.
        uint256[] memory _ids;
        // Mint first auction at zero cost.
        gobblers.mintLegendaryGobbler(_ids);
        // Start cost of next auction, which should equal 69.
        uint256 startCost = gobblers.legendaryGobblerPrice();
        assertEq(startCost, 69);
    }

    /// @notice Test that Legendary Gobblers can be minted.
    function testMintLegendaryGobbler() public {
        uint256 startTime = block.timestamp + 30 days;
        vm.warp(startTime);
        // Mint full interval to kick off first auction.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
        uint256 cost = gobblers.legendaryGobblerPrice();
        assertEq(cost, 69);
        setRandomnessAndReveal(cost, "seed");
        uint256 emissionMultipleSum;
        for (uint256 curId = 1; curId <= cost; curId++) {
            ids.push(curId);
            assertEq(gobblers.ownerOf(curId), users[0]);
            emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);
        }

        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum);

        vm.prank(users[0]);
        uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);

        // Legendary is owned by user.
        assertEq(gobblers.ownerOf(mintedLegendaryId), users[0]);
        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum * 2);

        assertEq(gobblers.getGobblerEmissionMultiple(mintedLegendaryId), emissionMultipleSum * 2);

        for (uint256 i = 0; i < ids.length; i++) assertEq(gobblers.ownerOf(ids[i]), address(0));
    }

    /// @notice Test that Legendary Gobblers can be minted at 0 cost.
    function testMintFreeLegendaryGobbler() public {
        uint256 startTime = block.timestamp + 30 days;
        vm.warp(startTime);

        // Mint 2 full intervals to send price to zero.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);

        uint256 cost = gobblers.legendaryGobblerPrice();
        assertEq(cost, 0);

        vm.prank(users[0]);
        uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);

        assertEq(gobblers.ownerOf(mintedLegendaryId), users[0]);
        assertEq(gobblers.getGobblerEmissionMultiple(mintedLegendaryId), 0);
    }

    /// @notice Test that Legendary Gobblers can be minted at 0 cost.
    function testMintFreeLegendaryGobblerPastInterval() public {
        uint256 startTime = block.timestamp + 30 days;
        vm.warp(startTime);

        // Mint 3 full intervals to send price to zero.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 3);

        uint256 cost = gobblers.legendaryGobblerPrice();
        assertEq(cost, 0);

        vm.prank(users[0]);
        uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);

        assertEq(gobblers.ownerOf(mintedLegendaryId), users[0]);
        assertEq(gobblers.getGobblerEmissionMultiple(mintedLegendaryId), 0);
    }

    /// @notice Test that legendary gobblers can't be minted with the wrong ids length.
    function testMintLegendaryGobblerWithWrongLength() public {
        uint256 startTime = block.timestamp + 30 days;
        vm.warp(startTime);
        // Mint full interval to kick off first auction.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
        uint256 cost = gobblers.legendaryGobblerPrice();
        assertEq(cost, 69);
        setRandomnessAndReveal(cost, "seed");
        uint256 emissionMultipleSum;
        for (uint256 curId = 1; curId <= cost; curId++) {
            ids.push(curId);
            assertEq(gobblers.ownerOf(curId), users[0]);
            emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);
        }

        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum);

        ids.push(9999999);

        vm.prank(users[0]);
        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.IncorrectGobblerAmount.selector, cost));
        gobblers.mintLegendaryGobbler(ids);
    }

    /// @notice Test that legendary gobblers can't be minted if the user doesn't own one of the ids.
    function testMintLegendaryGobblerWithUnownedId() public {
        uint256 startTime = block.timestamp + 30 days;
        vm.warp(startTime);
        // Mint full interval to kick off first auction.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
        uint256 cost = gobblers.legendaryGobblerPrice();
        assertEq(cost, 69);
        setRandomnessAndReveal(cost, "seed");
        uint256 emissionMultipleSum;
        for (uint256 curId = 1; curId <= cost; curId++) {
            ids.push(curId);
            assertEq(gobblers.ownerOf(curId), users[0]);
            emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);
        }

        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum);

        ids.pop();
        ids.push(999);

        vm.prank(users[0]);
        vm.expectRevert("WRONG_FROM");
        gobblers.mintLegendaryGobbler(ids);
    }

    /// @notice Test that legendary gobblers have expected ids.
    function testMintLegendaryGobblersExpectedIds() public {
        // We expect the first legendary to have this id.
        uint256 nextMintLegendaryId = 9991;
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
        for (int256 i = 0; i < 10; i++) {
            vm.warp(block.timestamp + 400 days);

            mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
            uint256 justMintedLegendaryId = gobblers.mintLegendaryGobbler(ids);
            //assert that legendaries have the expected ids
            assertEq(nextMintLegendaryId, justMintedLegendaryId);
            nextMintLegendaryId++;
        }

        // Minting any more should fail.
        vm.expectRevert(ArtGobblers.NoRemainingLegendaryGobblers.selector);
        gobblers.mintLegendaryGobbler(ids);
    }

    /// @notice Test that Legendary Gobblers can't be burned to mint another legendary.
    function testCannotMintLegendaryWithLegendary() public {
        vm.warp(block.timestamp + 30 days);

        mintNextLegendary(users[0]);
        uint256 mintedLegendaryId = gobblers.FIRST_LEGENDARY_GOBBLER_ID();
        //First legendary to be minted should be 9991
        assertEq(mintedLegendaryId, 9991);
        uint256 cost = gobblers.legendaryGobblerPrice();

        // Starting price should be 69.
        assertEq(cost, 69);
        setRandomnessAndReveal(cost, "seed");
        for (uint256 i = 1; i <= cost; i++) ids.push(i);

        ids[0] = mintedLegendaryId; // Try to pass in the legendary we just minted as well.
        vm.prank(users[0]);
        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.CannotBurnLegendary.selector, mintedLegendaryId));
        gobblers.mintLegendaryGobbler(ids);
    }

    /*//////////////////////////////////////////////////////////////
                                  URIS
    //////////////////////////////////////////////////////////////*/

    /// @notice Test unminted URI is correct.
    function testUnmintedUri() public {
        assertEq(gobblers.uri(1), "");
    }

    /// @notice Test that unrevealed URI is correct.
    function testUnrevealedUri() public {
        uint256 gobblerCost = gobblers.gobblerPrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(users[0], gobblerCost);
        vm.prank(users[0]);
        gobblers.mintFromGoo(type(uint256).max);
        // assert gobbler not revealed after mint
        assertTrue(stringEquals(gobblers.uri(1), gobblers.UNREVEALED_URI()));
    }

    /// @notice Test that revealed URI is correct.
    function testRevealedUri() public {
        mintGobblerToAddress(users[0], 1);
        // unrevealed gobblers have 0 value attributes
        assertEq(gobblers.getGobblerEmissionMultiple(1), 0);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");
        (, uint48 expectedIndex, ) = gobblers.getGobblerData(1);
        string memory expectedURI = string(abi.encodePacked(gobblers.BASE_URI(), uint256(expectedIndex).toString()));
        assertTrue(stringEquals(gobblers.uri(1), expectedURI));
    }

    /// @notice Test that legendary gobbler URI is correct.
    function testMintedLegendaryURI() public {
        //mint legendary for free
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);
        uint256 currentLegendaryId = gobblers.mintLegendaryGobbler(ids);

        //expected URI should not be shuffled
        string memory expectedURI = string(
            abi.encodePacked(gobblers.BASE_URI(), uint256(currentLegendaryId).toString())
        );
        string memory actualURI = gobblers.uri(currentLegendaryId);
        assertTrue(stringEquals(actualURI, expectedURI));
    }

    /// @notice Test that un-minted legendary gobbler URI is correct.
    function testUnmintedLegendaryUri() public {
        (, uint128 numSold) = gobblers.legendaryGobblerAuctionData();

        assertEq(gobblers.uri(gobblers.FIRST_LEGENDARY_GOBBLER_ID()), "");
        assertEq(gobblers.uri(gobblers.FIRST_LEGENDARY_GOBBLER_ID() + 1), "");
    }

    /*//////////////////////////////////////////////////////////////
                                 REVEALS
    //////////////////////////////////////////////////////////////*/

    function testDoesNotAllowRevealingZero() public {
        vm.warp(block.timestamp + 24 hours);
        vm.expectRevert(ArtGobblers.ZeroToBeRevealed.selector);
        gobblers.requestRandomSeed();
    }

    /// @notice Cannot request random seed before 24 hours have passed from initial mint.
    function testRevealDelayInitialMint() public {
        mintGobblerToAddress(users[0], 1);
        vm.expectRevert(ArtGobblers.RequestTooEarly.selector);
        gobblers.requestRandomSeed();
    }

    /// @notice Cannot reveal more gobblers than remaining to be revealed.
    function testCannotRevealMoreGobblersThanRemainingToBeRevealed() public {
        mintGobblerToAddress(users[0], 1);

        vm.warp(block.timestamp + 24 hours);

        bytes32 requestId = gobblers.requestRandomSeed();
        uint256 randomness = uint256(keccak256(abi.encodePacked("seed")));
        vrfCoordinator.callBackWithRandomness(requestId, randomness, address(gobblers));

        mintGobblerToAddress(users[0], 2);

        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.NotEnoughRemainingToBeRevealed.selector, 1));
        gobblers.revealGobblers(2);
    }

    /// @notice Cannot request random seed before 24 hours have passed from last reveal,
    function testRevealDelayRecurring() public {
        // Mint and reveal first gobbler
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");
        // Attempt reveal before 24 hours have passed
        mintGobblerToAddress(users[0], 1);
        vm.expectRevert(ArtGobblers.RequestTooEarly.selector);
        gobblers.requestRandomSeed();
    }

    /// @notice Test that seed can't be set without first revealing pending gobblers.
    function testCantSetRandomSeedWithoutRevealing() public {
        mintGobblerToAddress(users[0], 2);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");
        vm.warp(block.timestamp + 1 days);
        // should fail since there is one remaining gobbler to be revealed with seed
        vm.expectRevert(ArtGobblers.RevealsPending.selector);
        setRandomnessAndReveal(1, "seed");
    }

    /// @notice Test that revevals work as expected
    function testMultiReveal() public {
        mintGobblerToAddress(users[0], 100);
        // first 100 gobblers should be unrevealed
        for (uint256 i = 1; i <= 100; i++) {
            assertEq(gobblers.uri(i), gobblers.UNREVEALED_URI());
        }

        vm.warp(block.timestamp + 1 days); // can only reveal every 24 hours

        setRandomnessAndReveal(50, "seed");
        // first 50 gobblers should now be revealed
        for (uint256 i = 1; i <= 50; i++) {
            assertTrue(!stringEquals(gobblers.uri(i), gobblers.UNREVEALED_URI()));
        }
        // and next 50 should remain unrevealed
        for (uint256 i = 51; i <= 100; i++) {
            assertTrue(stringEquals(gobblers.uri(i), gobblers.UNREVEALED_URI()));
        }
    }

    function testCannotReuseSeedForReveal() public {
        // first mint and reveal.
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");
        // seed used for first reveal.
        (uint64 firstSeed, , , , ) = gobblers.gobblerRevealsData();
        // second mint.
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        gobblers.requestRandomSeed();
        // seed we want to use for second reveal.
        (uint64 secondSeed, , , , ) = gobblers.gobblerRevealsData();
        // verify that we are trying to use the same seed.
        assertEq(firstSeed, secondSeed);
        // try to reveal with same seed, which should fail.
        vm.expectRevert(ArtGobblers.SeedPending.selector);
        gobblers.revealGobblers(1);
        assertTrue(true);
    }

    /*//////////////////////////////////////////////////////////////
                                  GOO
    //////////////////////////////////////////////////////////////*/

    /// @notice test that goo balance grows as expected.
    function testSimpleRewards() public {
        mintGobblerToAddress(users[0], 1);
        // balance should initially be zero
        assertEq(gobblers.gooBalance(users[0]), 0);
        vm.warp(block.timestamp + 100000);
        // balance should be zero while no reveal
        assertEq(gobblers.gooBalance(users[0]), 0);
        setRandomnessAndReveal(1, "seed");
        // balance should NOT grow on same timestamp after reveal
        assertEq(gobblers.gooBalance(users[0]), 0);
        vm.warp(block.timestamp + 100000);
        // balance should grow after reveal
        assertGt(gobblers.gooBalance(users[0]), 0);
    }

    /// @notice Test that goo removal works as expected.
    function testGooRemoval() public {
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");
        vm.warp(block.timestamp + 100000);
        uint256 initialBalance = gobblers.gooBalance(users[0]);
        uint256 removalAmount = initialBalance / 10; //10%
        vm.prank(users[0]);
        gobblers.removeGoo(removalAmount);
        uint256 finalBalance = gobblers.gooBalance(users[0]);
        // balance should change
        assertTrue(initialBalance != finalBalance);
        assertEq(initialBalance, finalBalance + removalAmount);
        // user should have removed goo
        assertEq(goo.balanceOf(users[0]), removalAmount);
    }

    /// @notice Test that goo can't be removed by a different user.
    function testCantRemoveGoo() public {
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 100000);
        setRandomnessAndReveal(1, "seed");
        vm.prank(users[1]);
        vm.expectRevert(stdError.arithmeticError);
        gobblers.removeGoo(1);
    }

    /// @notice Test that adding goo is reflected in balance.
    function testGooAddition() public {
        mintGobblerToAddress(users[0], 1);
        assertEq(gobblers.getGobblerEmissionMultiple(1), 0);
        assertEq(gobblers.getUserEmissionMultiple(users[0]), 0);
        // waiting after mint to reveal shouldn't affect balance
        vm.warp(block.timestamp + 100000);
        assertEq(gobblers.gooBalance(users[0]), 0);
        setRandomnessAndReveal(1, "seed");
        uint256 gobblerMultiple = gobblers.getGobblerEmissionMultiple(1);
        assertGt(gobblerMultiple, 0);
        assertEq(gobblers.getUserEmissionMultiple(users[0]), gobblerMultiple);
        vm.prank(address(gobblers));
        uint256 additionAmount = 1000;
        goo.mintForGobblers(users[0], additionAmount);
        vm.prank(users[0]);
        gobblers.addGoo(additionAmount);
        assertEq(gobblers.gooBalance(users[0]), additionAmount);
    }

    /// @notice Test that emission multiple changes as expected after transfer.
    function testEmissionMultipleUpdatesAfterTransfer() public {
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");

        uint256 initialUserMultiple = gobblers.getUserEmissionMultiple(users[0]);
        assertGt(initialUserMultiple, 0);
        assertEq(gobblers.getUserEmissionMultiple(users[1]), 0);

        vm.prank(users[0]);
        gobblers.safeTransferFrom(users[0], users[1], 1, 1, "");

        assertEq(gobblers.getUserEmissionMultiple(users[0]), 0);
        assertEq(gobblers.getUserEmissionMultiple(users[1]), initialUserMultiple);
    }

    /// @notice Test that gobbler balances are accurate after transfer.
    function testGobblerBalancesAfterTransfer() public {
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");

        vm.warp(block.timestamp + 1000000);

        uint256 userOneBalance = gobblers.gooBalance(users[0]);
        uint256 userTwoBalance = gobblers.gooBalance(users[1]);
        //user with gobbler should have non-zero balance
        assertGt(userOneBalance, 0);
        //other user should have zero balance
        assertEq(userTwoBalance, 0);
        //transfer gobblers
        vm.prank(users[0]);
        gobblers.safeTransferFrom(users[0], users[1], 1, 1, "");
        //balance should not change after transfer
        assertEq(gobblers.gooBalance(users[0]), userOneBalance);
        assertEq(gobblers.gooBalance(users[1]), userTwoBalance);
    }

    /*//////////////////////////////////////////////////////////////
                               FEEDING ART
    //////////////////////////////////////////////////////////////*/

    /// @notice Test that pages can be fed to gobblers.
    function testFeedingArt() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        uint256 pagePrice = pages.pagePrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(user, pagePrice);
        vm.startPrank(user);
        pages.mintFromGoo(type(uint256).max);
        gobblers.feedArt(1, address(pages), 1, false);
        vm.stopPrank();
        assertEq(gobblers.getCopiesOfArtFedToGobbler(1, address(pages), 1), 1);
    }

    /// @notice Test that you can't feed art to gobblers you don't own.
    function testCantFeedArtToUnownedGobbler() public {
        address user = users[0];
        uint256 pagePrice = pages.pagePrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(user, pagePrice);
        vm.startPrank(user);
        pages.mintFromGoo(type(uint256).max);
        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.OwnerMismatch.selector, address(0)));
        gobblers.feedArt(1, address(pages), 1, false);
        vm.stopPrank();
    }

    /// @notice Test that you can't feed art you don't own to your gobbler.
    function testCantFeedUnownedArt() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        vm.startPrank(user);
        vm.expectRevert("WRONG_FROM");
        gobblers.feedArt(1, address(pages), 1, false);
        vm.stopPrank();
    }

    function testCantFeed721As1155() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        uint256 pagePrice = pages.pagePrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(user, pagePrice);
        vm.startPrank(user);
        pages.mintFromGoo(type(uint256).max);
        vm.expectRevert();
        gobblers.feedArt(1, address(pages), 1, true);
    }

    function testFeeding1155() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        MockERC1155 token = new MockERC1155();
        token.mint(user, 0, 1, "");
        vm.startPrank(user);
        token.setApprovalForAll(address(gobblers), true);
        gobblers.feedArt(1, address(token), 0, true);
        vm.stopPrank();
        assertEq(gobblers.getCopiesOfArtFedToGobbler(1, address(token), 0), 1);
    }

    function testFeedingMultiple1155Copies() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        MockERC1155 token = new MockERC1155();
        token.mint(user, 0, 5, "");
        vm.startPrank(user);
        token.setApprovalForAll(address(gobblers), true);
        gobblers.feedArt(1, address(token), 0, true);
        gobblers.feedArt(1, address(token), 0, true);
        gobblers.feedArt(1, address(token), 0, true);
        gobblers.feedArt(1, address(token), 0, true);
        gobblers.feedArt(1, address(token), 0, true);
        vm.stopPrank();
        assertEq(gobblers.getCopiesOfArtFedToGobbler(1, address(token), 0), 5);
    }

    function testCantFeed1155As721() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        MockERC1155 token = new MockERC1155();
        token.mint(user, 0, 1, "");
        vm.startPrank(user);
        token.setApprovalForAll(address(gobblers), true);
        vm.expectRevert();
        gobblers.feedArt(1, address(token), 0, false);
    }

    /*//////////////////////////////////////////////////////////////
                           LONG-RUNNING TESTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Check that max supply is mintable
    function testLongRunningMintMaxFromGoo() public {
        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();

        for (uint256 i = 0; i < maxMintableWithGoo; i++) {
            vm.warp(block.timestamp + 1 days);
            uint256 cost = gobblers.gobblerPrice();
            vm.prank(address(gobblers));
            goo.mintForGobblers(users[0], cost);
            vm.prank(users[0]);
            gobblers.mintFromGoo(type(uint256).max);
        }
    }

    /// @notice Check that minting beyond max supply should revert.
    function testLongRunningMintMaxFromGooRevert() public {
        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();

        for (uint256 i = 0; i < maxMintableWithGoo + 1; i++) {
            vm.warp(block.timestamp + 1 days);

            if (i == maxMintableWithGoo) vm.expectRevert("UNDEFINED");
            uint256 cost = gobblers.gobblerPrice();

            vm.prank(address(gobblers));
            goo.mintForGobblers(users[0], cost);
            vm.prank(users[0]);

            if (i == maxMintableWithGoo) vm.expectRevert("UNDEFINED");
            gobblers.mintFromGoo(type(uint256).max);
        }
    }

    /// @notice Check that max reserved supplies are mintable.
    function testLongRunningMintMaxReserved() public {
        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();

        for (uint256 i = 0; i < maxMintableWithGoo; i++) {
            vm.warp(block.timestamp + 1 days);
            uint256 cost = gobblers.gobblerPrice();
            vm.prank(address(gobblers));
            goo.mintForGobblers(users[0], cost);
            vm.prank(users[0]);
            gobblers.mintFromGoo(type(uint256).max);
        }

        gobblers.mintReservedGobblers(gobblers.RESERVED_SUPPLY() / 2);
    }

    /// @notice Check that minting reserves beyond their max supply reverts.
    function testLongRunningMintMaxTeamRevert() public {
        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();

        for (uint256 i = 0; i < maxMintableWithGoo; i++) {
            vm.warp(block.timestamp + 1 days);
            uint256 cost = gobblers.gobblerPrice();
            vm.prank(address(gobblers));
            goo.mintForGobblers(users[0], cost);
            vm.prank(users[0]);
            gobblers.mintFromGoo(type(uint256).max);
        }

        gobblers.mintReservedGobblers(gobblers.RESERVED_SUPPLY() / 2);

        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);
        gobblers.mintReservedGobblers(1);
    }

    /*//////////////////////////////////////////////////////////////
                                 HELPERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a number of gobblers to the given address
    function mintGobblerToAddress(address addr, uint256 num) internal {
        for (uint256 i = 0; i < num; i++) {
            vm.startPrank(address(gobblers));
            goo.mintForGobblers(addr, gobblers.gobblerPrice());
            vm.stopPrank();

            vm.prank(addr);
            gobblers.mintFromGoo(type(uint256).max);
        }
    }

    /// @notice Call back vrf with randomness and reveal gobblers.
    function setRandomnessAndReveal(uint256 numReveal, string memory seed) internal {
        bytes32 requestId = gobblers.requestRandomSeed();
        uint256 randomness = uint256(keccak256(abi.encodePacked(seed)));
        // call back from coordinator
        vrfCoordinator.callBackWithRandomness(requestId, randomness, address(gobblers));
        gobblers.revealGobblers(numReveal);
    }

    /// @notice Check for string equality.
    function stringEquals(string memory s1, string memory s2) internal pure returns (bool) {
        return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));
    }

    function mintNextLegendary(address addr) internal {
        uint256[] memory id;
        mintGobblerToAddress(addr, gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);
        vm.prank(addr);
        gobblers.mintLegendaryGobbler(id);
    }
}


================================================
File: /test/utils/LibRLP.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {Bytes32AddressLib} from "solmate/utils/Bytes32AddressLib.sol";

library LibRLP {
    using Bytes32AddressLib for bytes32;

    // prettier-ignore
    function computeAddress(address deployer, uint256 nonce) internal pure returns (address) {
        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.
        // A one byte integer uses its own value as its length prefix, there is no additional "0x80 + length" prefix that comes before it.
        if (nonce == 0x00)             return keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))).fromLast20Bytes();
        if (nonce <= 0x7f)             return keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))).fromLast20Bytes();

        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.
        if (nonce <= type(uint8).max)  return keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))).fromLast20Bytes();
        if (nonce <= type(uint16).max) return keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))).fromLast20Bytes();
        if (nonce <= type(uint24).max) return keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))).fromLast20Bytes();

        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp
        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)
        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)
        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)
        // We assume nobody can have a nonce large enough to require more than 32 bytes.
        return keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))).fromLast20Bytes();
    }
}


================================================
File: /test/utils/mocks/MockGooCalculator.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol";

contract MockGooCalculator {
    using FixedPointMathLib for uint256;

    /// @notice Compute goo balance based on emission multiple, last balance, and days elapsed.
    /// @dev Must be kept up to date with the gooBalance function's corresponding emission balance calculations in ArtGobblers.sol.
    /// @dev Forked from https://github.com/artgobblers/art-gobblers/blob/2f19bc901ed2f1bfedeb6f113b073bfc3585386a/src/ArtGobblers.sol#L693-L708
    function computeGooBalance(
        uint256 emissionMultiple,
        uint256 lastBalanceWad,
        uint256 daysElapsedWad
    ) public pure returns (uint256) {
        unchecked {
            uint256 daysElapsedSquaredWad = daysElapsedWad.mulWadDown(daysElapsedWad); // Need to use wad math here.

            // prettier-ignore
            return lastBalanceWad + // The last recorded balance.

            // Don't need to do wad multiplication since we're
            // multiplying by a plain integer with no decimals.
            // Shift right by 2 is equivalent to division by 4.
            ((emissionMultiple * daysElapsedSquaredWad) >> 2) +

            daysElapsedWad.mulWadDown( // Terms are wads, so must mulWad.
                // No wad multiplication for emissionMultiple * lastBalance
                // because emissionMultiple is a plain integer with no decimals.
                // We multiply the sqrt's radicand by 1e18 because it expects ints.
                (emissionMultiple * lastBalanceWad * 1e18).sqrt()
            );
        }
    }
}


================================================
File: /test/utils/mocks/LinkToken.sol
================================================
// SPDX-License-Identifier: MIT

// adapter from dapptools-starter-kit
pragma solidity ^0.8.0;

import {ERC20} from "solmate/tokens/ERC20.sol";

interface ERC677Receiver {
    function onTokenTransfer(
        address _sender,
        uint256 _value,
        bytes memory _data
    ) external;
}

contract LinkToken is ERC20 {
    uint256 initialSupply = 1000000000000000000000000;

    constructor() ERC20("LinkToken", "LINK", 18) {
        _mint(msg.sender, initialSupply);
    }

    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    /**
     * @dev transfer token to a contract address with additional data if the recipient is a contact.
     * @param _to The address to transfer to.
     * @param _value The amount to be transferred.
     * @param _data The extra data to be passed to the receiving contract.
     */
    function transferAndCall(
        address _to,
        uint256 _value,
        bytes memory _data
    ) public virtual returns (bool success) {
        super.transfer(_to, _value);
        // emit Transfer(msg.sender, _to, _value, _data);
        emit Transfer(msg.sender, _to, _value, _data);
        if (isContract(_to)) {
            contractFallback(_to, _value, _data);
        }
        return true;
    }

    // PRIVATE

    function contractFallback(
        address _to,
        uint256 _value,
        bytes memory _data
    ) private {
        ERC677Receiver receiver = ERC677Receiver(_to);
        receiver.onTokenTransfer(msg.sender, _value, _data);
    }

    function isContract(address _addr) private view returns (bool hasCode) {
        uint256 length;
        assembly {
            length := extcodesize(_addr)
        }
        return length > 0;
    }
}


================================================
File: /test/utils/Utilities.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTest} from "ds-test/test.sol";
import {Vm} from "forge-std/Vm.sol";

import {LibRLP} from "./LibRLP.sol";

// common utilities for forge tests
contract Utilities is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);
    bytes32 internal nextUser = keccak256(abi.encodePacked("user address"));

    function getNextUserAddress() external returns (address payable) {
        // bytes32 to address conversion
        address payable user = payable(address(uint160(uint256(nextUser))));
        nextUser = keccak256(abi.encodePacked(nextUser));
        return user;
    }

    // create users with 100 ether balance
    function createUsers(uint256 userNum) external returns (address payable[] memory) {
        address payable[] memory users = new address payable[](userNum);
        for (uint256 i = 0; i < userNum; i++) {
            address payable user = this.getNextUserAddress();
            vm.deal(user, 100 ether);
            users[i] = user;
        }
        return users;
    }

    // move block.number forward by a given number of blocks
    function mineBlocks(uint256 numBlocks) external {
        uint256 targetBlock = block.number + numBlocks;
        vm.roll(targetBlock);
    }

    function predictContractAddress(address user, uint256 distanceFromCurrentNonce) external returns (address) {
        return LibRLP.computeAddress(user, vm.getNonce(user) + distanceFromCurrentNonce);
    }
}


================================================
File: /test/VRGDAs.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {Utilities} from "./utils/Utilities.sol";
import {console} from "./utils/Console.sol";
import {Vm} from "forge-std/Vm.sol";
import {ArtGobblers} from "../src/ArtGobblers.sol";
import {Goo} from "../src/Goo.sol";
import {Pages} from "../src/Pages.sol";
import {LinkToken} from "./utils/mocks/LinkToken.sol";
import {VRFCoordinatorMock} from "chainlink/v0.8/mocks/VRFCoordinatorMock.sol";

contract VRGDAsTest is DSTestPlus {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    uint256 constant ONE_THOUSAND_YEARS = 356 days * 1000;

    Utilities internal utils;
    address payable[] internal users;

    ArtGobblers private gobblers;
    VRFCoordinatorMock private vrfCoordinator;
    LinkToken private linkToken;

    Goo goo;
    Pages pages;

    bytes32 private keyHash;
    uint256 private fee;

    function setUp() public {
        utils = new Utilities();
        users = utils.createUsers(5);
        linkToken = new LinkToken();
        vrfCoordinator = new VRFCoordinatorMock(address(linkToken));

        goo = new Goo(
            // Gobblers:
            utils.predictContractAddress(address(this), 1),
            // Pages:
            utils.predictContractAddress(address(this), 2)
        );

        gobblers = new ArtGobblers(
            "root",
            block.timestamp,
            goo,
            address(0xBEEF),
            address(0xBEEF),
            address(vrfCoordinator),
            address(linkToken),
            keyHash,
            fee,
            "base",
            ""
        );

        pages = new Pages(block.timestamp, goo, address(0xBEEF), address(gobblers), "");
    }

    // function testFindGobblerOverflowPoint() public view {
    //     uint256 sold;
    //     while (true) {
    //         gobblers.getPrice(0 days, sold++);
    //     }
    // }

    // function testFindPagesOverflowPoint() public view {
    //     uint256 sold;
    //     while (true) {
    //         pages.getPrice(0 days, sold++);
    //     }
    // }

    function testNoOverflowForMostGobblers(uint256 timeSinceStart, uint256 sold) public {
        gobblers.getPrice(bound(timeSinceStart, 0 days, ONE_THOUSAND_YEARS), bound(sold, 0, 1731));
    }

    function testNoOverflowForAllGobblers(uint256 timeSinceStart, uint256 sold) public {
        gobblers.getPrice(bound(timeSinceStart, 3870 days, ONE_THOUSAND_YEARS), bound(sold, 0, 6391));
    }

    function testFailOverflowForBeyondLimitGobblers(uint256 timeSinceStart, uint256 sold) public {
        gobblers.getPrice(bound(timeSinceStart, 0 days, ONE_THOUSAND_YEARS), bound(sold, 6392, type(uint128).max));
    }

    function testGobblerPriceStrictlyIncreasesForMostGobblers() public {
        uint256 sold;
        uint256 previousPrice;

        while (sold <= 1731) {
            uint256 price = gobblers.getPrice(0 days, sold++);
            assertGt(price, previousPrice);
            previousPrice = price;
        }
    }

    function testNoOverflowForFirst8465Pages(uint256 timeSinceStart, uint256 sold) public {
        pages.getPrice(bound(timeSinceStart, 0 days, ONE_THOUSAND_YEARS), bound(sold, 0, 8465));
    }

    function testPagePriceStrictlyIncreasesFor8465Pages() public {
        uint256 sold;
        uint256 previousPrice;

        while (sold <= 8465) {
            uint256 price = pages.getPrice(0 days, sold++);
            assertGt(price, previousPrice);
            previousPrice = price;
        }
    }
}


================================================
File: /.gitmodules
================================================
[submodule "lib/ds-test"]
	path = lib/ds-test
	url = https://github.com/dapphub/ds-test
[submodule "lib/solmate"]
	path = lib/solmate
	url = https://github.com/Rari-Capital/solmate
[submodule "lib/forge-std"]
	path = lib/forge-std
	url = https://github.com/brockelmore/forge-std
[submodule "lib/chainlink"]
	path = lib/chainlink
	url = https://github.com/smartcontractkit/chainlink


================================================
File: /script/deploy/DeployRinkeby.s.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DeployBase} from "./DeployBase.s.sol";

contract DeployRinkeby is DeployBase {
    address public immutable coldWallet = 0x126620598A797e6D9d2C280b5dB91b46F27A8330;

    address public immutable root = 0x1D18077167c1177253555e45B4b5448B11E30b4b;

    uint256 public immutable mintStart = 1656369768;

    string public constant gobblerBaseUri = "https://testnet.ag.xyz/api/nfts/gobblers/";
    string public constant gobblerUnrevealedUri = "https://testnet.ag.xyz/api/nfts/unrevealed";
    string public constant pagesBaseUri = "https://testnet.ag.xyz/api/nfts/pages/";

    constructor()
        DeployBase(
            // Team cold wallet:
            coldWallet,
            // Merkle root:
            keccak256(abi.encodePacked(root)),
            // Mint start:
            mintStart,
            // VRF coordinator:
            address(0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B),
            // LINK token:
            address(0x01BE23585060835E02B77ef475b0Cc51aA1e0709),
            // Chainlink hash:
            0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311,
            // Chainlink fee:
            0.1e18,
            // Gobbler base URI:
            gobblerBaseUri,
            // Gobbler unrevealed URI:
            gobblerUnrevealedUri,
            // Pages base URI:
            pagesBaseUri
        )
    {}
}


================================================
File: /script/deploy/DeployBase.s.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import "forge-std/Script.sol";

import {LibRLP} from "../../test/utils/LibRLP.sol";

import {GobblerReserve} from "../../src/utils/GobblerReserve.sol";

import {Goo} from "../../src/Goo.sol";
import {Pages} from "../../src/Pages.sol";
import {ArtGobblers} from "../../src/ArtGobblers.sol";

abstract contract DeployBase is Script {
    // Environment specific variables.
    address private immutable teamColdWallet;
    bytes32 private immutable merkleRoot;
    uint256 private immutable mintStart;
    address private immutable vrfCoordinator;
    address private immutable linkToken;
    bytes32 private immutable chainlinkKeyHash;
    uint256 private immutable chainlinkFee;
    string private gobblerBaseUri;
    string private gobblerUnrevealedUri;
    string private pagesBaseUri;

    // Deploy addresses.
    GobblerReserve public teamReserve;
    GobblerReserve public communityReserve;
    Goo public goo;
    ArtGobblers public artGobblers;
    Pages public pages;

    constructor(
        address _teamColdWallet,
        bytes32 _merkleRoot,
        uint256 _mintStart,
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _chainlinkKeyHash,
        uint256 _chainlinkFee,
        string memory _gobblerBaseUri,
        string memory _gobblerUnrevealedUri,
        string memory _pagesBaseUri
    ) {
        teamColdWallet = _teamColdWallet;
        merkleRoot = _merkleRoot;
        mintStart = _mintStart;
        vrfCoordinator = _vrfCoordinator;
        linkToken = _linkToken;
        chainlinkKeyHash = _chainlinkKeyHash;
        chainlinkFee = _chainlinkFee;
        gobblerBaseUri = _gobblerBaseUri;
        gobblerUnrevealedUri = _gobblerUnrevealedUri;
        pagesBaseUri = _pagesBaseUri;
    }

    function run() external {
        vm.startBroadcast();

        // Precomputed contract addresses, based on contract deploy nonces.
        // tx.origin is the address who will actually broadcast the contract creations below.
        address gobblerAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 3);
        address pageAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 4);

        // Deploy team and community reserves, owned by cold wallet.
        teamReserve = new GobblerReserve(ArtGobblers(gobblerAddress), teamColdWallet);
        communityReserve = new GobblerReserve(ArtGobblers(gobblerAddress), teamColdWallet);

        // Deploy goo contract.
        goo = new Goo(
            // Gobblers contract address:
            gobblerAddress,
            // Pages contract address:
            pageAddress
        );

        // Deploy gobblers contract,
        artGobblers = new ArtGobblers(
            merkleRoot,
            mintStart,
            goo,
            address(teamReserve),
            address(communityReserve),
            vrfCoordinator,
            linkToken,
            chainlinkKeyHash,
            chainlinkFee,
            gobblerBaseUri,
            gobblerUnrevealedUri
        );

        // Deploy pages contract.
        pages = new Pages(mintStart, goo, teamColdWallet, gobblerAddress, pagesBaseUri);

        vm.stopBroadcast();
    }
}


================================================
File: /foundry.toml
================================================
[default]
solc = "0.8.13"
optimizer_runs = 1000000
bytecode_hash = "none"
no_match_test = "FFI|LongRunning"

[intense]
fuzz_runs = 10000
no_match_test = "FFI"

[ffi]
ffi = true
no_match_test = "LongRunning"


================================================
File: /package.json
================================================
{
  "name": "art-gobblers",
  "author": "artgobblers",
  "version": "1.0.0",
  "description": "Art Gobblers scan the cosmos in search of art producing life.",
  "homepage": "https://github.com/FrankieIsLost/art-gobblers#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/FrankieIsLost/art-gobblers.git"
  },
  "scripts": {
    "prettier": "prettier --write **.sol",
    "prettier:list": "prettier --list-different **.sol",
    "prettier:check": "prettier --check **.sol",
    "solhint": "solhint --config ./.solhint.json 'src/**/*.sol' --fix",
    "solhint:check": "solhint --config ./.solhint.json 'src/**/*.sol'",
    "lint": "npm run prettier && npm run solhint",
    "lint:check": "npm run prettier:check && npm run solhint:check"
  },
  "devDependencies": {
    "prettier": "^2.5.1",
    "prettier-plugin-solidity": "^1.0.0-beta.19",
    "solhint": "^3.3.6"
  }
}


================================================
File: /README.md
================================================
<img align="right" width="150" height="150" top="100" src="./assets/gobbler.png">

# Art Gobblers • [![CI](https://github.com/artgobblers/art-gobblers/actions/workflows/tests.yml/badge.svg)](https://github.com/artgobblers/art-gobblers/actions/workflows/CI.yml)

Art Gobblers scan the cosmos in search of art producing life.

![Gobbler Lifecycle](assets/state-machines/gobbler-lifecycle.png)
![Legendary Gobbler Auctions](assets/state-machines/legendary-gobbler-auctions.png)
![Page Auctions](assets/state-machines/page-auctions.png)

## Contributing

You will need a copy of [Foundry](https://github.com/foundry-rs/foundry) installed before proceeding. See the [installation guide](https://github.com/foundry-rs/foundry#installation) for details.

### Setup

```sh
git clone https://github.com/artgobblers/art-gobblers.git
cd art-gobblers
```

### Run Tests

```sh
forge test
```

### Update Gas Snapshots

```sh
forge snapshot
```


================================================
File: /src/Pages.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {VRGDA} from "./utils/vrgda/VRGDA.sol";
import {LibString} from "./utils/lib/LibString.sol";
import {PagesERC721} from "./utils/token/PagesERC721.sol";
import {LogisticVRGDA} from "./utils/vrgda/LogisticVRGDA.sol";
import {PostSwitchVRGDA} from "./utils/vrgda/PostSwitchVRGDA.sol";

import {Goo} from "./Goo.sol";

/// @title Pages NFT
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Pages is an ERC721 that can hold custom art.
contract Pages is PagesERC721, LogisticVRGDA, PostSwitchVRGDA {
    using LibString for uint256;

    /*//////////////////////////////////////////////////////////////
                                ADDRESSES
    //////////////////////////////////////////////////////////////*/

    /// @notice The address of the goo ERC20 token contract.
    Goo public immutable goo;

    /// @notice The address which receives pages reserved for the community.
    address public immutable community;

    /*//////////////////////////////////////////////////////////////
                                  URIS
    //////////////////////////////////////////////////////////////*/

    /// @notice Base URI for minted pages.
    string public BASE_URI;

    /*//////////////////////////////////////////////////////////////
                            VRGDA INPUT STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Timestamp for the start of the VRGDA mint.
    uint256 public immutable mintStart;

    /// @notice Id of the most recently minted page.
    /// @dev Will be 0 if no pages have been minted yet.
    uint128 public currentId;

    /*//////////////////////////////////////////////////////////////
                          COMMUNITY PAGES STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice The number of pages minted to the community reserve.
    uint128 public numMintedForCommunity;

    /*//////////////////////////////////////////////////////////////
                            PRICING CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @dev The day the switch from a logistic to translated linear VRGDA is targeted to occur.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal constant SWITCH_DAY_WAD = 270e18;

    /// @notice The minimum amount of pages that must be sold for the VRGDA issuance
    /// schedule to switch from logistic to the "post switch" translated linear formula.
    /// @dev Computed off-chain by plugging the switch day into the uninverted pacing formula.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal constant SOLD_BY_SWITCH_WAD = 8598.35810341741976233e18;

    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event PagePurchased(address indexed user, uint256 indexed pageId, uint256 price);

    event CommunityPagesMinted(address indexed user, uint256 lastMintedPageId, uint256 numPages);

    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/

    error ReserveImbalance();

    error PriceExceededMax(uint256 currentPrice);

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(
        // Mint config:
        uint256 _mintStart,
        // Addresses:
        Goo _goo,
        address _community,
        address _artGobblers,
        // URIs:
        string memory _baseUri
    )
        VRGDA(
            4.2069e18, // Initial price.
            0.31e18 // Per period price decrease.
        )
        LogisticVRGDA(
            9000e18, // Asymptote.
            0.014e18 // Time scale.
        )
        PostSwitchVRGDA(
            SOLD_BY_SWITCH_WAD, // Sold by switch.
            SWITCH_DAY_WAD, // Target switch day.
            10e18 // Pages to target per day.
        )
        PagesERC721(_artGobblers, "Pages", "PAGE")
    {
        mintStart = _mintStart;

        goo = _goo;

        community = _community;

        BASE_URI = _baseUri;
    }

    /*//////////////////////////////////////////////////////////////
                              MINTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a page with goo, burning the cost.
    /// @param maxPrice Maximum price to pay to mint the page.
    /// @return pageId The id of the page that was minted.
    function mintFromGoo(uint256 maxPrice) external returns (uint256 pageId) {
        // Will revert if prior to mint start.
        uint256 currentPrice = pagePrice();

        // If the current price is above the user's specified max, revert.
        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);

        goo.burnForPages(msg.sender, currentPrice);

        unchecked {
            emit PagePurchased(msg.sender, pageId = ++currentId, currentPrice);

            _mint(msg.sender, pageId);
        }
    }

    /// @notice Calculate the mint cost of a page.
    /// @dev If the number of sales is below a pre-defined threshold, we use the
    /// VRGDA pricing algorithm, otherwise we use the post-switch pricing formula.
    /// @dev Reverts due to underflow if minting hasn't started yet. Done to save gas.
    function pagePrice() public view returns (uint256) {
        // We need checked math here to cause overflow
        // before minting has begun, preventing mints.
        uint256 timeSinceStart = block.timestamp - mintStart;

        unchecked {
            // The number of pages minted for the community reserve
            // cannot ever exceed 10% of the total supply of pages.
            return getPrice(timeSinceStart, currentId - numMintedForCommunity);
        }
    }

    function getTargetDayForNextSale(int256 tokens)
        internal
        view
        override(LogisticVRGDA, PostSwitchVRGDA)
        returns (int256)
    {
        return
            tokens < SOLD_BY_SWITCH_WAD
                ? LogisticVRGDA.getTargetDayForNextSale(tokens)
                : PostSwitchVRGDA.getTargetDayForNextSale(tokens);
    }

    /*//////////////////////////////////////////////////////////////
                      COMMUNITY PAGES MINTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a number of pages to the community reserve.
    /// @param numPages The number of pages to mint to the reserve.
    /// @dev Pages minted to the reserve cannot compromise more than 10% of the sum of the
    /// supply of goo minted pages and the supply of pages minted to the community reserve.
    function mintCommunityPages(uint256 numPages) external returns (uint256 lastMintedPageId) {
        unchecked {
            // Optimistically increment numMintedForCommunity, may be reverted below.
            // Overflow in this calculation is possible but numPages would have to
            // be so large that it would cause the loop to run out of gas quickly.
            uint256 newNumMintedForCommunity = numMintedForCommunity += uint128(numPages);

            // Ensure that after this mint pages minted to the community reserve won't compromise more than
            // 10% of the new total page supply. currentId is equivalent to the current total supply of pages.
            if (newNumMintedForCommunity > ((lastMintedPageId = currentId) + numPages) / 10) revert ReserveImbalance();

            // Mint the pages to the community reserve while updating lastMintedPageId.
            for (uint256 i = 0; i < numPages; i++) _mint(community, ++lastMintedPageId);

            currentId = uint128(lastMintedPageId); // Update currentId with the last minted page id.

            emit CommunityPagesMinted(msg.sender, lastMintedPageId, numPages);
        }
    }

    /*//////////////////////////////////////////////////////////////
                             TOKEN URI LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Returns a pages's URI if it has been minted.
    /// @param pageId The id of the page to get the URI for.
    function tokenURI(uint256 pageId) public view virtual override returns (string memory) {
        if (pageId > currentId) return "";

        return string(abi.encodePacked(BASE_URI, pageId.toString()));
    }
}


================================================
File: /src/Goo.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {ERC20} from "solmate/tokens/ERC20.sol";

/// @title Goo Token (GOO)
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Goo is the in-game token for ArtGobblers. It's a standard ERC20
/// token that can be burned and minted by the gobblers and pages contract.
contract Goo is ERC20("Goo", "GOO", 18) {
    /*//////////////////////////////////////////////////////////////
                                ADDRESSES
    //////////////////////////////////////////////////////////////*/

    /// @notice The address of the Art Gobblers contract.
    address public immutable artGobblers;

    /// @notice The address of the Pages contract.
    address public immutable pages;

    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/

    error Unauthorized();

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(address _artGobblers, address _pages) {
        artGobblers = _artGobblers;
        pages = _pages;
    }

    /*//////////////////////////////////////////////////////////////
                             MINT/BURN LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Requires caller address to match user address.
    modifier only(address user) {
        if (msg.sender != user) revert Unauthorized();

        _;
    }

    /// @notice Mint any amount of goo to a user. Can only be called by ArtGobblers.
    /// @param to The address of the user to mint goo to.
    /// @param amount The amount of goo to mint.
    function mintForGobblers(address to, uint256 amount) public only(artGobblers) {
        _mint(to, amount);
    }

    /// @notice Burn any amount of goo from a user. Can only be called by ArtGobblers.
    /// @param from The address of the user to burn goo from.
    /// @param amount The amount of goo to burn.
    function burnForGobblers(address from, uint256 amount) public only(artGobblers) {
        _burn(from, amount);
    }

    /// @notice Burn any amount of goo from a user. Can only be called by Pages.
    /// @param from The address of the user to burn goo from.
    /// @param amount The amount of goo to burn.
    function burnForPages(address from, uint256 amount) public only(pages) {
        _burn(from, amount);
    }
}


================================================
File: /src/ArtGobblers.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {Owned} from "solmate/auth/Owned.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol";
import {ERC1155, ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";

import {VRFConsumerBase} from "chainlink/v0.8/VRFConsumerBase.sol";

import {VRGDA} from "./utils/vrgda/VRGDA.sol";
import {LibString} from "./utils/lib/LibString.sol";
import {LogisticVRGDA} from "./utils/vrgda/LogisticVRGDA.sol";
import {MerkleProofLib} from "./utils/lib/MerkleProofLib.sol";
import {GobblersERC1155B} from "./utils/token/GobblersERC1155B.sol";

import {Goo} from "./Goo.sol";

/// @title Art Gobblers NFT
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Art Gobblers scan the cosmos in search of art producing life.
contract ArtGobblers is GobblersERC1155B, LogisticVRGDA, VRFConsumerBase, Owned, ERC1155TokenReceiver {
    using LibString for uint256;
    using FixedPointMathLib for uint256;

    /*//////////////////////////////////////////////////////////////
                                ADDRESSES
    //////////////////////////////////////////////////////////////*/

    /// @notice The address of the Goo ERC20 token contract.
    Goo public immutable goo;

    /// @notice The address which receives gobblers reserved for the team.
    address public immutable team;

    /// @notice The address which receives gobblers reserved for the community.
    address public immutable community;

    /*//////////////////////////////////////////////////////////////
                            SUPPLY CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Maximum number of mintable gobblers.
    uint256 public constant MAX_SUPPLY = 10000;

    /// @notice Maximum amount of gobblers mintable via mintlist.
    uint256 public constant MINTLIST_SUPPLY = 2000;

    /// @notice Maximum amount of mintable legendary gobblers.
    uint256 public constant LEGENDARY_SUPPLY = 10;

    /// @notice Maximum amount of gobblers split between the reserves.
    /// @dev Set to compromise 20% of the sum of goo mintable gobblers + reserved gobblers.
    uint256 public constant RESERVED_SUPPLY = (MAX_SUPPLY - MINTLIST_SUPPLY - LEGENDARY_SUPPLY) / 5;

    /// @notice Maximum amount of gobblers that can be minted via VRGDA.
    // prettier-ignore
    uint256 public constant MAX_MINTABLE = MAX_SUPPLY
        - MINTLIST_SUPPLY
        - LEGENDARY_SUPPLY
        - RESERVED_SUPPLY;

    /*//////////////////////////////////////////////////////////////
                           METADATA CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @notice The name displayed for the contract on Etherscan.
    string public constant name = "Art Gobblers";

    /// @notice URI for gobblers that have yet to be revealed.
    string public UNREVEALED_URI;

    /// @notice Base URI for minted gobblers.
    string public BASE_URI;

    /*//////////////////////////////////////////////////////////////
                              VRF CONSTANTS
    //////////////////////////////////////////////////////////////*/

    bytes32 internal immutable chainlinkKeyHash;

    uint256 internal immutable chainlinkFee;

    /*//////////////////////////////////////////////////////////////
                             MINTLIST STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Merkle root of mint mintlist.
    bytes32 public immutable merkleRoot;

    /// @notice Mapping to keep track of which addresses have claimed from mintlist.
    mapping(address => bool) public hasClaimedMintlistGobbler;

    /*//////////////////////////////////////////////////////////////
                            VRGDA INPUT STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Timestamp for the start of minting.
    uint256 public immutable mintStart;

    /// @notice Number of gobblers minted from goo.
    uint128 public numMintedFromGoo;

    /*//////////////////////////////////////////////////////////////
                         STANDARD GOBBLER STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Id of the most recently minted non legendary gobbler.
    /// @dev Will be 0 if no non legendary gobblers have been minted yet.
    uint128 public currentNonLegendaryId;

    /// @notice The number of gobblers minted to the reserves.
    uint256 public numMintedForReserves;

    /*//////////////////////////////////////////////////////////////
                     LEGENDARY GOBBLER AUCTION STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice The last LEGENDARY_SUPPLY ids are reserved for legendary gobblers.
    uint256 public constant FIRST_LEGENDARY_GOBBLER_ID = MAX_SUPPLY - LEGENDARY_SUPPLY + 1;

    /// @notice Legendary auctions begin each time a multiple of these many gobblers have been minted.
    /// @dev We add 1 to LEGENDARY_SUPPLY because legendary auctions begin only after the first interval.
    uint256 public constant LEGENDARY_AUCTION_INTERVAL = MAX_MINTABLE / (LEGENDARY_SUPPLY + 1);

    /// @notice Struct holding data required for legendary gobbler auctions.
    struct LegendaryGobblerAuctionData {
        // Start price of current legendary gobbler auction.
        uint128 startPrice;
        // Number of legendary gobblers sold so far.
        uint128 numSold;
    }

    /// @notice Data about the current legendary gobbler auction.
    LegendaryGobblerAuctionData public legendaryGobblerAuctionData;

    /*//////////////////////////////////////////////////////////////
                          GOBBLER REVEAL STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Struct holding data required for gobbler reveals.
    struct GobblerRevealsData {
        // Last random seed obtained from VRF.
        uint64 randomSeed;
        // Next reveal cannot happen before this timestamp.
        uint64 nextRevealTimestamp;
        // Id of latest gobbler which has been revealed so far.
        uint56 lastRevealedId;
        // Remaining gobblers to be revealed with the current seed.
        uint56 toBeRevealed;
        // Whether we are waiting to receive a seed from Chainlink.
        bool waitingForSeed;
    }

    /// @notice Data about the current state of gobbler reveals.
    GobblerRevealsData public gobblerRevealsData;

    /*//////////////////////////////////////////////////////////////
                             EMISSION STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Struct holding data required for goo emission calculations.
    struct EmissionData {
        // The sum of the multiples of all gobblers the user holds.
        uint64 emissionMultiple;
        // Balance at time of last deposit or withdrawal.
        uint128 lastBalance;
        // Timestamp of last deposit or withdrawal.
        uint64 lastTimestamp;
    }

    /// @notice Maps user addresses to their emission data.
    mapping(address => EmissionData) public getEmissionDataForUser;

    /*//////////////////////////////////////////////////////////////
                            ART FEEDING STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Maps gobbler ids to NFT contracts and their ids to the # of those NFT ids fed to the gobbler.
    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public getCopiesOfArtFedToGobbler;

    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event GooAdded(address indexed user, uint256 gooAdded);
    event GooRemoved(address indexed user, uint256 gooAdded);

    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);
    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);
    event LegendaryGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);
    event ReservedGobblersMinted(address indexed user, uint256 lastMintedGobblerId, uint256 numGobblersEach);

    event RandomnessRequested(address indexed user, uint256 toBeRevealed);
    event RandomnessFulfilled(uint256 randomness);

    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);

    event ArtFedToGobbler(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);

    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/

    error InvalidProof();
    error AlreadyClaimed();
    error MintStartPending();

    error SeedPending();
    error RevealsPending();
    error RequestTooEarly();
    error ZeroToBeRevealed();

    error ReserveImbalance();

    error OwnerMismatch(address owner);

    error NoRemainingLegendaryGobblers();
    error IncorrectGobblerAmount(uint256 cost);
    error CannotBurnLegendary(uint256 gobblerId);

    error PriceExceededMax(uint256 currentPrice);

    error NotEnoughRemainingToBeRevealed(uint256 totalRemainingToBeRevealed);

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(
        // Mint config:
        bytes32 _merkleRoot,
        uint256 _mintStart,
        // Addresses:
        Goo _goo,
        address _team,
        address _community,
        // Chainlink:
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _chainlinkKeyHash,
        uint256 _chainlinkFee,
        // URIs:
        string memory _baseUri,
        string memory _unrevealedUri
    )
        VRGDA(
            69.42e18, // Initial price.
            0.31e18 // Per period price decrease.
        )
        LogisticVRGDA(
            // Max mintable gobblers.
            int256(MAX_MINTABLE * 1e18),
            0.0023e18 // Time scale.
        )
        VRFConsumerBase(_vrfCoordinator, _linkToken)
        Owned(msg.sender) // Deployer starts as owner.
    {
        mintStart = _mintStart;
        merkleRoot = _merkleRoot;

        goo = _goo;
        team = _team;
        community = _community;

        chainlinkKeyHash = _chainlinkKeyHash;
        chainlinkFee = _chainlinkFee;

        BASE_URI = _baseUri;
        UNREVEALED_URI = _unrevealedUri;

        // Starting price for legendary gobblers is 69 gobblers.
        legendaryGobblerAuctionData.startPrice = 69;

        // Reveal for initial mint must wait 24 hours
        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);
    }

    /*//////////////////////////////////////////////////////////////
                          MINTLIST CLAIM LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Claim from mintlist, using a merkle proof.
    /// @param proof Merkle proof to verify the sender is mintlisted.
    /// @return gobblerId The id of the gobbler that was claimed.
    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {
        // If minting has not yet begun, revert.
        if (mintStart > block.timestamp) revert MintStartPending();

        // If the user has already claimed, revert.
        if (hasClaimedMintlistGobbler[msg.sender]) revert AlreadyClaimed();

        // If the user's proof is invalid, revert.
        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert InvalidProof();

        hasClaimedMintlistGobbler[msg.sender] = true; // Before mint to prevent reentrancy.

        unchecked {
            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLegendaryId);

            _mint(msg.sender, gobblerId, "");
        }
    }

    /*//////////////////////////////////////////////////////////////
                              MINTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a gobbler with goo, burning the cost.
    /// @param maxPrice Maximum price to pay to mint the gobbler.
    /// @return gobblerId The id of the gobbler that was minted.
    function mintFromGoo(uint256 maxPrice) external returns (uint256 gobblerId) {
        // No need to check mint cap, gobblerPrice()
        // will revert due to overflow if we reach it.
        // It will also revert prior to the mint start.
        uint256 currentPrice = gobblerPrice();

        // If the current price is above the user's specified max, revert.
        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);

        goo.burnForGobblers(msg.sender, currentPrice);

        unchecked {
            ++numMintedFromGoo; // Before mint to prevent reentrancy.

            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLegendaryId, currentPrice);

            _mint(msg.sender, gobblerId, "");
        }
    }

    /// @notice Gobbler pricing in terms of goo.
    /// @dev Will revert if called before minting starts
    /// or after all gobblers have been minted via VRGDA.
    function gobblerPrice() public view returns (uint256) {
        // We need checked math here to cause overflow
        // before minting has begun, preventing mints.
        uint256 timeSinceStart = block.timestamp - mintStart;

        return getPrice(timeSinceStart, numMintedFromGoo);
    }

    /*//////////////////////////////////////////////////////////////
                     LEGENDARY GOBBLER AUCTION LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a legendary gobbler by burning multiple standard gobblers.
    /// @param gobblerIds The ids of the standard gobblers to burn.
    /// @return gobblerId The id of the legendary gobbler that was minted.
    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {
        gobblerId = FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold; // Assign id.

        // If the gobbler id would be greater than the max supply, there are no remaining legendaries.
        if (gobblerId > MAX_SUPPLY) revert NoRemainingLegendaryGobblers();

        // This will revert if the auction hasn't started yet, no need to check here as well.
        uint256 cost = legendaryGobblerPrice();

        if (gobblerIds.length != cost) revert IncorrectGobblerAmount(cost);

        // Overflow should not occur in here, as most math is on emission multiples, which are inherently small.
        unchecked {
            uint256 burnedMultipleTotal; // The legendary's emissionMultiple will be 2x the sum of the gobblers burned.

            /*//////////////////////////////////////////////////////////////
                                    BATCH BURN LOGIC
            //////////////////////////////////////////////////////////////*/

            // Generate an amounts array locally to use in the event below.
            uint256[] memory amounts = new uint256[](gobblerIds.length);

            uint256 id; // Storing outside the loop saves ~7 gas per iteration.

            for (uint256 i = 0; i < gobblerIds.length; ++i) {
                id = gobblerIds[i];

                if (id >= FIRST_LEGENDARY_GOBBLER_ID) revert CannotBurnLegendary(id);

                require(getGobblerData[id].owner == msg.sender, "WRONG_FROM");

                burnedMultipleTotal += getGobblerData[id].emissionMultiple;

                getGobblerData[id].owner = address(0);

                amounts[i] = 1;
            }

            emit TransferBatch(msg.sender, msg.sender, address(0), gobblerIds, amounts);

            /*//////////////////////////////////////////////////////////////
                                 LEGENDARY MINTING LOGIC
            //////////////////////////////////////////////////////////////*/

            // The shift right by 1 is equivalent to multiplication by 2, used to make
            // the legendary's emissionMultiple 2x the sum of the multiples of the gobblers burned.
            // Must be done before minting as the transfer hook will update the user's emissionMultiple.
            getGobblerData[gobblerId].emissionMultiple = uint48(burnedMultipleTotal << 1);

            // Update the user's emission data in one big batch. We add burnedMultipleTotal to their
            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that
            // were burned and hence should have their multiples subtracted from the user's total multiple.
            getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender));
            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);
            getEmissionDataForUser[msg.sender].emissionMultiple += uint64(burnedMultipleTotal);

            // New start price is the max of 69 and cost * 2. Left shift by 1 is like multiplication by 2.
            legendaryGobblerAuctionData.startPrice = uint120(cost < 35 ? 69 : cost << 1);
            legendaryGobblerAuctionData.numSold += 1; // Increment the # of legendaries sold.

            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.
            emit LegendaryGobblerMinted(msg.sender, gobblerId, gobblerIds);

            _mint(msg.sender, gobblerId, "");
        }
    }

    /// @notice Calculate the legendary gobbler price in terms of gobblers, according to a linear decay function.
    /// @dev The price of a legendary gobbler decays as gobblers are minted. The first legendary auction begins when
    /// 1 LEGENDARY_AUCTION_INTERVAL worth of gobblers are minted, and the price decays linearly while the next interval of
    /// gobblers is minted. Every time an additional interval is minted, a new auction begins until all legendaries been sold.
    function legendaryGobblerPrice() public view returns (uint256) {
        // Retrieve and cache the auction's startPrice and numSold on the stack.
        uint256 startPrice = legendaryGobblerAuctionData.startPrice;
        uint256 numSold = legendaryGobblerAuctionData.numSold;

        uint256 numMintedAtStart; // The number of gobblers minted at the start of the auction.

        unchecked {
            // The number of gobblers minted at the start of the auction is computed by multiplying the # of
            // intervals that must pass before the next auction begins by the number of gobblers in each interval.
            numMintedAtStart = (numSold + 1) * LEGENDARY_AUCTION_INTERVAL;
        }

        // How many gobblers where minted since auction began. Cannot be
        // unchecked, we want this to revert if auction has not yet started.
        uint256 numMintedSinceStart = numMintedFromGoo - numMintedAtStart;

        unchecked {
            // If we've minted the full interval or beyond it, the price has decayed to 0.
            if (numMintedSinceStart >= LEGENDARY_AUCTION_INTERVAL) return 0;
            // Otherwise decay the price linearly based on what fraction of the interval has been minted.
            else return (startPrice * (LEGENDARY_AUCTION_INTERVAL - numMintedSinceStart)) / LEGENDARY_AUCTION_INTERVAL;
        }
    }

    /*//////////////////////////////////////////////////////////////
                                VRF LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Request a new random seed for revealing gobblers.
    /// @dev Can only be called every 24 hours at the earliest.
    function requestRandomSeed() external returns (bytes32) {
        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;

        // A new random seed cannot be requested before the next reveal timestamp.
        if (block.timestamp < nextRevealTimestamp) revert RequestTooEarly();

        // A random seed can only be requested when all gobblers from the previous seed have been revealed.
        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.
        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();

        unchecked {
            // Prevent revealing while we wait for the seed.
            gobblerRevealsData.waitingForSeed = true;

            // Compute the number of gobblers to be revealed with the seed.
            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;

            // Ensure that there are more than 0 gobblers to be revealed,
            // otherwise the contract could waste LINK revealing nothing.
            if (toBeRevealed == 0) revert ZeroToBeRevealed();

            // Lock in the number of gobblers to be revealed from seed.
            gobblerRevealsData.toBeRevealed = uint56(toBeRevealed);

            // We want at most one batch of reveals every 24 hours.
            // Timestamp overflow is impossible on human timescales.
            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);

            emit RandomnessRequested(msg.sender, toBeRevealed);
        }

        // Will revert if we don't have enough LINK to afford the request.
        return requestRandomness(chainlinkKeyHash, chainlinkFee);
    }

    /// @notice Callback from Chainlink VRF. Sets randomSeed.
    function fulfillRandomness(bytes32, uint256 randomness) internal override {
        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.
        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.

        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.

        emit RandomnessFulfilled(randomness);
    }

    /*//////////////////////////////////////////////////////////////
                          GOBBLER REVEAL LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Knuth shuffle to progressively reveal gobblers using entropy from random seed.
    /// @param numGobblers The number of gobblers to reveal.
    function revealGobblers(uint256 numGobblers) external {
        uint256 randomSeed = gobblerRevealsData.randomSeed;

        uint256 lastRevealedId = gobblerRevealsData.lastRevealedId;

        uint256 totalRemainingToBeRevealed = gobblerRevealsData.toBeRevealed;

        // Can't reveal if we're still waiting for a new seed.
        if (gobblerRevealsData.waitingForSeed) revert SeedPending();

        // Can't reveal more gobblers than are currently remaining to be revealed with the seed.
        if (numGobblers > totalRemainingToBeRevealed) revert NotEnoughRemainingToBeRevealed(totalRemainingToBeRevealed);

        // Implements a Knuth shuffle. If something in
        // here can overflow we've got bigger problems.
        unchecked {
            for (uint256 i = 0; i < numGobblers; ++i) {
                /*//////////////////////////////////////////////////////////////
                                      DETERMINE RANDOM SWAP
                //////////////////////////////////////////////////////////////*/

                // Number of ids that have not been revealed. Subtract 1
                // because we don't want to include any legendaries in the swap.
                uint256 remainingIds = FIRST_LEGENDARY_GOBBLER_ID - lastRevealedId - 1;

                // Randomly pick distance for swap.
                uint256 distance = randomSeed % remainingIds;

                // Current id is consecutive to last reveal.
                uint256 currentId = ++lastRevealedId;

                // Select swap id, adding distance to next reveal id.
                uint256 swapId = currentId + distance;

                /*//////////////////////////////////////////////////////////////
                                       GET INDICES FOR IDS
                //////////////////////////////////////////////////////////////*/

                // Get the index of the swap id.
                uint48 swapIndex = getGobblerData[swapId].idx == 0
                    ? uint48(swapId) // Hasn't been shuffled before.
                    : getGobblerData[swapId].idx; // Shuffled before.

                // Get the owner of the current id.
                address currentIdOwner = getGobblerData[currentId].owner;

                // Get the index of the current id.
                uint48 currentIndex = getGobblerData[currentId].idx == 0
                    ? uint48(currentId) // Hasn't been shuffled before.
                    : getGobblerData[currentId].idx; // Shuffled before.

                /*//////////////////////////////////////////////////////////////
                                  SWAP INDICES AND SET MULTIPLE
                //////////////////////////////////////////////////////////////*/

                // Determine the current id's new emission multiple.
                uint256 newCurrentIdMultiple = 9; // For beyond 7963.

                // The branchless expression below is equivalent to:
                //      if (swapIndex <= 3054) newCurrentIdMultiple = 6;
                // else if (swapIndex <= 5672) newCurrentIdMultiple = 7;
                // else if (swapIndex <= 7963) newCurrentIdMultiple = 8;
                assembly {
                    // prettier-ignore
                    newCurrentIdMultiple := sub(sub(sub(
                        newCurrentIdMultiple,
                        lt(swapIndex, 7964)),
                        lt(swapIndex, 5673)),
                        lt(swapIndex, 3055)
                    )
                }

                // Swap the index and multiple of the current id.
                getGobblerData[currentId].idx = swapIndex;
                getGobblerData[currentId].emissionMultiple = uint48(newCurrentIdMultiple);

                // Swap the index of the swap id.
                getGobblerData[swapId].idx = currentIndex;

                /*//////////////////////////////////////////////////////////////
                                   UPDATE CURRENT ID MULTIPLE
                //////////////////////////////////////////////////////////////*/

                // Update the emission data for the owner of the current id.
                getEmissionDataForUser[currentIdOwner].lastBalance = uint128(gooBalance(currentIdOwner));
                getEmissionDataForUser[currentIdOwner].lastTimestamp = uint64(block.timestamp);
                getEmissionDataForUser[currentIdOwner].emissionMultiple += uint64(newCurrentIdMultiple);

                // Update the random seed to choose a new distance for the next iteration.
                // It is critical that we cast to uint64 here, as otherwise the random seed
                // set after calling revealGobblers(1) thrice would differ from the seed set
                // after calling revealGobblers(3) a single time. This would enable an attacker
                // to choose from a number of different seeds and use whichever is most favorable.
                // Equivalent to randomSeed = uint64(uint256(keccak256(abi.encodePacked(randomSeed))))
                assembly {
                    mstore(0, randomSeed) // Store the random seed in scratch space.

                    // Moduloing by 1 << 64 (2 ** 64) is equivalent to a uint64 cast.
                    randomSeed := mod(keccak256(0, 32), shl(64, 1))
                }
            }

            // Update all relevant reveal state state.
            gobblerRevealsData.randomSeed = uint64(randomSeed);
            gobblerRevealsData.lastRevealedId = uint56(lastRevealedId);
            gobblerRevealsData.toBeRevealed = uint56(totalRemainingToBeRevealed - numGobblers);

            emit GobblersRevealed(msg.sender, numGobblers, lastRevealedId);
        }
    }

    /*//////////////////////////////////////////////////////////////
                                URI LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Returns a token's URI if it has been minted.
    /// @param gobblerId The id of the token to get the URI for.
    function uri(uint256 gobblerId) public view virtual override returns (string memory) {
        // Between 0 and lastRevealed are revealed normal gobblers.
        if (gobblerId <= gobblerRevealsData.lastRevealedId) {
            // 0 is not a valid id:
            if (gobblerId == 0) return "";

            return string(abi.encodePacked(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString()));
        }

        // Between lastRevealed + 1 and currentNonLegendaryId are minted but not revealed.
        if (gobblerId <= currentNonLegendaryId) return UNREVEALED_URI;

        // Between currentNonLegendaryId and FIRST_LEGENDARY_GOBBLER_ID are unminted.
        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID) return "";

        // Between FIRST_LEGENDARY_GOBBLER_ID and FIRST_LEGENDARY_GOBBLER_ID + numSold are minted legendaries.
        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold)
            return string(abi.encodePacked(BASE_URI, gobblerId.toString()));

        return ""; // Unminted legendaries and invalid token ids.
    }

    /*//////////////////////////////////////////////////////////////
                            ART FEEDING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Feed a gobbler a work of art.
    /// @param gobblerId The gobbler to feed the work of art.
    /// @param nft The ERC721 or ERC1155 contract of the work of art.
    /// @param id The id of the work of art.
    /// @param isERC1155 Whether the work of art is an ERC1155 token.
    function feedArt(
        uint256 gobblerId,
        address nft,
        uint256 id,
        bool isERC1155
    ) external {
        // Get the owner of the gobbler to feed.
        address owner = getGobblerData[gobblerId].owner;

        // The caller must own the gobbler they're feeding.
        if (owner != msg.sender) revert OwnerMismatch(owner);

        unchecked {
            // Increment the number of copies fed to the gobbler.
            // Counter overflow is unrealistic on human timescales.
            ++getCopiesOfArtFedToGobbler[gobblerId][nft][id];
        }

        emit ArtFedToGobbler(msg.sender, gobblerId, nft, id);

        isERC1155
            ? ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, "")
            : ERC721(nft).transferFrom(msg.sender, address(this), id);
    }

    /*//////////////////////////////////////////////////////////////
                             EMISSION LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Calculate a user's staked goo balance.
    /// @param user The user to query balance for.
    function gooBalance(address user) public view returns (uint256) {
        // If a user's goo balance is greater than
        // 2**256 - 1 we've got much bigger problems.
        unchecked {
            uint256 emissionMultiple = getEmissionDataForUser[user].emissionMultiple;
            uint256 lastBalanceWad = getEmissionDataForUser[user].lastBalance;

            // Stored with 18 decimals, such that if a day and a half elapsed this variable would equal 1.5e18.
            uint256 daysElapsedWad = ((block.timestamp - getEmissionDataForUser[user].lastTimestamp) * 1e18) / 1 days;

            uint256 daysElapsedSquaredWad = daysElapsedWad.mulWadDown(daysElapsedWad); // Need to use wad math here.

            // prettier-ignore
            return lastBalanceWad + // The last recorded balance.

            // Don't need to do wad multiplication since we're
            // multiplying by a plain integer with no decimals.
            // Shift right by 2 is equivalent to division by 4.
            ((emissionMultiple * daysElapsedSquaredWad) >> 2) +

            daysElapsedWad.mulWadDown( // Terms are wads, so must mulWad.
                // No wad multiplication for emissionMultiple * lastBalance
                // because emissionMultiple is a plain integer with no decimals.
                // We multiply the sqrt's radicand by 1e18 because it expects ints.
                (emissionMultiple * lastBalanceWad * 1e18).sqrt()
            );
        }
    }

    /// @notice Add goo to your emission balance.
    /// @param gooAmount The amount of goo to add.
    function addGoo(uint256 gooAmount) external {
        // Burn goo being added to gobbler.
        goo.burnForGobblers(msg.sender, gooAmount);

        unchecked {
            // If a user has enough goo to overflow their balance we've got big problems.
            getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender) + gooAmount);
            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);
        }

        emit GooAdded(msg.sender, gooAmount);
    }

    /// @notice Remove goo from your emission balance.
    /// @param gooAmount The amount of goo to remove.
    function removeGoo(uint256 gooAmount) external {
        // Will revert due to underflow if removed amount is larger than the user's current goo balance.
        getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender) - gooAmount);
        getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);

        goo.mintForGobblers(msg.sender, gooAmount);

        emit GooRemoved(msg.sender, gooAmount);
    }

    /*//////////////////////////////////////////////////////////////
                     RESERVED GOBBLERS MINTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a number of gobblers to the reserves.
    /// @param numGobblersEach The number of gobblers to mint to each reserve.
    /// @dev Gobblers minted to reserves cannot compromise more than 20% of the sum of
    /// the supply of goo minted gobblers and the supply of gobblers minted to reserves.
    function mintReservedGobblers(uint256 numGobblersEach) external returns (uint256 lastMintedGobblerId) {
        unchecked {
            // Optimistically increment numMintedForReserves, may be reverted below. Overflow in this
            // calculation is possible but numGobblersEach would have to be so large that it would cause the
            // loop in _batchMint to run out of gas quickly. Shift left by 1 is equivalent to multiplying by 2.
            uint256 newNumMintedForReserves = numMintedForReserves += (numGobblersEach << 1);

            // Ensure that after this mint gobblers minted to reserves won't compromise more than 20% of
            // the sum of the supply of goo minted gobblers and the supply of gobblers minted to reserves.
            if (newNumMintedForReserves > (numMintedFromGoo + newNumMintedForReserves) / 5) revert ReserveImbalance();
        }

        // Mint numGobblersEach gobblers to both the team and community reserve.
        lastMintedGobblerId = _batchMint(team, numGobblersEach, currentNonLegendaryId, "");
        lastMintedGobblerId = _batchMint(community, numGobblersEach, lastMintedGobblerId, "");

        // Note: There is reentrancy here. The _batchMint calls above can enable an
        // adversary to reenter before currentNonLegendaryId is updated, but since we
        // assume the reserves are both trusted addresses, we can safely ignore this risk.
        currentNonLegendaryId = uint128(lastMintedGobblerId); // Set currentNonLegendaryId.

        emit ReservedGobblersMinted(msg.sender, lastMintedGobblerId, numGobblersEach);
    }

    /*//////////////////////////////////////////////////////////////
                          CONVENIENCE FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /// @notice Convenience function to get emission emissionMultiple for a gobbler.
    /// @param gobblerId The gobbler to get emissionMultiple for.
    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {
        return getGobblerData[gobblerId].emissionMultiple;
    }

    /// @notice Convenience function to get emission emissionMultiple for a user.
    /// @param user The user to get emissionMultiple for.
    function getUserEmissionMultiple(address user) external view returns (uint256) {
        return getEmissionDataForUser[user].emissionMultiple;
    }

    /*//////////////////////////////////////////////////////////////
                             ERC1155B LOGIC
    //////////////////////////////////////////////////////////////*/

    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) public override {
        require(ids.length == amounts.length, "LENGTH_MISMATCH");

        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");

        // Storing these outside the loop saves ~15 gas per iteration.
        uint256 id;
        uint256 amount;

        unchecked {
            uint64 emissionsMultipleTotal; // Will use to set each user's multiple.

            for (uint256 i = 0; i < ids.length; i++) {
                id = ids[i];
                amount = amounts[i];

                // Can only transfer from the owner.
                require(from == getGobblerData[id].owner, "WRONG_FROM");

                // Can only transfer 1 with ERC1155B.
                require(amount == 1, "INVALID_AMOUNT");

                getGobblerData[id].owner = to;

                emissionsMultipleTotal += getGobblerData[id].emissionMultiple;
            }

            transferUserEmissionMultiple(from, to, emissionsMultipleTotal);
        }

        emit TransferBatch(msg.sender, from, to, ids, amounts);

        if (to.code.length != 0) {
            require(
                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==
                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,
                "UNSAFE_RECIPIENT"
            );
        } else require(to != address(0), "INVALID_RECIPIENT");
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) public override {
        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");

        require(from == getGobblerData[id].owner, "WRONG_FROM"); // Can only transfer from the owner.

        // Can only transfer 1 with ERC1155B.
        require(amount == 1, "INVALID_AMOUNT");

        getGobblerData[id].owner = to;

        transferUserEmissionMultiple(from, to, getGobblerData[id].emissionMultiple);

        emit TransferSingle(msg.sender, from, to, id, amount);

        if (to.code.length != 0) {
            require(
                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==
                    ERC1155TokenReceiver.onERC1155Received.selector,
                "UNSAFE_RECIPIENT"
            );
        } else require(to != address(0), "INVALID_RECIPIENT");
    }

    /*//////////////////////////////////////////////////////////////
                              HELPER LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @dev Transfer an amount of a user's emission's multiple to another user.
    /// @dev Should be done whenever a gobbler is transferred between two users.
    /// @param from The user to transfer the amount of emission multiple from.
    /// @param to The user to transfer the amount of emission multiple to.
    /// @param emissionMultiple The amount of emission multiple to transfer.
    function transferUserEmissionMultiple(
        address from,
        address to,
        uint64 emissionMultiple
    ) internal {
        unchecked {
            // Decrease the from user's emissionMultiple by the gobbler's emissionMultiple.
            getEmissionDataForUser[from].lastBalance = uint128(gooBalance(from));
            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);
            getEmissionDataForUser[from].emissionMultiple -= emissionMultiple;

            // Increase the to user's emissionMultiple by the gobbler's emissionMultiple.
            getEmissionDataForUser[to].lastBalance = uint128(gooBalance(to));
            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);
            getEmissionDataForUser[to].emissionMultiple += emissionMultiple;
        }
    }
}


================================================
File: /src/utils/GobblerReserve.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {Owned} from "solmate/auth/Owned.sol";
import {ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";

import {ArtGobblers} from "../ArtGobblers.sol";

/// @title Gobbler Reserve
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Reserves gobblers for an owner while keeping any goo produced.
contract GobblerReserve is Owned, ERC1155TokenReceiver {
    /*//////////////////////////////////////////////////////////////
                                ADDRESSES
    //////////////////////////////////////////////////////////////*/
    ArtGobblers public artGobblers;

    constructor(ArtGobblers _artGobblers, address _owner) Owned(_owner) {
        artGobblers = _artGobblers;
    }

    /*//////////////////////////////////////////////////////////////
                            WITHDRAWAL LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Withdraw gobblers from the reserve.
    /// @param to The address to transfer the gobblers to.
    /// @param ids The ids of the gobblers to transfer.
    function withdraw(address to, uint256[] calldata ids) public onlyOwner {
        unchecked {
            // Generating this in memory is pretty expensive
            // but this is not a hot path so we can afford it.
            uint256[] memory amounts = new uint256[](ids.length);
            for (uint256 i = 0; i < ids.length; i++) amounts[i] = 1;

            artGobblers.safeBatchTransferFrom(address(this), to, ids, amounts, "");
        }
    }
}


================================================
File: /src/utils/lib/SignedWadMath.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/// @title Signed Wad Math
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Efficient signed wad arithmetic.

/// @dev Will not revert on overflow, only use where overflow is not possible.
function toWadUnsafe(uint256 x) pure returns (int256 r) {
    assembly {
        // Multiply x by 1e18.
        r := mul(x, 1000000000000000000)
    }
}

/// @dev Will not revert on overflow, only use where overflow is not possible.
function unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {
    assembly {
        // Multiply x by y and divide by 1e18.
        r := sdiv(mul(x, y), 1000000000000000000)
    }
}

/// @dev Will return 0 instead of reverting if y is zero and will
/// not revert on overflow, only use where overflow is not possible.
function unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {
    assembly {
        // Multiply x by 1e18 and divide it by y.
        r := sdiv(mul(x, 1000000000000000000), y)
    }
}

function wadMul(int256 x, int256 y) pure returns (int256 r) {
    assembly {
        // Store x * y in r for now.
        r := mul(x, y)

        // Equivalent to require(x == 0 || (x * y) / x == y)
        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {
            revert(0, 0)
        }

        // Scale the result down by 1e18.
        r := sdiv(r, 1000000000000000000)
    }
}

function wadDiv(int256 x, int256 y) pure returns (int256 r) {
    assembly {
        // Store x * 1e18 in r for now.
        r := mul(x, 1000000000000000000)

        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))
        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {
            revert(0, 0)
        }

        // Divide r by y.
        r := sdiv(r, y)
    }
}

function wadExp(int256 x) pure returns (int256 r) {
    unchecked {
        // When the result is < 0.5 we return zero. This happens when
        // x <= floor(log(0.5e18) * 1e18) ~ -42e18
        if (x <= -42139678854452767551) return 0;

        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an
        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.
        if (x >= 135305999368893231589) revert("EXP_OVERFLOW");

        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96
        // for more intermediate precision and a binary basis. This base conversion
        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.
        x = (x << 78) / 5**18;

        // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers
        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.
        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).
        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;
        x = x - k * 54916777467707473351141471128;

        // k is in the range [-61, 195].

        // Evaluate using a (6, 7)-term rational approximation.
        // p is made monic, we'll multiply by a scale factor later.
        int256 y = x + 1346386616545796478920950773328;
        y = ((y * x) >> 96) + 57155421227552351082224309758442;
        int256 p = y + x - 94201549194550492254356042504812;
        p = ((p * y) >> 96) + 28719021644029726153956944680412240;
        p = p * x + (4385272521454847904659076985693276 << 96);

        // We leave p in 2**192 basis so we don't need to scale it back up for the division.
        int256 q = x - 2855989394907223263936484059900;
        q = ((q * x) >> 96) + 50020603652535783019961831881945;
        q = ((q * x) >> 96) - 533845033583426703283633433725380;
        q = ((q * x) >> 96) + 3604857256930695427073651918091429;
        q = ((q * x) >> 96) - 14423608567350463180887372962807573;
        q = ((q * x) >> 96) + 26449188498355588339934803723976023;

        assembly {
            // Div in assembly because solidity adds a zero check despite the unchecked.
            // The q polynomial won't have zeros in the domain as all its roots are complex.
            // No scaling is necessary because p is already 2**96 too large.
            r := sdiv(p, q)
        }

        // r should be in the range (0.09, 0.25) * 2**96.

        // We now need to multiply r by:
        // * the scale factor s = ~6.031367120.
        // * the 2**k factor from the range reduction.
        // * the 1e18 / 2**96 factor for base conversion.
        // We do this all at once, with an intermediate result in 2**213
        // basis, so the final right shift is always by a positive amount.
        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));
    }
}

function wadLn(int256 x) pure returns (int256 r) {
    unchecked {
        require(x > 0, "UNDEFINED");

        // We want to convert x from 10**18 fixed point to 2**96 fixed point.
        // We do this by multiplying by 2**96 / 10**18. But since
        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here
        // and add ln(2**96 / 10**18) at the end.

        assembly {
            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
            r := or(r, shl(4, lt(0xffff, shr(r, x))))
            r := or(r, shl(3, lt(0xff, shr(r, x))))
            r := or(r, shl(2, lt(0xf, shr(r, x))))
            r := or(r, shl(1, lt(0x3, shr(r, x))))
            r := or(r, lt(0x1, shr(r, x)))
        }

        // Reduce range of x to (1, 2) * 2**96
        // ln(2^k * x) = k * ln(2) + ln(x)
        int256 k = r - 96;
        x <<= uint256(159 - k);
        x = int256(uint256(x) >> 159);

        // Evaluate using a (8, 8)-term rational approximation.
        // p is made monic, we will multiply by a scale factor later.
        int256 p = x + 3273285459638523848632254066296;
        p = ((p * x) >> 96) + 24828157081833163892658089445524;
        p = ((p * x) >> 96) + 43456485725739037958740375743393;
        p = ((p * x) >> 96) - 11111509109440967052023855526967;
        p = ((p * x) >> 96) - 45023709667254063763336534515857;
        p = ((p * x) >> 96) - 14706773417378608786704636184526;
        p = p * x - (795164235651350426258249787498 << 96);

        // We leave p in 2**192 basis so we don't need to scale it back up for the division.
        // q is monic by convention.
        int256 q = x + 5573035233440673466300451813936;
        q = ((q * x) >> 96) + 71694874799317883764090561454958;
        q = ((q * x) >> 96) + 283447036172924575727196451306956;
        q = ((q * x) >> 96) + 401686690394027663651624208769553;
        q = ((q * x) >> 96) + 204048457590392012362485061816622;
        q = ((q * x) >> 96) + 31853899698501571402653359427138;
        q = ((q * x) >> 96) + 909429971244387300277376558375;
        assembly {
            // Div in assembly because solidity adds a zero check despite the unchecked.
            // The q polynomial is known not to have zeros in the domain.
            // No scaling required because p is already 2**96 too large.
            r := sdiv(p, q)
        }

        // r is in the range (0, 0.125) * 2**96

        // Finalization, we need to:
        // * multiply by the scale factor s = 5.549…
        // * add ln(2**96 / 10**18)
        // * add k * ln(2)
        // * multiply by 10**18 / 2**96 = 5**18 >> 78

        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192
        r *= 1677202110996718588342820967067443963516166;
        // add ln(2) * k * 5e18 * 2**192
        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;
        // add ln(2**96 / 10**18) * 5e18 * 2**192
        r += 600920179829731861736702779321621459595472258049074101567377883020018308;
        // base conversion: mul 2**18 / 2**192
        r >>= 174;
    }
}

/// @dev Will return 0 instead of reverting if y is zero.
function unsafeDiv(int256 x, int256 y) pure returns (int256 r) {
    assembly {
        // Divide x by y.
        r := sdiv(x, y)
    }
}


================================================
File: /src/utils/lib/MerkleProofLib.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/// @notice Gas optimized merkle proof verification library.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/MerkleProofLib.sol)
library MerkleProofLib {
    function verify(
        bytes32[] calldata proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool isValid) {
        assembly {
            let computedHash := leaf // The hash starts as the leaf hash.

            // Initialize data to the offset of the proof in the calldata.
            let data := proof.offset

            // Iterate over proof elements to compute root hash.
            for {
                // Left shifting by 5 is like multiplying by 32.
                let end := add(data, shl(5, proof.length))
            } lt(data, end) {
                data := add(data, 32) // Shift 1 word per cycle.
            } {
                // Load the current proof element.
                let loadedData := calldataload(data)

                // Slot where computedHash should be put in scratch space.
                // If computedHash > loadedData: slot 32, otherwise: slot 0.
                let computedHashSlot := shl(5, gt(computedHash, loadedData))

                // Store elements to hash contiguously in scratch space.
                // The xor puts loadedData in whichever slot computedHash is
                // not occupying, so 0 if computedHashSlot is 32, 32 otherwise.
                mstore(computedHashSlot, computedHash)
                mstore(xor(computedHashSlot, 32), loadedData)

                computedHash := keccak256(0, 64) // Hash both slots of scratch space.
            }

            isValid := eq(computedHash, root) // The proof is valid if the roots match.
        }
    }
}


================================================
File: /src/utils/lib/LibString.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/// @notice Efficient library for creating string representations of integers.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)
library LibString {
    function toString(uint256 n) internal pure returns (string memory str) {
        if (n == 0) return "0"; // Otherwise it'd output an empty string for 0.

        assembly {
            let k := 78 // Start with the max length a uint256 string could be.

            // We'll store our string at the first chunk of free memory.
            str := mload(0x40)

            // The length of our string will start off at the max of 78.
            mstore(str, k)

            // Update the free memory pointer to prevent overriding our string.
            // Add 128 to the str pointer instead of 78 because we want to maintain
            // the Solidity convention of keeping the free memory pointer word aligned.
            mstore(0x40, add(str, 128))

            // We'll populate the string from right to left.
            // prettier-ignore
            for {} n {} {
                // The ASCII digit offset for '0' is 48.
                let char := add(48, mod(n, 10))

                // Write the current character into str.
                mstore(add(str, k), char)

                k := sub(k, 1)
                n := div(n, 10)
            }

            // Shift the pointer to the start of the string.
            str := add(str, k)

            // Set the length of the string to the correct value.
            mstore(str, sub(78, k))
        }
    }
}


================================================
File: /src/utils/token/PagesERC721.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {ERC721TokenReceiver} from "solmate/tokens/ERC721.sol";

/// @notice ERC721 implementation optimized for Pages by pre-approving them to the ArtGobblers contract.
/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)
abstract contract PagesERC721 {
    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event Transfer(address indexed from, address indexed to, uint256 indexed id);

    event Approval(address indexed owner, address indexed spender, uint256 indexed id);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /*//////////////////////////////////////////////////////////////
                         METADATA STORAGE/LOGIC
    //////////////////////////////////////////////////////////////*/

    string public name;

    string public symbol;

    function tokenURI(uint256 id) public view virtual returns (string memory);

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    address public immutable artGobblers;

    constructor(
        address _artGobblers,
        string memory _name,
        string memory _symbol
    ) {
        name = _name;
        symbol = _symbol;
        artGobblers = _artGobblers;
    }

    /*//////////////////////////////////////////////////////////////
                      ERC721 BALANCE/OWNER STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(uint256 => address) internal _ownerOf;

    mapping(address => uint256) internal _balanceOf;

    function ownerOf(uint256 id) public view virtual returns (address owner) {
        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");
    }

    function balanceOf(address owner) public view virtual returns (uint256) {
        require(owner != address(0), "ZERO_ADDRESS");

        return _balanceOf[owner];
    }

    /*//////////////////////////////////////////////////////////////
                         ERC721 APPROVAL STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(uint256 => address) public getApproved;

    mapping(address => mapping(address => bool)) internal _isApprovedForAll;

    function isApprovedForAll(address owner, address operator) public view virtual returns (bool isApproved) {
        if (operator == artGobblers) return true; // Skip approvals for the ArtGobblers contract.

        return _isApprovedForAll[owner][operator];
    }

    /*//////////////////////////////////////////////////////////////
                              ERC721 LOGIC
    //////////////////////////////////////////////////////////////*/

    function approve(address spender, uint256 id) public virtual {
        address owner = _ownerOf[id];

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "NOT_AUTHORIZED");

        getApproved[id] = spender;

        emit Approval(owner, spender, id);
    }

    function setApprovalForAll(address operator, bool approved) public virtual {
        _isApprovedForAll[msg.sender][operator] = approved;

        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function transferFrom(
        address from,
        address to,
        uint256 id
    ) public virtual {
        require(from == _ownerOf[id], "WRONG_FROM");

        require(to != address(0), "INVALID_RECIPIENT");

        require(
            msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved[id],
            "NOT_AUTHORIZED"
        );

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        unchecked {
            _balanceOf[from]--;

            _balanceOf[to]++;
        }

        _ownerOf[id] = to;

        delete getApproved[id];

        emit Transfer(from, to, id);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id
    ) public virtual {
        transferFrom(from, to, id);

        if (to.code.length != 0)
            require(
                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==
                    ERC721TokenReceiver.onERC721Received.selector,
                "UNSAFE_RECIPIENT"
            );
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        bytes calldata data
    ) public virtual {
        transferFrom(from, to, id);

        if (to.code.length != 0)
            require(
                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==
                    ERC721TokenReceiver.onERC721Received.selector,
                "UNSAFE_RECIPIENT"
            );
    }

    /*//////////////////////////////////////////////////////////////
                              ERC165 LOGIC
    //////////////////////////////////////////////////////////////*/

    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return
            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165
            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721
            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL MINT/BURN LOGIC
    //////////////////////////////////////////////////////////////*/

    function _mint(address to, uint256 id) internal virtual {
        // Does not check the token has not been already minted
        // or is being minted to address(0) because ids in Pages.sol
        // are set using a monotonically increasing counter and only
        // minted to safe addresses or msg.sender who cannot be zero.

        // Counter overflow is incredibly unrealistic.
        unchecked {
            _balanceOf[to]++;
        }

        _ownerOf[id] = to;

        emit Transfer(address(0), to, id);
    }
}


================================================
File: /src/utils/token/GobblersERC1155B.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";

/// @notice ERC1155B implementation optimized for ArtGobblers by using the ownerOf storage slot to store attribute data.
/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/tokens/ERC1155B.sol)
abstract contract GobblersERC1155B {
    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event TransferSingle(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 id,
        uint256 amount
    );

    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] amounts
    );

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    event URI(string value, uint256 indexed id);

    /*//////////////////////////////////////////////////////////////
                             ERC1155 STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(address => mapping(address => bool)) public isApprovedForAll;

    /*//////////////////////////////////////////////////////////////
                        GOBBLERS/ERC1155B STORAGE
    //////////////////////////////////////////////////////////////*/

    /// @notice Struct holding gobbler data.
    struct GobblerData {
        // The current owner of the gobbler.
        address owner;
        // Index of token after shuffle.
        uint48 idx;
        // Multiple on goo issuance.
        uint48 emissionMultiple;
    }

    mapping(uint256 => GobblerData) public getGobblerData;

    function ownerOf(uint256 id) public view virtual returns (address owner) {
        return getGobblerData[id].owner;
    }

    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 bal) {
        address idOwner = getGobblerData[id].owner;

        assembly {
            // We avoid branching by using assembly to take
            // the bool output of eq() and use it as a uint.
            bal := eq(idOwner, owner)
        }
    }

    /*//////////////////////////////////////////////////////////////
                             METADATA LOGIC
    //////////////////////////////////////////////////////////////*/

    function uri(uint256 id) public view virtual returns (string memory);

    /*//////////////////////////////////////////////////////////////
                              ERC1155 LOGIC
    //////////////////////////////////////////////////////////////*/

    function setApprovalForAll(address operator, bool approved) public virtual {
        isApprovedForAll[msg.sender][operator] = approved;

        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) public virtual;

    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) public virtual;

    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)
        public
        view
        virtual
        returns (uint256[] memory balances)
    {
        require(owners.length == ids.length, "LENGTH_MISMATCH");

        balances = new uint256[](owners.length);

        // Unchecked because the only math done is incrementing
        // the array index counter which cannot possibly overflow.
        unchecked {
            for (uint256 i = 0; i < owners.length; ++i) {
                balances[i] = balanceOf(owners[i], ids[i]);
            }
        }
    }

    /*//////////////////////////////////////////////////////////////
                           INTERNAL MINT LOGIC
    //////////////////////////////////////////////////////////////*/

    function _mint(
        address to,
        uint256 id,
        bytes memory data
    ) internal virtual {
        getGobblerData[id].owner = to;

        // Does not check if the token was already minted because new ids in
        // ArtGobblers.sol are set using a monotonically increasing counter.

        emit TransferSingle(msg.sender, address(0), to, id, 1);

        if (to.code.length != 0) {
            require(
                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, 1, data) ==
                    ERC1155TokenReceiver.onERC1155Received.selector,
                "UNSAFE_RECIPIENT"
            );
        } else require(to != address(0), "INVALID_RECIPIENT");
    }

    function _batchMint(
        address to,
        uint256 amount,
        uint256 lastMintedId,
        bytes memory data
    ) internal returns (uint256) {
        // Allocate arrays before entering the loop.
        uint256[] memory ids = new uint256[](amount);
        uint256[] memory amounts = new uint256[](amount);

        // Counter overflow is unrealistic on human timescales.
        unchecked {
            for (uint256 i = 0; i < amount; ++i) {
                ids[i] = ++lastMintedId; // Increment id while setting.

                amounts[i] = 1; // ERC1155B amounts are always 1.

                getGobblerData[lastMintedId].owner = to;
            }
        }

        emit TransferBatch(msg.sender, address(0), to, ids, amounts);

        if (to.code.length != 0) {
            require(
                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==
                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,
                "UNSAFE_RECIPIENT"
            );
        } else require(to != address(0), "INVALID_RECIPIENT");

        return lastMintedId; // Return the new last minted id.
    }
}


================================================
File: /src/utils/vrgda/PostSwitchVRGDA.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {unsafeWadDiv} from "../lib/SignedWadMath.sol";

import {VRGDA} from "./VRGDA.sol";

/// @title "Post Switch" Variable Rate Gradual Dutch Auction
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Abstract VRGDA with a (translated) linear issuance curve.
abstract contract PostSwitchVRGDA is VRGDA {
    /*//////////////////////////////////////////////////////////////
                           PRICING PARAMETERS
    //////////////////////////////////////////////////////////////*/

    /// @dev The number of tokens sold at the time of the switch.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable soldBySwitch;

    /// @dev The day soldBySwitch tokens were targeted to sell by.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable switchDay;

    /// @dev The total number of tokens to target selling each day.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable perDay;

    constructor(
        int256 _soldBySwitch,
        int256 _switchDay,
        int256 _perDay
    ) {
        soldBySwitch = _soldBySwitch;
        switchDay = _switchDay;
        perDay = _perDay;
    }

    /*//////////////////////////////////////////////////////////////
                              PRICING LOGIC
    //////////////////////////////////////////////////////////////*/

    function getTargetDayForNextSale(int256 sold) internal view virtual override returns (int256) {
        unchecked {
            return unsafeWadDiv(sold - soldBySwitch, perDay) + switchDay;
        }
    }
}


================================================
File: /src/utils/vrgda/LogisticVRGDA.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {wadExp, wadLn, unsafeDiv, unsafeWadDiv} from "../lib/SignedWadMath.sol";

import {VRGDA} from "./VRGDA.sol";

/// @title Logistic Variable Rate Gradual Dutch Auction
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Abstract VRGDA with a logistic issuance curve.
abstract contract LogisticVRGDA is VRGDA {
    /*//////////////////////////////////////////////////////////////
                           PRICING PARAMETERS
    //////////////////////////////////////////////////////////////*/

    /// @dev Controls the curve's maximum value which
    /// controls the maximum number of tokens to sell.
    /// @dev Represented as a 36 decimal fixed point number.
    int256 internal immutable logisticScale;

    /// @dev Time scale controls the steepness of the logistic curve,
    /// which effects how quickly we will reach the curve's asymptote.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable timeScale;

    /// @dev The initial value the uninverted logistic formula would output.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable initialLogisticValue;

    constructor(int256 _maxMintable, int256 _timeScale) {
        // We need to double _maxMintable to account for initialLogisticValue
        // and use 18 decimals to avoid wad multiplication in getTargetSaleDay.
        logisticScale = _maxMintable * 2e18;

        initialLogisticValue = _maxMintable;

        timeScale = _timeScale;
    }

    /*//////////////////////////////////////////////////////////////
                              PRICING LOGIC
    //////////////////////////////////////////////////////////////*/

    function getTargetDayForNextSale(int256 sold) internal view virtual override returns (int256) {
        unchecked {
            return -unsafeWadDiv(wadLn(unsafeDiv(logisticScale, sold + initialLogisticValue) - 1e18), timeScale);
        }
    }
}


================================================
File: /src/utils/vrgda/VRGDA.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {wadExp, wadLn, wadMul, unsafeWadMul, toWadUnsafe} from "../lib/SignedWadMath.sol";

/// @title Variable Rate Gradual Dutch Auction
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Sell tokens roughly according to an issuance schedule.
abstract contract VRGDA {
    /*//////////////////////////////////////////////////////////////
                            VRGDA PARAMETERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Initial price of each token, to be scaled according to sales rate.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 public immutable initialPrice;Directory structure:
└── artgobblers-art-gobblers
    ├── .prettierrc
    ├── analysis
    │   ├── compute_emissions.py
    │   ├── compute_price.py
    │   ├── requirements.txt
    │   ├── pricer.py
    │   └── README.md
    ├── .prettierignore
    ├── .gas-snapshot
    ├── remappings.txt
    ├── .github
    │   └── workflows
    │       └── tests.yml
    ├── assets
    │   └── state-machines
    ├── .solhint.json
    ├── test
    │   ├── Optimizations.t.sol
    │   ├── deploy
    │   │   └── DeployRinkeby.t.sol
    │   ├── GobblerReserve.t.sol
    │   ├── MerkleProofLib.t.sol
    │   ├── Pages.t.sol
    │   ├── SignedWadMath.t.sol
    │   ├── correctness
    │   │   ├── GobblersCorrectness.t.sol
    │   │   ├── PagesCorrectness.t.sol
    │   │   └── EmissionCorrectness.t.sol
    │   ├── LibString.t.sol
    │   ├── Benchmarks.t.sol
    │   ├── Goo.t.sol
    │   ├── ArtGobblers.t.sol
    │   ├── utils
    │   │   ├── LibRLP.sol
    │   │   ├── Console.sol
    │   │   ├── mocks
    │   │   │   ├── MockGooCalculator.sol
    │   │   │   └── LinkToken.sol
    │   │   └── Utilities.sol
    │   └── VRGDAs.t.sol
    ├── .gitmodules
    ├── lib
    │   ├── chainlink
    │   ├── ds-test
    │   ├── forge-std
    │   └── solmate
    ├── script
    │   └── deploy
    │       ├── DeployRinkeby.s.sol
    │       └── DeployBase.s.sol
    ├── foundry.toml
    ├── package.json
    ├── README.md
    └── src
        ├── Pages.sol
        ├── Goo.sol
        ├── ArtGobblers.sol
        └── utils
            ├── GobblerReserve.sol
            ├── lib
            │   ├── SignedWadMath.sol
            │   ├── MerkleProofLib.sol
            │   └── LibString.sol
            ├── token
            │   ├── PagesERC721.sol
            │   └── GobblersERC1155B.sol
            └── vrgda
                ├── PostSwitchVRGDA.sol
                ├── LogisticVRGDA.sol
                └── VRGDA.sol


Files Content:

================================================
File: /.prettierrc
================================================
{
  "tabWidth": 2,
  "printWidth": 100,

  "overrides": [
    {
      "files": "*.sol",
      "options": {
        "tabWidth": 4,
        "printWidth": 120
      }
    }
  ]
}


================================================
File: /analysis/compute_emissions.py
================================================
from eth_abi import encode_single
import math
import argparse

def compute_emissions(time, initial_amount, staking_multiple): 
    t1 = math.sqrt(staking_multiple) * time + 2 * math.sqrt(initial_amount)
    final_amount = 0.25 * t1 * t1

    final_amount *= (10 ** 18)
    encode_and_print(final_amount)

def encode_and_print(price):
    enc = encode_single('uint256', int(price))
    ## append 0x for FFI parsing 
    print("0x" + enc.hex())

def parse_args(): 
    parser = argparse.ArgumentParser()
    parser.add_argument("--time", type=int)
    parser.add_argument("--initial_amount", type=int)
    parser.add_argument("--emission_multiple", type=int)
    return parser.parse_args()

if __name__ == '__main__':
    args = parse_args() 
    compute_emissions(
        args.time / (10 ** 18)
        , args.initial_amount / (10 ** 18)
        , args.emission_multiple)

================================================
File: /analysis/compute_price.py
================================================
from pricer import Pricer
from eth_abi import encode_single
import argparse

def main(args): 
    if (args.type == 'gobblers'): 
        calculate_gobblers_price(args)
    elif (args.type == 'pages'):
        calculate_pages_price(args)
    
def calculate_gobblers_price(args): 
    pricer = Pricer()
    price = pricer.compute_gobbler_price(
        args.time_since_start / (60 * 60 * 24), ## convert to seconds 
        args.num_sold, 
        args.initial_price / (10 ** 18), ## scale decimals 
        args.per_period_price_decrease / (10 ** 18), ## scale decimals 
        args.logistic_scale / (10 ** 18), ## scale decimals 
        args.time_scale / (10 ** 18), ## scale decimals 
        0
    )
    price *= (10 ** 18)
    encode_and_print(price)

def calculate_pages_price(args): 
    pricer = Pricer()
    price = pricer.compute_page_price(
        args.time_since_start / (60 * 60 * 24), ## convert to seconds 
        args.num_sold, 
        args.initial_price / (10 ** 18), ## scale decimals 
        args.per_period_price_decrease / (10 ** 18), ## scale decimals 
        args.logistic_scale / (10 ** 18), ## scale decimals 
        args.time_scale / (10 ** 18), ## scale decimals 
        0,
        args.per_period_post_switchover / (10 ** 18), ## scale decimals 
        args.switchover_time / (10 ** 18)
    )
    price *= (10 ** 18)
    encode_and_print(price)

def encode_and_print(price):
    enc = encode_single('uint256', int(price))
    ## append 0x for FFI parsing 
    print("0x" + enc.hex())

def parse_args(): 
    parser = argparse.ArgumentParser()
    parser.add_argument("type", choices=["gobblers", "pages"])
    parser.add_argument("--time_since_start", type=int)
    parser.add_argument("--num_sold", type=int)
    parser.add_argument("--initial_price", type=int)
    parser.add_argument("--per_period_price_decrease", type=int)
    parser.add_argument("--logistic_scale", type=int)
    parser.add_argument("--time_scale", type=int)
    parser.add_argument("--per_period_post_switchover", type=int)
    parser.add_argument("--switchover_time", type=int)
    return parser.parse_args()

if __name__ == '__main__':
    args = parse_args() 
    main(args)

================================================
File: /analysis/requirements.txt
================================================
cytoolz==0.11.2
eth-abi==3.0.0
eth-hash==0.3.2
eth-typing==3.0.0
eth-utils==2.0.0
numpy==1.22.3
parsimonious==0.8.1
six==1.16.0
toolz==0.11.2


================================================
File: /analysis/pricer.py
================================================
import math
import numpy as np


class Pricer: 
    
    def compute_gobbler_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift):
       return self.compute_vrgda_price(time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift)

    def compute_page_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift,  per_period_post_switchover, switchover_time):
        initial_value = logistic_scale/ (1 +math.exp(time_scale * time_shift))
        sold_by_switchover = logistic_scale / (1 + math.exp(-1 * time_scale * (switchover_time - time_shift))) - initial_value
        if num_sold < sold_by_switchover:
            return self.compute_vrgda_price(time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift)
        else: 
            f_inv = (num_sold - sold_by_switchover) / per_period_post_switchover + switchover_time
            return initial_price * math.exp(-math.log(1 - per_period_price_decrease) * (f_inv - time_since_start))

    def compute_vrgda_price(self, time_since_start, num_sold, initial_price, per_period_price_decrease, logistic_scale, time_scale, time_shift):
        initial_value = logistic_scale / (1 + math.exp(time_scale * time_shift))
        logistic_value = num_sold + initial_value
        price = (1 - per_period_price_decrease) ** (time_since_start - time_shift + (math.log(-1 + logistic_scale / logistic_value) / time_scale)) * initial_price
        return price


================================================
File: /analysis/README.md
================================================
# Gobblers Analysis

Directory for gobbler economy modeling.

## Running

In order to run correctness tests, first install requirements with

```
pip install -r requirements.txt
```

Then run FFI tests with

```
forge test -vvv --ffi --match-test FFI
```


================================================
File: /.prettierignore
================================================
lib

================================================
File: /.gas-snapshot
================================================
ArtGobblersTest:testCanMintMultipleReserved() (gas: 1287959)
ArtGobblersTest:testCanMintReserved() (gas: 613727)
ArtGobblersTest:testCannotMintLegendaryWithLegendary() (gas: 76482119)
ArtGobblersTest:testCannotReuseSeedForReveal() (gas: 260127)
ArtGobblersTest:testCannotRevealMoreGobblersThanRemainingToBeRevealed() (gas: 268922)
ArtGobblersTest:testCantFeed1155As721() (gas: 1730262)
ArtGobblersTest:testCantFeed721As1155() (gas: 215902)
ArtGobblersTest:testCantFeedArtToUnownedGobbler() (gas: 114952)
ArtGobblersTest:testCantFeedUnownedArt() (gas: 120521)
ArtGobblersTest:testCantMintTooFastReserved() (gas: 1191218)
ArtGobblersTest:testCantMintTooFastReservedOneByOne() (gas: 6313459)
ArtGobblersTest:testCantRemoveGoo() (gas: 198003)
ArtGobblersTest:testCantSetRandomSeedWithoutRevealing() (gas: 270452)
ArtGobblersTest:testDoesNotAllowRevealingZero() (gas: 16298)
ArtGobblersTest:testEmissionMultipleUpdatesAfterTransfer() (gas: 231430)
ArtGobblersTest:testFeeding1155() (gas: 1739560)
ArtGobblersTest:testFeedingArt() (gas: 238976)
ArtGobblersTest:testFeedingMultiple1155Copies() (gas: 1781012)
ArtGobblersTest:testGobblerBalancesAfterTransfer() (gas: 235410)
ArtGobblersTest:testGooAddition() (gas: 228896)
ArtGobblersTest:testGooRemoval() (gas: 244664)
ArtGobblersTest:testInitialGobblerPrice() (gas: 9994)
ArtGobblersTest:testLegendaryGobblerFinalPrice() (gas: 73832294)
ArtGobblersTest:testLegendaryGobblerInitialPrice() (gas: 36930528)
ArtGobblersTest:testLegendaryGobblerMidPrice() (gas: 55349188)
ArtGobblersTest:testLegendaryGobblerMinStartPrice() (gas: 73881145)
ArtGobblersTest:testLegendaryGobblerMintBeforeStart() (gas: 20751)
ArtGobblersTest:testLegendaryGobblerPastFinalPrice() (gas: 67861384)
ArtGobblersTest:testMintFreeLegendaryGobbler() (gas: 73884453)
ArtGobblersTest:testMintFreeLegendaryGobblerPastInterval() (gas: 110790416)
ArtGobblersTest:testMintFromGoo() (gas: 93859)
ArtGobblersTest:testMintFromMintlist() (gas: 85518)
ArtGobblersTest:testMintFromMintlistBeforeMintingStarts() (gas: 13832)
ArtGobblersTest:testMintInsufficientBalance() (gas: 22757)
ArtGobblersTest:testMintLegendaryGobbler() (gas: 39932016)
ArtGobblersTest:testMintLegendaryGobblerWithUnownedId() (gas: 39781071)
ArtGobblersTest:testMintLegendaryGobblerWithWrongLength() (gas: 39741318)
ArtGobblersTest:testMintLegendaryGobblersExpectedIds() (gas: 249746540)
ArtGobblersTest:testMintNotInMintlist() (gas: 11203)
ArtGobblersTest:testMintPriceExceededMax() (gas: 71957)
ArtGobblersTest:testMintReservedGobblersFailsWithNoMints() (gas: 32683)
ArtGobblersTest:testMintedLegendaryURI() (gas: 73891311)
ArtGobblersTest:testMintingFromMintlistTwiceFails() (gas: 86043)
ArtGobblersTest:testMultiReveal() (gas: 8285801)
ArtGobblersTest:testPricingBasic() (gas: 54164622)
ArtGobblersTest:testRevealDelayInitialMint() (gas: 95506)
ArtGobblersTest:testRevealDelayRecurring() (gas: 244916)
ArtGobblersTest:testRevealedUri() (gas: 202251)
ArtGobblersTest:testSimpleRewards() (gas: 200238)
ArtGobblersTest:testUnmintedLegendaryUri() (gas: 19275)
ArtGobblersTest:testUnmintedUri() (gas: 11341)
ArtGobblersTest:testUnrevealedUri() (gas: 99913)
BenchmarksTest:testAddGoo() (gas: 28507)
BenchmarksTest:testBatchTransferGobblers() (gas: 697629)
BenchmarksTest:testGobblerPrice() (gas: 8982)
BenchmarksTest:testGooBalance() (gas: 8650)
BenchmarksTest:testLegendaryGobblersPrice() (gas: 9907)
BenchmarksTest:testMintCommunityPages() (gas: 58998)
BenchmarksTest:testMintGobbler() (gas: 55850)
BenchmarksTest:testMintLegendaryGobbler() (gas: 410870)
BenchmarksTest:testMintPage() (gas: 58713)
BenchmarksTest:testMintReservedGobblers() (gas: 91179)
BenchmarksTest:testPagePrice() (gas: 9110)
BenchmarksTest:testRemoveGoo() (gas: 28566)
BenchmarksTest:testRevealGobblers() (gas: 2840727)
GobblerReserveTest:testCanWithdraw() (gas: 760498)
GooTest:testBurnAllowed() (gas: 56314)
GooTest:testBurnNotAllowed() (gas: 56354)
GooTest:testMintByAuthority() (gas: 53601)
GooTest:testMintByNonAuthority() (gas: 13113)
GooTest:testSetPages() (gas: 64071)
LibStringTest:testToString() (gas: 10927)
MerkleProofLibTest:testValidProofSupplied() (gas: 2217)
MerkleProofLibTest:testVerifyEmptyMerkleProofSuppliedLeafAndRootDifferent() (gas: 1498)
MerkleProofLibTest:testVerifyEmptyMerkleProofSuppliedLeafAndRootSame() (gas: 1492)
MerkleProofLibTest:testVerifyInvalidProofSupplied() (gas: 2236)
PagesTest:testCanMintCommunity() (gas: 650527)
PagesTest:testCanMintMultipleCommunity() (gas: 1234368)
PagesTest:testCantMintTooFastCommunity() (gas: 1172707)
PagesTest:testCantMintTooFastCommunityOneByOne() (gas: 5916760)
PagesTest:testInitialPrice() (gas: 10023)
PagesTest:testInsufficientBalance() (gas: 20515)
PagesTest:testMintBeforeSetMint() (gas: 20528)
PagesTest:testMintBeforeStart() (gas: 11767)
PagesTest:testMintCommunityPagesFailsWithNoMints() (gas: 30572)
PagesTest:testMintPriceExceededMax() (gas: 69218)
PagesTest:testPagePricingPricingAfterSwitch() (gas: 360680811)
PagesTest:testPagePricingPricingBeforeSwitch() (gas: 224252486)
PagesTest:testRegularMint() (gas: 108635)
VRGDAsTest:testGobblerPriceStrictlyIncreasesForMostGobblers() (gas: 4120666)
VRGDAsTest:testPagePriceStrictlyIncreasesFor8465Pages() (gas: 20446362)
DeployRinkebyTest:testColdWallet() (gas: 21773)
DeployRinkebyTest:testGooAddressCorrectness() (gas: 18214)
DeployRinkebyTest:testMerkleRoot() (gas: 88127)
DeployRinkebyTest:testPagesAddressCorrectness() (gas: 18235)
DeployRinkebyTest:testURIs() (gas: 48605)


================================================
File: /remappings.txt
================================================
ds-test/=lib/ds-test/src/
solmate/=lib/solmate/src/
forge-std/=lib/forge-std/src/
openzeppelin/=lib/openzeppelin-contracts/contracts/
chainlink/=lib/chainlink/contracts/src/

================================================
File: /.github/workflows/tests.yml
================================================
name: Tests

on: [push, pull_request]

jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2

      - name: Install dev dependencies
        run: npm install

      - name: Install Foundry
        uses: onbjerg/foundry-toolchain@v1
        with:
          version: nightly

      - name: Run lint check
        run: npm run lint:check

      - name: Install dependencies
        run: forge install

      - name: Check contract sizes
        run: forge build --sizes

      - name: Check gas snapshots
        run: forge snapshot --check

      - name: Run tests
        run: forge test
        env:
          # Only fuzz intensely if we're running this action on a push to master or for a PR going into master:
          FOUNDRY_PROFILE: ${{ (github.ref == 'refs/heads/master' || github.base_ref == 'master') && 'intense' }}


================================================
File: /.solhint.json
================================================
{
  "extends": "solhint:recommended", 
  "rules": {
    "compiler-version": ["error",">=0.8.0"], 
    "avoid-low-level-calls": "off"
  }
}


================================================
File: /test/Optimizations.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";

contract OptimizationsTest is DSTestPlus {
    function testFuzzCurrentIdMultipleBranchlessOptimization(uint256 swapIndex) public {
        /*//////////////////////////////////////////////////////////////
                                  BRANCHLESS
        //////////////////////////////////////////////////////////////*/

        uint256 newCurrentIdMultipleBranchless = 9; // For beyond 7963.
        assembly {
            // prettier-ignore
            newCurrentIdMultipleBranchless := sub(sub(sub(newCurrentIdMultipleBranchless,
                lt(swapIndex, 7964)), lt(swapIndex, 5673)), lt(swapIndex, 3055)
            )
        }

        /*//////////////////////////////////////////////////////////////
                                  BRANCHED
        //////////////////////////////////////////////////////////////*/

        uint256 newCurrentIdMultipleBranched = 9; // For beyond 7963.
        if (swapIndex <= 3054) newCurrentIdMultipleBranched = 6;
        else if (swapIndex <= 5672) newCurrentIdMultipleBranched = 7;
        else if (swapIndex <= 7963) newCurrentIdMultipleBranched = 8;

        /*//////////////////////////////////////////////////////////////
                                EQUIVALENCE
        //////////////////////////////////////////////////////////////*/

        assertEq(newCurrentIdMultipleBranchless, newCurrentIdMultipleBranched);
    }
}


================================================
File: /test/deploy/DeployRinkeby.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {DeployRinkeby} from "../../script/deploy/DeployRinkeby.s.sol";
import {Vm} from "forge-std/Vm.sol";
import {console} from "forge-std/console.sol";

import {Pages} from "../../src/Pages.sol";
import {ArtGobblers} from "../../src/ArtGobblers.sol";

contract DeployRinkebyTest is DSTestPlus {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    DeployRinkeby deployScript;

    function setUp() public {
        deployScript = new DeployRinkeby();
        deployScript.run();
    }

    /// @notice Test goo addresses where correctly set.
    function testGooAddressCorrectness() public {
        assertEq(deployScript.goo().artGobblers(), address(deployScript.artGobblers()));
        assertEq(address(deployScript.goo().pages()), address(deployScript.pages()));
    }

    /// @notice Test page addresses where correctly set.
    function testPagesAddressCorrectness() public {
        assertEq(deployScript.pages().artGobblers(), address(deployScript.artGobblers()));
        assertEq(address(deployScript.pages().goo()), address(deployScript.goo()));
    }

    /// @notice Test that merkle root was correctly set.
    function testMerkleRoot() public {
        vm.warp(deployScript.mintStart());
        // Use merkle root as user to test simple proof.
        address user = deployScript.root();
        bytes32[] memory proof;
        ArtGobblers gobblers = deployScript.artGobblers();
        vm.prank(user);
        gobblers.claimGobbler(proof);
        // Verify gobbler ownership.
        assertEq(gobblers.ownerOf(1), user);
    }

    /// @notice Test cold wallet was appropriately set.
    function testColdWallet() public {
        address coldWallet = deployScript.coldWallet();
        address communityOwner = deployScript.teamReserve().owner();
        address teamOwner = deployScript.communityReserve().owner();
        assertEq(coldWallet, communityOwner);
        assertEq(coldWallet, teamOwner);
    }

    /// @notice Test URIs are correctly set.
    function testURIs() public {
        ArtGobblers gobblers = deployScript.artGobblers();
        assertEq(gobblers.BASE_URI(), deployScript.gobblerBaseUri());
        assertEq(gobblers.UNREVEALED_URI(), deployScript.gobblerUnrevealedUri());
        Pages pages = deployScript.pages();
        assertEq(pages.BASE_URI(), deployScript.pagesBaseUri());
    }
}


================================================
File: /test/GobblerReserve.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";
import {Utilities} from "./utils/Utilities.sol";
import {console} from "./utils/Console.sol";
import {Vm} from "forge-std/Vm.sol";
import {stdError} from "forge-std/Test.sol";
import {ArtGobblers} from "../src/ArtGobblers.sol";
import {Goo} from "../src/Goo.sol";
import {Pages} from "../src/Pages.sol";
import {GobblerReserve} from "../src/utils/GobblerReserve.sol";
import {LinkToken} from "./utils/mocks/LinkToken.sol";
import {VRFCoordinatorMock} from "chainlink/v0.8/mocks/VRFCoordinatorMock.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {MockERC1155} from "solmate/test/utils/mocks/MockERC1155.sol";
import {LibString} from "../src/utils/lib/LibString.sol";

/// @notice Unit test for the Gobbler Reserve contract.
contract GobblerReserveTest is DSTestPlus, ERC1155TokenReceiver {
    using LibString for uint256;

    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    Utilities internal utils;
    address payable[] internal users;

    ArtGobblers internal gobblers;
    VRFCoordinatorMock internal vrfCoordinator;
    LinkToken internal linkToken;
    Goo internal goo;
    Pages internal pages;
    GobblerReserve internal team;
    GobblerReserve internal community;

    bytes32 private keyHash;
    uint256 private fee;

    uint256[] ids;

    /*//////////////////////////////////////////////////////////////
                                  SETUP
    //////////////////////////////////////////////////////////////*/

    function setUp() public {
        utils = new Utilities();
        users = utils.createUsers(5);
        linkToken = new LinkToken();
        vrfCoordinator = new VRFCoordinatorMock(address(linkToken));

        team = new GobblerReserve(ArtGobblers(utils.predictContractAddress(address(this), 3)), address(this));
        community = new GobblerReserve(ArtGobblers(utils.predictContractAddress(address(this), 2)), address(this));

        goo = new Goo(
            // Gobblers:
            utils.predictContractAddress(address(this), 1),
            // Pages:
            utils.predictContractAddress(address(this), 2)
        );

        gobblers = new ArtGobblers(
            keccak256(abi.encodePacked(users[0])),
            block.timestamp,
            goo,
            address(team),
            address(community),
            address(vrfCoordinator),
            address(linkToken),
            keyHash,
            fee,
            "base",
            ""
        );

        pages = new Pages(block.timestamp, goo, address(0xBEEF), address(gobblers), "");
    }

    /*//////////////////////////////////////////////////////////////
                            WITHDRAWAL TESTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Tests that a reserve can be withdrawn from.
    function testCanWithdraw() public {
        mintGobblerToAddress(users[0], 9);

        gobblers.mintReservedGobblers(1);

        assertEq(gobblers.ownerOf(10), address(team));
        assertEq(gobblers.ownerOf(11), address(community));

        uint256[] memory idsToWithdraw = new uint256[](1);

        idsToWithdraw[0] = 10;
        team.withdraw(address(this), idsToWithdraw);

        idsToWithdraw[0] = 11;
        community.withdraw(address(this), idsToWithdraw);

        assertEq(gobblers.ownerOf(10), address(this));
        assertEq(gobblers.ownerOf(11), address(this));
    }

    /*//////////////////////////////////////////////////////////////
                                 HELPERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a number of gobblers to the given address
    function mintGobblerToAddress(address addr, uint256 num) internal {
        for (uint256 i = 0; i < num; i++) {
            vm.startPrank(address(gobblers));
            goo.mintForGobblers(addr, gobblers.gobblerPrice());
            vm.stopPrank();

            vm.prank(addr);
            gobblers.mintFromGoo(type(uint256).max);
        }
    }
}


================================================
File: /test/MerkleProofLib.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";

import {MerkleProofLib} from "../src/utils/lib/MerkleProofLib.sol";

contract MerkleProofLibTest is DSTestPlus {
    function testVerifyEmptyMerkleProofSuppliedLeafAndRootSame() public {
        bytes32[] memory proof;
        assertBoolEq(this.verify(proof, 0x00, 0x00), true);
    }

    function testVerifyEmptyMerkleProofSuppliedLeafAndRootDifferent() public {
        bytes32[] memory proof;
        bytes32 leaf = "a";
        assertBoolEq(this.verify(proof, 0x00, leaf), false);
    }

    function testValidProofSupplied() public {
        // Merkle tree created from leaves ['a', 'b', 'c'].
        // Leaf is 'a'.
        bytes32[] memory proof = new bytes32[](2);
        proof[0] = 0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5510;
        proof[1] = 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2;
        bytes32 root = 0x5842148bc6ebeb52af882a317c765fccd3ae80589b21a9b8cbf21abb630e46a7;
        bytes32 leaf = 0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb;
        assertBoolEq(this.verify(proof, root, leaf), true);
    }

    function testVerifyInvalidProofSupplied() public {
        // Merkle tree created from leaves ['a', 'b', 'c'].
        // Leaf is 'a'.
        // Proof is same as testValidProofSupplied but last byte of first element is modified.
        bytes32[] memory proof = new bytes32[](2);
        proof[0] = 0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5511;
        proof[1] = 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2;
        bytes32 root = 0x5842148bc6ebeb52af882a317c765fccd3ae80589b21a9b8cbf21abb630e46a7;
        bytes32 leaf = 0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb;
        assertBoolEq(this.verify(proof, root, leaf), false);
    }

    function verify(
        bytes32[] calldata proof,
        bytes32 root,
        bytes32 leaf
    ) external pure returns (bool) {
        return MerkleProofLib.verify(proof, root, leaf);
    }
}


================================================
File: /test/Pages.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {Utilities} from "./utils/Utilities.sol";
import {Vm} from "forge-std/Vm.sol";
import {stdError} from "forge-std/Test.sol";
import {Goo} from "../src/Goo.sol";
import {Pages} from "../src/Pages.sol";
import {console} from "./utils/Console.sol";

contract PagesTest is DSTestPlus {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);
    Utilities internal utils;
    address payable[] internal users;
    address internal mintAuth;

    address internal user;
    Goo internal goo;
    Pages internal pages;
    uint256 mintStart;

    address internal community = address(0xBEEF);

    function setUp() public {
        // Avoid starting at timestamp at 0 for ease of testing.
        vm.warp(block.timestamp + 1);

        utils = new Utilities();
        users = utils.createUsers(5);

        goo = new Goo(
            // Gobblers:
            address(this),
            // Pages:
            utils.predictContractAddress(address(this), 1)
        );

        pages = new Pages(block.timestamp, goo, community, address(this), "");

        user = users[1];
    }

    function testMintBeforeSetMint() public {
        vm.expectRevert(stdError.arithmeticError);
        vm.prank(user);
        pages.mintFromGoo(type(uint256).max);
    }

    function testMintBeforeStart() public {
        vm.warp(block.timestamp - 1);

        vm.expectRevert(stdError.arithmeticError);
        vm.prank(user);
        pages.mintFromGoo(type(uint256).max);
    }

    function testRegularMint() public {
        goo.mintForGobblers(user, pages.pagePrice());
        vm.prank(user);
        pages.mintFromGoo(type(uint256).max);
        assertEq(user, pages.ownerOf(1));
    }

    function testInitialPrice() public {
        uint256 cost = pages.pagePrice();
        uint256 maxDelta = 5; // 0.000000000000000005

        assertApproxEq(cost, uint256(pages.initialPrice()), maxDelta);
    }

    function testMintCommunityPagesFailsWithNoMints() public {
        vm.expectRevert(Pages.ReserveImbalance.selector);
        pages.mintCommunityPages(1);
    }

    function testCanMintCommunity() public {
        mintPageToAddress(user, 9);

        pages.mintCommunityPages(1);
        assertEq(pages.ownerOf(10), address(community));
    }

    function testCanMintMultipleCommunity() public {
        mintPageToAddress(user, 18);

        pages.mintCommunityPages(2);
        assertEq(pages.ownerOf(19), address(community));
        assertEq(pages.ownerOf(20), address(community));
    }

    function testCantMintTooFastCommunity() public {
        mintPageToAddress(user, 18);

        vm.expectRevert(Pages.ReserveImbalance.selector);
        pages.mintCommunityPages(3);
    }

    function testCantMintTooFastCommunityOneByOne() public {
        mintPageToAddress(user, 90);

        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);
        pages.mintCommunityPages(1);

        vm.expectRevert(Pages.ReserveImbalance.selector);
        pages.mintCommunityPages(1);
    }

    /// @notice Test that page pricing matches expected behavior before switch.
    function testPagePricingPricingBeforeSwitch() public {
        // Expected sales rate according to mathematical formula.
        uint256 timeDelta = 60 days;
        uint256 numMint = 3572;

        vm.warp(block.timestamp + timeDelta);

        uint256 initialPrice = uint256(pages.initialPrice());

        for (uint256 i = 0; i < numMint; i++) {
            uint256 price = pages.pagePrice();
            goo.mintForGobblers(user, price);
            vm.prank(user);
            pages.mintFromGoo(price);
        }

        uint256 finalPrice = pages.pagePrice();

        // If selling at target rate, final price should equal starting price.
        assertRelApproxEq(initialPrice, finalPrice, 0.01e18);
    }

    /// @notice Test that page pricing matches expected behavior after switch.
    function testPagePricingPricingAfterSwitch() public {
        uint256 timeDelta = 360 days;
        uint256 numMint = 9498;

        vm.warp(block.timestamp + timeDelta);

        uint256 initialPrice = uint256(pages.initialPrice());

        for (uint256 i = 0; i < numMint; i++) {
            uint256 price = pages.pagePrice();
            goo.mintForGobblers(user, price);
            vm.prank(user);
            pages.mintFromGoo(price);
        }

        uint256 finalPrice = pages.pagePrice();

        // If selling at target rate, final price should equal starting price.
        assertRelApproxEq(initialPrice, finalPrice, 0.02e18);
    }

    function testInsufficientBalance() public {
        vm.prank(user);
        vm.expectRevert(stdError.arithmeticError);
        pages.mintFromGoo(type(uint256).max);
    }

    function testMintPriceExceededMax() public {
        uint256 cost = pages.pagePrice();
        goo.mintForGobblers(user, cost);
        vm.prank(user);
        vm.expectRevert(abi.encodeWithSelector(Pages.PriceExceededMax.selector, cost));
        pages.mintFromGoo(cost - 1);
    }

    /// @notice Mint a number of pages to the given address
    function mintPageToAddress(address addr, uint256 num) internal {
        for (uint256 i = 0; i < num; i++) {
            goo.mintForGobblers(addr, pages.pagePrice());

            vm.prank(addr);
            pages.mintFromGoo(type(uint256).max);
        }
    }
}


================================================
File: /test/SignedWadMath.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";

import {wadMul, wadDiv} from "../src/utils/lib/SignedWadMath.sol";

contract SignedWadMathTest is DSTestPlus {
    function testWadMul(
        uint256 x,
        uint256 y,
        bool negX,
        bool negY
    ) public {
        x = bound(x, 0, 99999999999999e18);
        y = bound(x, 0, 99999999999999e18);

        int256 xPrime = negX ? -int256(x) : int256(x);
        int256 yPrime = negY ? -int256(y) : int256(y);

        assertEq(wadMul(xPrime, yPrime), (xPrime * yPrime) / 1e18);
    }

    function testFailWadMulOverflow(int256 x, int256 y) public pure {
        // Ignore cases where x * y does not overflow.
        unchecked {
            if ((x * y) / x == y) revert();
        }

        wadMul(x, y);
    }

    function testWadDiv(
        uint256 x,
        uint256 y,
        bool negX,
        bool negY
    ) public {
        x = bound(x, 0, 99999999e18);
        y = bound(x, 1, 99999999e18);

        int256 xPrime = negX ? -int256(x) : int256(x);
        int256 yPrime = negY ? -int256(y) : int256(y);

        assertEq(wadDiv(xPrime, yPrime), (xPrime * 1e18) / yPrime);
    }

    function testFailWadDivOverflow(int256 x, int256 y) public pure {
        // Ignore cases where x * WAD does not overflow or y is 0.
        unchecked {
            if (y == 0 || (x * 1e18) / 1e18 == x) revert();
        }

        wadDiv(x, y);
    }

    function testFailWadDivZeroDenominator(int256 x) public pure {
        wadDiv(x, 0);
    }
}


================================================
File: /test/correctness/GobblersCorrectness.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {Vm} from "forge-std/Vm.sol";
import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {LibString} from "../../src/utils/lib/LibString.sol";
import {ArtGobblers} from "../../src/ArtGobblers.sol";
import {Goo} from "../../src/Goo.sol";

contract GobblersCorrectnessTest is DSTestPlus {
    using LibString for uint256;

    uint256 internal immutable TWENTY_YEARS = 7300 days;

    uint256 internal MAX_MINTABLE;

    int256 internal LOGISTIC_SCALE;

    int256 internal immutable INITIAL_PRICE = 69.42e18;

    int256 internal immutable PER_PERIOD_PRICE_DECREASE = 0.31e18;

    int256 internal immutable TIME_SCALE = 0.0023e18;

    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    ArtGobblers internal gobblers;

    function setUp() public {
        gobblers = new ArtGobblers(
            "root",
            block.timestamp,
            Goo(address(0)),
            address(0),
            address(0),
            address(0),
            address(0),
            0,
            0,
            "",
            ""
        );

        MAX_MINTABLE = gobblers.MAX_MINTABLE();
        LOGISTIC_SCALE = int256(MAX_MINTABLE * 2e18);
    }

    function testFFICorrectness(uint256 timeSinceStart, uint256 numSold) public {
        // Limit num sold to max mint.
        numSold = bound(numSold, 0, MAX_MINTABLE);

        // Limit mint time to 20 years.
        timeSinceStart = bound(timeSinceStart, 0, TWENTY_YEARS);

        // Calculate actual price from VRGDA.
        try gobblers.getPrice(timeSinceStart, numSold) returns (uint256 actualPrice) {
            // Calculate expected price from python script.
            uint256 expectedPrice = calculatePrice(
                timeSinceStart,
                numSold,
                INITIAL_PRICE,
                PER_PERIOD_PRICE_DECREASE,
                LOGISTIC_SCALE,
                TIME_SCALE
            );

            if (expectedPrice < 0.0000000000001e18) return; // For really small prices we can't expect them to be equal.

            // Equal within 1 percent.
            assertRelApproxEq(actualPrice, expectedPrice, 0.01e18);
        } catch {
            // If it reverts that's fine, there are some bounds on the function, they are tested in VRGDAs.t.sol
        }
    }

    function calculatePrice(
        uint256 _timeSinceStart,
        uint256 _numSold,
        int256 _initialPrice,
        int256 _perPeriodPriceDecrease,
        int256 _logisticScale,
        int256 _timeScale
    ) private returns (uint256) {
        string[] memory inputs = new string[](15);
        inputs[0] = "python3";
        inputs[1] = "analysis/compute_price.py";
        inputs[2] = "gobblers";
        inputs[3] = "--time_since_start";
        inputs[4] = _timeSinceStart.toString();
        inputs[5] = "--num_sold";
        inputs[6] = _numSold.toString();
        inputs[7] = "--initial_price";
        inputs[8] = uint256(_initialPrice).toString();
        inputs[9] = "--per_period_price_decrease";
        inputs[10] = uint256(_perPeriodPriceDecrease).toString();
        inputs[11] = "--logistic_scale";
        inputs[12] = uint256(_logisticScale).toString();
        inputs[13] = "--time_scale";
        inputs[14] = uint256(_timeScale).toString();

        return abi.decode(vm.ffi(inputs), (uint256));
    }
}


================================================
File: /test/correctness/PagesCorrectness.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {Vm} from "forge-std/Vm.sol";
import {LibString} from "../../src/utils/lib/LibString.sol";
import {console} from "../utils/Console.sol";
import {Pages} from "../../src/Pages.sol";
import {Goo} from "../../src/Goo.sol";

contract PageCorrectnessTest is DSTestPlus {
    using LibString for uint256;

    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    uint256 internal immutable TWENTY_YEARS = 7300 days;

    uint256 internal immutable MAX_MINTABLE = 9000;

    int256 internal LOGISTIC_SCALE;

    int256 internal immutable INITIAL_PRICE = 4.2069e18;

    int256 internal immutable PER_PERIOD_PRICE_DECREASE = 0.31e18;

    int256 internal immutable TIME_SCALE = 0.014e18;

    int256 internal immutable SWITCHOVER_TIME = 207e18;

    int256 internal immutable PER_PERIOD_POST_SWITCHOVER = 10e18;

    Pages internal pages;

    function setUp() public {
        pages = new Pages(block.timestamp, Goo(address(0)), address(0), address(0), "");

        LOGISTIC_SCALE = int256(MAX_MINTABLE * 2e18);
    }

    function testFFICorrectness(uint256 timeSinceStart, uint256 numSold) public {
        // Limit num sold to max mint.
        numSold = bound(numSold, 0, 10000);

        // Limit mint time to 20 years.
        timeSinceStart = bound(timeSinceStart, 0, TWENTY_YEARS);

        // Calculate actual price from VRGDA.
        try pages.getPrice(timeSinceStart, numSold) returns (uint256 actualPrice) {
            // Calculate expected price from python script.
            uint256 expectedPrice = calculatePrice(
                timeSinceStart,
                numSold,
                INITIAL_PRICE,
                PER_PERIOD_PRICE_DECREASE,
                LOGISTIC_SCALE,
                TIME_SCALE,
                PER_PERIOD_POST_SWITCHOVER,
                SWITCHOVER_TIME
            );

            if (expectedPrice < 0.0000000000001e18) return; // For really small prices we can't expect them to be equal.

            // Equal within 1 percent.
            assertRelApproxEq(actualPrice, expectedPrice, 0.01e18);
        } catch {
            // If it reverts that's fine, there are some bounds on the function, they are tested in VRGDAs.t.sol
        }
    }

    function calculatePrice(
        uint256 _timeSinceStart,
        uint256 _numSold,
        int256 _initialPrice,
        int256 _PER_PERIOD_PRICE_DECREASE,
        int256 _logisticScale,
        int256 _timeScale,
        int256 _perPeriodPostSwitchover,
        int256 _switchoverTime
    ) private returns (uint256) {
        string[] memory inputs = new string[](19);
        inputs[0] = "python3";
        inputs[1] = "analysis/compute_price.py";
        inputs[2] = "pages";
        inputs[3] = "--time_since_start";
        inputs[4] = _timeSinceStart.toString();
        inputs[5] = "--num_sold";
        inputs[6] = _numSold.toString();
        inputs[7] = "--initial_price";
        inputs[8] = uint256(_initialPrice).toString();
        inputs[9] = "--per_period_price_decrease";
        inputs[10] = uint256(_PER_PERIOD_PRICE_DECREASE).toString();
        inputs[11] = "--logistic_scale";
        inputs[12] = uint256(_logisticScale).toString();
        inputs[13] = "--time_scale";
        inputs[14] = uint256(_timeScale).toString();
        inputs[15] = "--per_period_post_switchover";
        inputs[16] = uint256(_perPeriodPostSwitchover).toString();
        inputs[17] = "--switchover_time";
        inputs[18] = uint256(_switchoverTime).toString();

        return abi.decode(vm.ffi(inputs), (uint256));
    }
}


================================================
File: /test/correctness/EmissionCorrectness.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {MockGooCalculator} from "../utils/mocks/MockGooCalculator.sol";
import {Vm} from "forge-std/Vm.sol";
import {LibString} from "../../src/utils/lib/LibString.sol";

contract EmissionCorrectnessTest is DSTestPlus {
    using LibString for uint256;

    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    MockGooCalculator immutable gooCalculator = new MockGooCalculator();

    function testFFIEmissionCorrectness(
        uint256 daysElapsedWad,
        uint256 lastBalanceWad,
        uint256 emissionMultiple
    ) public {
        emissionMultiple = bound(emissionMultiple, 0, 100);

        daysElapsedWad = bound(daysElapsedWad, 0, 7300 days * 1e18);

        lastBalanceWad = bound(lastBalanceWad, 0, 1e36);

        uint256 expectedBalance = calculateBalance(daysElapsedWad, lastBalanceWad, emissionMultiple);

        uint256 actualBalance = gooCalculator.computeGooBalance(emissionMultiple, lastBalanceWad, daysElapsedWad);

        if (expectedBalance < 0.0000000000001e18) return; // For really small balances we can't expect them to be equal.

        // Equal within 1 percent.
        assertRelApproxEq(actualBalance, expectedBalance, 0.01e18);
    }

    function calculateBalance(
        uint256 _emissionTime,
        uint256 _initialAmount,
        uint256 _emissionMultiple
    ) private returns (uint256) {
        string[] memory inputs = new string[](8);
        inputs[0] = "python3";
        inputs[1] = "analysis/compute_emissions.py";
        inputs[2] = "--time";
        inputs[3] = _emissionTime.toString();
        inputs[4] = "--initial_amount";
        inputs[5] = _initialAmount.toString();
        inputs[6] = "--emission_multiple";
        inputs[7] = _emissionMultiple.toString();

        return abi.decode(vm.ffi(inputs), (uint256));
    }
}


================================================
File: /test/LibString.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";

import {LibString} from "../src/utils/lib/LibString.sol";

contract LibStringTest is DSTestPlus {
    function testToString() public {
        assertEq(LibString.toString(0), "0");
        assertEq(LibString.toString(1), "1");
        assertEq(LibString.toString(17), "17");
        assertEq(LibString.toString(99999999), "99999999");
        assertEq(LibString.toString(99999999999), "99999999999");
        assertEq(LibString.toString(2342343923423), "2342343923423");
        assertEq(LibString.toString(98765685434567), "98765685434567");
    }

    function testDifferentiallyFuzzToString(uint256 value, bytes calldata brutalizeWith)
        public
        brutalizeMemory(brutalizeWith)
    {
        string memory libString = LibString.toString(value);
        string memory oz = toStringOZ(value);

        assertEq(bytes(libString).length, bytes(oz).length);
        assertEq(libString, oz);
    }
}

function toStringOZ(uint256 value) pure returns (string memory) {
    if (value == 0) {
        return "0";
    }
    uint256 temp = value;
    uint256 digits;
    while (temp != 0) {
        digits++;
        temp /= 10;
    }
    bytes memory buffer = new bytes(digits);
    while (value != 0) {
        digits -= 1;
        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
        value /= 10;
    }
    return string(buffer);
}


================================================
File: /test/Benchmarks.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTest} from "ds-test/test.sol";
import {ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";
import {Utilities} from "./utils/Utilities.sol";
import {console} from "./utils/Console.sol";
import {Vm} from "forge-std/Vm.sol";
import {ArtGobblers} from "../src/ArtGobblers.sol";
import {Goo} from "../src/Goo.sol";
import {Pages} from "../src/Pages.sol";
import {LinkToken} from "./utils/mocks/LinkToken.sol";
import {VRFCoordinatorMock} from "chainlink/v0.8/mocks/VRFCoordinatorMock.sol";

contract BenchmarksTest is DSTest, ERC1155TokenReceiver {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    Utilities internal utils;
    address payable[] internal users;

    ArtGobblers private gobblers;
    VRFCoordinatorMock private vrfCoordinator;
    LinkToken private linkToken;

    Goo goo;
    Pages pages;

    uint256 legendaryCost;

    bytes32 private keyHash;
    uint256 private fee;

    function setUp() public {
        vm.warp(1); // Otherwise mintStart will be set to 0 and brick pages.mintFromGoo(type(uint256).max)

        utils = new Utilities();
        users = utils.createUsers(5);
        linkToken = new LinkToken();
        vrfCoordinator = new VRFCoordinatorMock(address(linkToken));

        goo = new Goo(
            // Gobblers:
            utils.predictContractAddress(address(this), 1),
            // Pages:
            utils.predictContractAddress(address(this), 2)
        );

        gobblers = new ArtGobblers(
            keccak256(abi.encodePacked(users[0])),
            block.timestamp,
            goo,
            address(0xBEEF),
            address(0xBEEF),
            address(vrfCoordinator),
            address(linkToken),
            keyHash,
            fee,
            "base",
            ""
        );

        pages = new Pages(block.timestamp, goo, address(0xBEEF), address(gobblers), "");

        vm.prank(address(gobblers));
        goo.mintForGobblers(address(this), type(uint128).max);

        gobblers.addGoo(1e18);

        mintPageToAddress(address(this), 9);
        mintGobblerToAddress(address(this), gobblers.LEGENDARY_AUCTION_INTERVAL());

        vm.warp(block.timestamp + 30 days);

        legendaryCost = gobblers.legendaryGobblerPrice();

        bytes32 requestId = gobblers.requestRandomSeed();
        uint256 randomness = uint256(keccak256(abi.encodePacked("seed")));
        vrfCoordinator.callBackWithRandomness(requestId, randomness, address(gobblers));
    }

    function testPagePrice() public view {
        pages.pagePrice();
    }

    function testGobblerPrice() public view {
        gobblers.gobblerPrice();
    }

    function testLegendaryGobblersPrice() public view {
        gobblers.legendaryGobblerPrice();
    }

    function testGooBalance() public view {
        gobblers.gooBalance(address(this));
    }

    function testMintPage() public {
        pages.mintFromGoo(type(uint256).max);
    }

    function testMintGobbler() public {
        gobblers.mintFromGoo(type(uint256).max);
    }

    function testBatchTransferGobblers() public {
        uint256[] memory ids = new uint256[](100);
        uint256[] memory amounts = new uint256[](100);
        for (uint256 i = 0; i < 100; i++) {
            ids[i] = i + 1;
            amounts[i] = 1;
        }

        gobblers.safeBatchTransferFrom(address(this), address(0xBEEF), ids, amounts, "");
    }

    function testAddGoo() public {
        gobblers.addGoo(1e18);
    }

    function testRemoveGoo() public {
        gobblers.removeGoo(1e18);
    }

    function testRevealGobblers() public {
        gobblers.revealGobblers(100);
    }

    function testMintLegendaryGobbler() public {
        uint256 legendaryGobblerCost = legendaryCost;

        uint256[] memory ids = new uint256[](legendaryGobblerCost);
        for (uint256 i = 0; i < legendaryGobblerCost; i++) ids[i] = i + 1;

        gobblers.mintLegendaryGobbler(ids);
    }

    function testMintReservedGobblers() public {
        gobblers.mintReservedGobblers(1);
    }

    function testMintCommunityPages() public {
        pages.mintCommunityPages(1);
    }

    function mintGobblerToAddress(address addr, uint256 num) internal {
        for (uint256 i = 0; i < num; i++) {
            vm.startPrank(address(gobblers));
            goo.mintForGobblers(addr, gobblers.gobblerPrice());
            vm.stopPrank();

            vm.prank(addr);
            gobblers.mintFromGoo(type(uint256).max);
        }
    }

    function mintPageToAddress(address addr, uint256 num) internal {
        for (uint256 i = 0; i < num; i++) {
            vm.startPrank(address(gobblers));
            goo.mintForGobblers(addr, pages.pagePrice());
            vm.stopPrank();

            vm.prank(addr);
            pages.mintFromGoo(type(uint256).max);
        }
    }
}


================================================
File: /test/Goo.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTest} from "ds-test/test.sol";
import {Utilities} from "./utils/Utilities.sol";
import {Vm} from "forge-std/Vm.sol";
import {stdError} from "forge-std/Test.sol";
import {Goo} from "../src/Goo.sol";

contract GooTest is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);
    Utilities internal utils;
    address payable[] internal users;
    Goo internal goo;

    function setUp() public {
        utils = new Utilities();
        users = utils.createUsers(5);
        goo = new Goo(address(this), users[0]);
    }

    function testMintByAuthority() public {
        uint256 initialSupply = goo.totalSupply();
        uint256 mintAmount = 100000;
        goo.mintForGobblers(address(this), mintAmount);
        uint256 finalSupply = goo.totalSupply();
        assertEq(finalSupply, initialSupply + mintAmount);
    }

    function testMintByNonAuthority() public {
        uint256 mintAmount = 100000;
        vm.prank(users[0]);
        vm.expectRevert(Goo.Unauthorized.selector);
        goo.mintForGobblers(address(this), mintAmount);
    }

    function testSetPages() public {
        goo.mintForGobblers(address(this), 1000000);
        uint256 initialSupply = goo.totalSupply();
        uint256 burnAmount = 100000;
        vm.prank(users[0]);
        goo.burnForPages(address(this), burnAmount);
        uint256 finalSupply = goo.totalSupply();
        assertEq(finalSupply, initialSupply - burnAmount);
    }

    function testBurnAllowed() public {
        uint256 mintAmount = 100000;
        goo.mintForGobblers(address(this), mintAmount);
        uint256 burnAmount = 30000;
        goo.burnForGobblers(address(this), burnAmount);
        uint256 finalBalance = goo.balanceOf(address(this));
        assertEq(finalBalance, mintAmount - burnAmount);
    }

    function testBurnNotAllowed() public {
        uint256 mintAmount = 100000;
        goo.mintForGobblers(address(this), mintAmount);
        uint256 burnAmount = 200000;
        vm.expectRevert(stdError.arithmeticError);
        goo.burnForGobblers(address(this), burnAmount);
    }
}


================================================
File: /test/ArtGobblers.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";
import {Utilities} from "./utils/Utilities.sol";
import {console} from "./utils/Console.sol";
import {Vm} from "forge-std/Vm.sol";
import {stdError} from "forge-std/Test.sol";
import {ArtGobblers} from "../src/ArtGobblers.sol";
import {Goo} from "../src/Goo.sol";
import {Pages} from "../src/Pages.sol";
import {GobblerReserve} from "../src/utils/GobblerReserve.sol";
import {LinkToken} from "./utils/mocks/LinkToken.sol";
import {VRFCoordinatorMock} from "chainlink/v0.8/mocks/VRFCoordinatorMock.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {MockERC1155} from "solmate/test/utils/mocks/MockERC1155.sol";
import {LibString} from "../src/utils/lib/LibString.sol";

/// @notice Unit test for Art Gobbler Contract.
contract ArtGobblersTest is DSTestPlus, ERC1155TokenReceiver {
    using LibString for uint256;

    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    Utilities internal utils;
    address payable[] internal users;

    ArtGobblers internal gobblers;
    VRFCoordinatorMock internal vrfCoordinator;
    LinkToken internal linkToken;
    Goo internal goo;
    Pages internal pages;
    GobblerReserve internal team;
    GobblerReserve internal community;

    bytes32 private keyHash;
    uint256 private fee;

    uint256[] ids;

    /*//////////////////////////////////////////////////////////////
                                  SETUP
    //////////////////////////////////////////////////////////////*/

    function setUp() public {
        utils = new Utilities();
        users = utils.createUsers(5);
        linkToken = new LinkToken();
        vrfCoordinator = new VRFCoordinatorMock(address(linkToken));

        team = new GobblerReserve(ArtGobblers(utils.predictContractAddress(address(this), 3)), address(this));
        community = new GobblerReserve(ArtGobblers(utils.predictContractAddress(address(this), 2)), address(this));

        goo = new Goo(
            // Gobblers:
            utils.predictContractAddress(address(this), 1),
            // Pages:
            utils.predictContractAddress(address(this), 2)
        );

        gobblers = new ArtGobblers(
            keccak256(abi.encodePacked(users[0])),
            block.timestamp,
            goo,
            address(team),
            address(community),
            address(vrfCoordinator),
            address(linkToken),
            keyHash,
            fee,
            "base",
            ""
        );

        pages = new Pages(block.timestamp, goo, address(0xBEEF), address(gobblers), "");
    }

    /*//////////////////////////////////////////////////////////////
                               MINT TESTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Test that minting from the mintlist before minting starts fails.
    function testMintFromMintlistBeforeMintingStarts() public {
        vm.warp(block.timestamp - 1);

        address user = users[0];
        bytes32[] memory proof;
        vm.prank(user);
        vm.expectRevert(ArtGobblers.MintStartPending.selector);
        gobblers.claimGobbler(proof);
    }

    /// @notice Test that you can mint from mintlist successfully.
    function testMintFromMintlist() public {
        address user = users[0];
        bytes32[] memory proof;
        vm.prank(user);
        gobblers.claimGobbler(proof);
        // verify gobbler ownership
        assertEq(gobblers.ownerOf(1), user);
    }

    /// @notice Test that minting from the mintlist twice fails.
    function testMintingFromMintlistTwiceFails() public {
        address user = users[0];
        bytes32[] memory proof;
        vm.startPrank(user);
        gobblers.claimGobbler(proof);

        vm.expectRevert(ArtGobblers.AlreadyClaimed.selector);
        gobblers.claimGobbler(proof);
    }

    /// @notice Test that an invalid mintlist proof reverts.
    function testMintNotInMintlist() public {
        bytes32[] memory proof;
        vm.expectRevert(ArtGobblers.InvalidProof.selector);
        gobblers.claimGobbler(proof);
    }

    /// @notice Test that you can successfully mint from goo.
    function testMintFromGoo() public {
        uint256 cost = gobblers.gobblerPrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(users[0], cost);
        vm.prank(users[0]);
        gobblers.mintFromGoo(type(uint256).max);
        assertEq(gobblers.ownerOf(1), users[0]);
    }

    /// @notice Test that trying to mint with insufficient balance reverts.
    function testMintInsufficientBalance() public {
        vm.prank(users[0]);
        vm.expectRevert(stdError.arithmeticError);
        gobblers.mintFromGoo(type(uint256).max);
    }

    /// @notice Test that if mint price exceeds max it reverts.
    function testMintPriceExceededMax() public {
        uint256 cost = gobblers.gobblerPrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(users[0], cost);
        vm.prank(users[0]);
        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.PriceExceededMax.selector, cost));
        gobblers.mintFromGoo(cost - 1);
    }

    /// @notice Test that initial gobbler price is what we expect.
    function testInitialGobblerPrice() public {
        uint256 cost = gobblers.gobblerPrice();
        uint256 maxDelta = 0.000000000000000070e18;
        assertApproxEq(cost, uint256(gobblers.initialPrice()), maxDelta);
    }

    /// @notice Test that minting reserved gobblers fails if there are no mints.
    function testMintReservedGobblersFailsWithNoMints() public {
        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);
        gobblers.mintReservedGobblers(1);
    }

    /// @notice Test that reserved gobblers can be minted under fair circumstances.
    function testCanMintReserved() public {
        mintGobblerToAddress(users[0], 8);

        gobblers.mintReservedGobblers(1);
        assertEq(gobblers.ownerOf(9), address(team));
        assertEq(gobblers.ownerOf(10), address(community));
    }

    /// @notice Test multiple reserved gobblers can be minted under fair circumstances.
    function testCanMintMultipleReserved() public {
        mintGobblerToAddress(users[0], 18);

        gobblers.mintReservedGobblers(2);
        assertEq(gobblers.ownerOf(19), address(team));
        assertEq(gobblers.ownerOf(20), address(team));
        assertEq(gobblers.ownerOf(21), address(community));
        assertEq(gobblers.ownerOf(22), address(community));
    }

    /// @notice Test minting reserved gobblers fails if not enough have gobblers been minted.
    function testCantMintTooFastReserved() public {
        mintGobblerToAddress(users[0], 18);

        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);
        gobblers.mintReservedGobblers(3);
    }

    /// @notice Test minting reserved gobblers fails one by one if not enough have gobblers been minted.
    function testCantMintTooFastReservedOneByOne() public {
        mintGobblerToAddress(users[0], 90);

        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);
        gobblers.mintReservedGobblers(1);

        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);
        gobblers.mintReservedGobblers(1);
    }

    /*//////////////////////////////////////////////////////////////
                              PRICING TESTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Test VRGDA behavior when selling at target rate.
    function testPricingBasic() public {
        // VRGDA targets this number of mints at given time.
        uint256 timeDelta = 120 days;
        uint256 numMint = 877;

        vm.warp(block.timestamp + timeDelta);

        for (uint256 i = 0; i < numMint; i++) {
            vm.startPrank(address(gobblers));
            uint256 price = gobblers.gobblerPrice();
            goo.mintForGobblers(users[0], price);
            vm.stopPrank();
            vm.prank(users[0]);
            gobblers.mintFromGoo(price);
        }

        uint256 initialPrice = uint256(gobblers.initialPrice());
        uint256 finalPrice = gobblers.gobblerPrice();

        // Equal within 3 percent since num mint is rounded from true decimal amount.
        assertRelApproxEq(initialPrice, finalPrice, 0.03e18);
    }

    /*//////////////////////////////////////////////////////////////
                           LEGENDARY GOBBLERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Test that attempting to mint before start time reverts.
    function testLegendaryGobblerMintBeforeStart() public {
        vm.expectRevert(stdError.arithmeticError);
        vm.prank(users[0]);
        gobblers.mintLegendaryGobbler(ids);
    }

    /// @notice Test that Legendary Gobbler initial price is what we expect.
    function testLegendaryGobblerInitialPrice() public {
        // Start of initial auction after initial interval is minted.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
        uint256 cost = gobblers.legendaryGobblerPrice();
        // Initial auction should start at a cost of 69.
        assertEq(cost, 69);
    }

    /// @notice Test that auction ends at a price of 0.
    function testLegendaryGobblerFinalPrice() public {
        // Mint 2 full intervals.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);
        uint256 cost = gobblers.legendaryGobblerPrice();
        // Auction price should be 0 after full interval decay.
        assertEq(cost, 0);
    }

    /// @notice Test that auction ends at a price of 0 even after the interval.
    function testLegendaryGobblerPastFinalPrice() public {
        // Mint 3 full intervals.
        vm.warp(block.timestamp + 600 days);
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 3);
        uint256 cost = gobblers.legendaryGobblerPrice();
        // Auction price should be 0 after full interval decay.
        assertEq(cost, 0);
    }

    /// @notice Test that mid price happens when we expect.
    function testLegendaryGobblerMidPrice() public {
        // Mint first interval and half of second interval.
        mintGobblerToAddress(users[0], (gobblers.LEGENDARY_AUCTION_INTERVAL() * 3) / 2);
        uint256 cost = gobblers.legendaryGobblerPrice();
        // Auction price should be cut by half mid way through auction.
        assertEq(cost, 34);
    }

    /// @notice Test that initial price does't fall below what we expect.
    function testLegendaryGobblerMinStartPrice() public {
        // Mint two full intervals, such that price of first auction goes to zero.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);
        // Empty id list.
        uint256[] memory _ids;
        // Mint first auction at zero cost.
        gobblers.mintLegendaryGobbler(_ids);
        // Start cost of next auction, which should equal 69.
        uint256 startCost = gobblers.legendaryGobblerPrice();
        assertEq(startCost, 69);
    }

    /// @notice Test that Legendary Gobblers can be minted.
    function testMintLegendaryGobbler() public {
        uint256 startTime = block.timestamp + 30 days;
        vm.warp(startTime);
        // Mint full interval to kick off first auction.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
        uint256 cost = gobblers.legendaryGobblerPrice();
        assertEq(cost, 69);
        setRandomnessAndReveal(cost, "seed");
        uint256 emissionMultipleSum;
        for (uint256 curId = 1; curId <= cost; curId++) {
            ids.push(curId);
            assertEq(gobblers.ownerOf(curId), users[0]);
            emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);
        }

        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum);

        vm.prank(users[0]);
        uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);

        // Legendary is owned by user.
        assertEq(gobblers.ownerOf(mintedLegendaryId), users[0]);
        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum * 2);

        assertEq(gobblers.getGobblerEmissionMultiple(mintedLegendaryId), emissionMultipleSum * 2);

        for (uint256 i = 0; i < ids.length; i++) assertEq(gobblers.ownerOf(ids[i]), address(0));
    }

    /// @notice Test that Legendary Gobblers can be minted at 0 cost.
    function testMintFreeLegendaryGobbler() public {
        uint256 startTime = block.timestamp + 30 days;
        vm.warp(startTime);

        // Mint 2 full intervals to send price to zero.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);

        uint256 cost = gobblers.legendaryGobblerPrice();
        assertEq(cost, 0);

        vm.prank(users[0]);
        uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);

        assertEq(gobblers.ownerOf(mintedLegendaryId), users[0]);
        assertEq(gobblers.getGobblerEmissionMultiple(mintedLegendaryId), 0);
    }

    /// @notice Test that Legendary Gobblers can be minted at 0 cost.
    function testMintFreeLegendaryGobblerPastInterval() public {
        uint256 startTime = block.timestamp + 30 days;
        vm.warp(startTime);

        // Mint 3 full intervals to send price to zero.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 3);

        uint256 cost = gobblers.legendaryGobblerPrice();
        assertEq(cost, 0);

        vm.prank(users[0]);
        uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);

        assertEq(gobblers.ownerOf(mintedLegendaryId), users[0]);
        assertEq(gobblers.getGobblerEmissionMultiple(mintedLegendaryId), 0);
    }

    /// @notice Test that legendary gobblers can't be minted with the wrong ids length.
    function testMintLegendaryGobblerWithWrongLength() public {
        uint256 startTime = block.timestamp + 30 days;
        vm.warp(startTime);
        // Mint full interval to kick off first auction.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
        uint256 cost = gobblers.legendaryGobblerPrice();
        assertEq(cost, 69);
        setRandomnessAndReveal(cost, "seed");
        uint256 emissionMultipleSum;
        for (uint256 curId = 1; curId <= cost; curId++) {
            ids.push(curId);
            assertEq(gobblers.ownerOf(curId), users[0]);
            emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);
        }

        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum);

        ids.push(9999999);

        vm.prank(users[0]);
        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.IncorrectGobblerAmount.selector, cost));
        gobblers.mintLegendaryGobbler(ids);
    }

    /// @notice Test that legendary gobblers can't be minted if the user doesn't own one of the ids.
    function testMintLegendaryGobblerWithUnownedId() public {
        uint256 startTime = block.timestamp + 30 days;
        vm.warp(startTime);
        // Mint full interval to kick off first auction.
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
        uint256 cost = gobblers.legendaryGobblerPrice();
        assertEq(cost, 69);
        setRandomnessAndReveal(cost, "seed");
        uint256 emissionMultipleSum;
        for (uint256 curId = 1; curId <= cost; curId++) {
            ids.push(curId);
            assertEq(gobblers.ownerOf(curId), users[0]);
            emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);
        }

        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum);

        ids.pop();
        ids.push(999);

        vm.prank(users[0]);
        vm.expectRevert("WRONG_FROM");
        gobblers.mintLegendaryGobbler(ids);
    }

    /// @notice Test that legendary gobblers have expected ids.
    function testMintLegendaryGobblersExpectedIds() public {
        // We expect the first legendary to have this id.
        uint256 nextMintLegendaryId = 9991;
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
        for (int256 i = 0; i < 10; i++) {
            vm.warp(block.timestamp + 400 days);

            mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());
            uint256 justMintedLegendaryId = gobblers.mintLegendaryGobbler(ids);
            //assert that legendaries have the expected ids
            assertEq(nextMintLegendaryId, justMintedLegendaryId);
            nextMintLegendaryId++;
        }

        // Minting any more should fail.
        vm.expectRevert(ArtGobblers.NoRemainingLegendaryGobblers.selector);
        gobblers.mintLegendaryGobbler(ids);
    }

    /// @notice Test that Legendary Gobblers can't be burned to mint another legendary.
    function testCannotMintLegendaryWithLegendary() public {
        vm.warp(block.timestamp + 30 days);

        mintNextLegendary(users[0]);
        uint256 mintedLegendaryId = gobblers.FIRST_LEGENDARY_GOBBLER_ID();
        //First legendary to be minted should be 9991
        assertEq(mintedLegendaryId, 9991);
        uint256 cost = gobblers.legendaryGobblerPrice();

        // Starting price should be 69.
        assertEq(cost, 69);
        setRandomnessAndReveal(cost, "seed");
        for (uint256 i = 1; i <= cost; i++) ids.push(i);

        ids[0] = mintedLegendaryId; // Try to pass in the legendary we just minted as well.
        vm.prank(users[0]);
        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.CannotBurnLegendary.selector, mintedLegendaryId));
        gobblers.mintLegendaryGobbler(ids);
    }

    /*//////////////////////////////////////////////////////////////
                                  URIS
    //////////////////////////////////////////////////////////////*/

    /// @notice Test unminted URI is correct.
    function testUnmintedUri() public {
        assertEq(gobblers.uri(1), "");
    }

    /// @notice Test that unrevealed URI is correct.
    function testUnrevealedUri() public {
        uint256 gobblerCost = gobblers.gobblerPrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(users[0], gobblerCost);
        vm.prank(users[0]);
        gobblers.mintFromGoo(type(uint256).max);
        // assert gobbler not revealed after mint
        assertTrue(stringEquals(gobblers.uri(1), gobblers.UNREVEALED_URI()));
    }

    /// @notice Test that revealed URI is correct.
    function testRevealedUri() public {
        mintGobblerToAddress(users[0], 1);
        // unrevealed gobblers have 0 value attributes
        assertEq(gobblers.getGobblerEmissionMultiple(1), 0);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");
        (, uint48 expectedIndex, ) = gobblers.getGobblerData(1);
        string memory expectedURI = string(abi.encodePacked(gobblers.BASE_URI(), uint256(expectedIndex).toString()));
        assertTrue(stringEquals(gobblers.uri(1), expectedURI));
    }

    /// @notice Test that legendary gobbler URI is correct.
    function testMintedLegendaryURI() public {
        //mint legendary for free
        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);
        uint256 currentLegendaryId = gobblers.mintLegendaryGobbler(ids);

        //expected URI should not be shuffled
        string memory expectedURI = string(
            abi.encodePacked(gobblers.BASE_URI(), uint256(currentLegendaryId).toString())
        );
        string memory actualURI = gobblers.uri(currentLegendaryId);
        assertTrue(stringEquals(actualURI, expectedURI));
    }

    /// @notice Test that un-minted legendary gobbler URI is correct.
    function testUnmintedLegendaryUri() public {
        (, uint128 numSold) = gobblers.legendaryGobblerAuctionData();

        assertEq(gobblers.uri(gobblers.FIRST_LEGENDARY_GOBBLER_ID()), "");
        assertEq(gobblers.uri(gobblers.FIRST_LEGENDARY_GOBBLER_ID() + 1), "");
    }

    /*//////////////////////////////////////////////////////////////
                                 REVEALS
    //////////////////////////////////////////////////////////////*/

    function testDoesNotAllowRevealingZero() public {
        vm.warp(block.timestamp + 24 hours);
        vm.expectRevert(ArtGobblers.ZeroToBeRevealed.selector);
        gobblers.requestRandomSeed();
    }

    /// @notice Cannot request random seed before 24 hours have passed from initial mint.
    function testRevealDelayInitialMint() public {
        mintGobblerToAddress(users[0], 1);
        vm.expectRevert(ArtGobblers.RequestTooEarly.selector);
        gobblers.requestRandomSeed();
    }

    /// @notice Cannot reveal more gobblers than remaining to be revealed.
    function testCannotRevealMoreGobblersThanRemainingToBeRevealed() public {
        mintGobblerToAddress(users[0], 1);

        vm.warp(block.timestamp + 24 hours);

        bytes32 requestId = gobblers.requestRandomSeed();
        uint256 randomness = uint256(keccak256(abi.encodePacked("seed")));
        vrfCoordinator.callBackWithRandomness(requestId, randomness, address(gobblers));

        mintGobblerToAddress(users[0], 2);

        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.NotEnoughRemainingToBeRevealed.selector, 1));
        gobblers.revealGobblers(2);
    }

    /// @notice Cannot request random seed before 24 hours have passed from last reveal,
    function testRevealDelayRecurring() public {
        // Mint and reveal first gobbler
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");
        // Attempt reveal before 24 hours have passed
        mintGobblerToAddress(users[0], 1);
        vm.expectRevert(ArtGobblers.RequestTooEarly.selector);
        gobblers.requestRandomSeed();
    }

    /// @notice Test that seed can't be set without first revealing pending gobblers.
    function testCantSetRandomSeedWithoutRevealing() public {
        mintGobblerToAddress(users[0], 2);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");
        vm.warp(block.timestamp + 1 days);
        // should fail since there is one remaining gobbler to be revealed with seed
        vm.expectRevert(ArtGobblers.RevealsPending.selector);
        setRandomnessAndReveal(1, "seed");
    }

    /// @notice Test that revevals work as expected
    function testMultiReveal() public {
        mintGobblerToAddress(users[0], 100);
        // first 100 gobblers should be unrevealed
        for (uint256 i = 1; i <= 100; i++) {
            assertEq(gobblers.uri(i), gobblers.UNREVEALED_URI());
        }

        vm.warp(block.timestamp + 1 days); // can only reveal every 24 hours

        setRandomnessAndReveal(50, "seed");
        // first 50 gobblers should now be revealed
        for (uint256 i = 1; i <= 50; i++) {
            assertTrue(!stringEquals(gobblers.uri(i), gobblers.UNREVEALED_URI()));
        }
        // and next 50 should remain unrevealed
        for (uint256 i = 51; i <= 100; i++) {
            assertTrue(stringEquals(gobblers.uri(i), gobblers.UNREVEALED_URI()));
        }
    }

    function testCannotReuseSeedForReveal() public {
        // first mint and reveal.
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");
        // seed used for first reveal.
        (uint64 firstSeed, , , , ) = gobblers.gobblerRevealsData();
        // second mint.
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        gobblers.requestRandomSeed();
        // seed we want to use for second reveal.
        (uint64 secondSeed, , , , ) = gobblers.gobblerRevealsData();
        // verify that we are trying to use the same seed.
        assertEq(firstSeed, secondSeed);
        // try to reveal with same seed, which should fail.
        vm.expectRevert(ArtGobblers.SeedPending.selector);
        gobblers.revealGobblers(1);
        assertTrue(true);
    }

    /*//////////////////////////////////////////////////////////////
                                  GOO
    //////////////////////////////////////////////////////////////*/

    /// @notice test that goo balance grows as expected.
    function testSimpleRewards() public {
        mintGobblerToAddress(users[0], 1);
        // balance should initially be zero
        assertEq(gobblers.gooBalance(users[0]), 0);
        vm.warp(block.timestamp + 100000);
        // balance should be zero while no reveal
        assertEq(gobblers.gooBalance(users[0]), 0);
        setRandomnessAndReveal(1, "seed");
        // balance should NOT grow on same timestamp after reveal
        assertEq(gobblers.gooBalance(users[0]), 0);
        vm.warp(block.timestamp + 100000);
        // balance should grow after reveal
        assertGt(gobblers.gooBalance(users[0]), 0);
    }

    /// @notice Test that goo removal works as expected.
    function testGooRemoval() public {
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");
        vm.warp(block.timestamp + 100000);
        uint256 initialBalance = gobblers.gooBalance(users[0]);
        uint256 removalAmount = initialBalance / 10; //10%
        vm.prank(users[0]);
        gobblers.removeGoo(removalAmount);
        uint256 finalBalance = gobblers.gooBalance(users[0]);
        // balance should change
        assertTrue(initialBalance != finalBalance);
        assertEq(initialBalance, finalBalance + removalAmount);
        // user should have removed goo
        assertEq(goo.balanceOf(users[0]), removalAmount);
    }

    /// @notice Test that goo can't be removed by a different user.
    function testCantRemoveGoo() public {
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 100000);
        setRandomnessAndReveal(1, "seed");
        vm.prank(users[1]);
        vm.expectRevert(stdError.arithmeticError);
        gobblers.removeGoo(1);
    }

    /// @notice Test that adding goo is reflected in balance.
    function testGooAddition() public {
        mintGobblerToAddress(users[0], 1);
        assertEq(gobblers.getGobblerEmissionMultiple(1), 0);
        assertEq(gobblers.getUserEmissionMultiple(users[0]), 0);
        // waiting after mint to reveal shouldn't affect balance
        vm.warp(block.timestamp + 100000);
        assertEq(gobblers.gooBalance(users[0]), 0);
        setRandomnessAndReveal(1, "seed");
        uint256 gobblerMultiple = gobblers.getGobblerEmissionMultiple(1);
        assertGt(gobblerMultiple, 0);
        assertEq(gobblers.getUserEmissionMultiple(users[0]), gobblerMultiple);
        vm.prank(address(gobblers));
        uint256 additionAmount = 1000;
        goo.mintForGobblers(users[0], additionAmount);
        vm.prank(users[0]);
        gobblers.addGoo(additionAmount);
        assertEq(gobblers.gooBalance(users[0]), additionAmount);
    }

    /// @notice Test that emission multiple changes as expected after transfer.
    function testEmissionMultipleUpdatesAfterTransfer() public {
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");

        uint256 initialUserMultiple = gobblers.getUserEmissionMultiple(users[0]);
        assertGt(initialUserMultiple, 0);
        assertEq(gobblers.getUserEmissionMultiple(users[1]), 0);

        vm.prank(users[0]);
        gobblers.safeTransferFrom(users[0], users[1], 1, 1, "");

        assertEq(gobblers.getUserEmissionMultiple(users[0]), 0);
        assertEq(gobblers.getUserEmissionMultiple(users[1]), initialUserMultiple);
    }

    /// @notice Test that gobbler balances are accurate after transfer.
    function testGobblerBalancesAfterTransfer() public {
        mintGobblerToAddress(users[0], 1);
        vm.warp(block.timestamp + 1 days);
        setRandomnessAndReveal(1, "seed");

        vm.warp(block.timestamp + 1000000);

        uint256 userOneBalance = gobblers.gooBalance(users[0]);
        uint256 userTwoBalance = gobblers.gooBalance(users[1]);
        //user with gobbler should have non-zero balance
        assertGt(userOneBalance, 0);
        //other user should have zero balance
        assertEq(userTwoBalance, 0);
        //transfer gobblers
        vm.prank(users[0]);
        gobblers.safeTransferFrom(users[0], users[1], 1, 1, "");
        //balance should not change after transfer
        assertEq(gobblers.gooBalance(users[0]), userOneBalance);
        assertEq(gobblers.gooBalance(users[1]), userTwoBalance);
    }

    /*//////////////////////////////////////////////////////////////
                               FEEDING ART
    //////////////////////////////////////////////////////////////*/

    /// @notice Test that pages can be fed to gobblers.
    function testFeedingArt() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        uint256 pagePrice = pages.pagePrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(user, pagePrice);
        vm.startPrank(user);
        pages.mintFromGoo(type(uint256).max);
        gobblers.feedArt(1, address(pages), 1, false);
        vm.stopPrank();
        assertEq(gobblers.getCopiesOfArtFedToGobbler(1, address(pages), 1), 1);
    }

    /// @notice Test that you can't feed art to gobblers you don't own.
    function testCantFeedArtToUnownedGobbler() public {
        address user = users[0];
        uint256 pagePrice = pages.pagePrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(user, pagePrice);
        vm.startPrank(user);
        pages.mintFromGoo(type(uint256).max);
        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.OwnerMismatch.selector, address(0)));
        gobblers.feedArt(1, address(pages), 1, false);
        vm.stopPrank();
    }

    /// @notice Test that you can't feed art you don't own to your gobbler.
    function testCantFeedUnownedArt() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        vm.startPrank(user);
        vm.expectRevert("WRONG_FROM");
        gobblers.feedArt(1, address(pages), 1, false);
        vm.stopPrank();
    }

    function testCantFeed721As1155() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        uint256 pagePrice = pages.pagePrice();
        vm.prank(address(gobblers));
        goo.mintForGobblers(user, pagePrice);
        vm.startPrank(user);
        pages.mintFromGoo(type(uint256).max);
        vm.expectRevert();
        gobblers.feedArt(1, address(pages), 1, true);
    }

    function testFeeding1155() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        MockERC1155 token = new MockERC1155();
        token.mint(user, 0, 1, "");
        vm.startPrank(user);
        token.setApprovalForAll(address(gobblers), true);
        gobblers.feedArt(1, address(token), 0, true);
        vm.stopPrank();
        assertEq(gobblers.getCopiesOfArtFedToGobbler(1, address(token), 0), 1);
    }

    function testFeedingMultiple1155Copies() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        MockERC1155 token = new MockERC1155();
        token.mint(user, 0, 5, "");
        vm.startPrank(user);
        token.setApprovalForAll(address(gobblers), true);
        gobblers.feedArt(1, address(token), 0, true);
        gobblers.feedArt(1, address(token), 0, true);
        gobblers.feedArt(1, address(token), 0, true);
        gobblers.feedArt(1, address(token), 0, true);
        gobblers.feedArt(1, address(token), 0, true);
        vm.stopPrank();
        assertEq(gobblers.getCopiesOfArtFedToGobbler(1, address(token), 0), 5);
    }

    function testCantFeed1155As721() public {
        address user = users[0];
        mintGobblerToAddress(user, 1);
        MockERC1155 token = new MockERC1155();
        token.mint(user, 0, 1, "");
        vm.startPrank(user);
        token.setApprovalForAll(address(gobblers), true);
        vm.expectRevert();
        gobblers.feedArt(1, address(token), 0, false);
    }

    /*//////////////////////////////////////////////////////////////
                           LONG-RUNNING TESTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Check that max supply is mintable
    function testLongRunningMintMaxFromGoo() public {
        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();

        for (uint256 i = 0; i < maxMintableWithGoo; i++) {
            vm.warp(block.timestamp + 1 days);
            uint256 cost = gobblers.gobblerPrice();
            vm.prank(address(gobblers));
            goo.mintForGobblers(users[0], cost);
            vm.prank(users[0]);
            gobblers.mintFromGoo(type(uint256).max);
        }
    }

    /// @notice Check that minting beyond max supply should revert.
    function testLongRunningMintMaxFromGooRevert() public {
        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();

        for (uint256 i = 0; i < maxMintableWithGoo + 1; i++) {
            vm.warp(block.timestamp + 1 days);

            if (i == maxMintableWithGoo) vm.expectRevert("UNDEFINED");
            uint256 cost = gobblers.gobblerPrice();

            vm.prank(address(gobblers));
            goo.mintForGobblers(users[0], cost);
            vm.prank(users[0]);

            if (i == maxMintableWithGoo) vm.expectRevert("UNDEFINED");
            gobblers.mintFromGoo(type(uint256).max);
        }
    }

    /// @notice Check that max reserved supplies are mintable.
    function testLongRunningMintMaxReserved() public {
        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();

        for (uint256 i = 0; i < maxMintableWithGoo; i++) {
            vm.warp(block.timestamp + 1 days);
            uint256 cost = gobblers.gobblerPrice();
            vm.prank(address(gobblers));
            goo.mintForGobblers(users[0], cost);
            vm.prank(users[0]);
            gobblers.mintFromGoo(type(uint256).max);
        }

        gobblers.mintReservedGobblers(gobblers.RESERVED_SUPPLY() / 2);
    }

    /// @notice Check that minting reserves beyond their max supply reverts.
    function testLongRunningMintMaxTeamRevert() public {
        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();

        for (uint256 i = 0; i < maxMintableWithGoo; i++) {
            vm.warp(block.timestamp + 1 days);
            uint256 cost = gobblers.gobblerPrice();
            vm.prank(address(gobblers));
            goo.mintForGobblers(users[0], cost);
            vm.prank(users[0]);
            gobblers.mintFromGoo(type(uint256).max);
        }

        gobblers.mintReservedGobblers(gobblers.RESERVED_SUPPLY() / 2);

        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);
        gobblers.mintReservedGobblers(1);
    }

    /*//////////////////////////////////////////////////////////////
                                 HELPERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a number of gobblers to the given address
    function mintGobblerToAddress(address addr, uint256 num) internal {
        for (uint256 i = 0; i < num; i++) {
            vm.startPrank(address(gobblers));
            goo.mintForGobblers(addr, gobblers.gobblerPrice());
            vm.stopPrank();

            vm.prank(addr);
            gobblers.mintFromGoo(type(uint256).max);
        }
    }

    /// @notice Call back vrf with randomness and reveal gobblers.
    function setRandomnessAndReveal(uint256 numReveal, string memory seed) internal {
        bytes32 requestId = gobblers.requestRandomSeed();
        uint256 randomness = uint256(keccak256(abi.encodePacked(seed)));
        // call back from coordinator
        vrfCoordinator.callBackWithRandomness(requestId, randomness, address(gobblers));
        gobblers.revealGobblers(numReveal);
    }

    /// @notice Check for string equality.
    function stringEquals(string memory s1, string memory s2) internal pure returns (bool) {
        return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));
    }

    function mintNextLegendary(address addr) internal {
        uint256[] memory id;
        mintGobblerToAddress(addr, gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);
        vm.prank(addr);
        gobblers.mintLegendaryGobbler(id);
    }
}


================================================
File: /test/utils/LibRLP.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {Bytes32AddressLib} from "solmate/utils/Bytes32AddressLib.sol";

library LibRLP {
    using Bytes32AddressLib for bytes32;

    // prettier-ignore
    function computeAddress(address deployer, uint256 nonce) internal pure returns (address) {
        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.
        // A one byte integer uses its own value as its length prefix, there is no additional "0x80 + length" prefix that comes before it.
        if (nonce == 0x00)             return keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))).fromLast20Bytes();
        if (nonce <= 0x7f)             return keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))).fromLast20Bytes();

        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.
        if (nonce <= type(uint8).max)  return keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))).fromLast20Bytes();
        if (nonce <= type(uint16).max) return keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))).fromLast20Bytes();
        if (nonce <= type(uint24).max) return keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))).fromLast20Bytes();

        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp
        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)
        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)
        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)
        // We assume nobody can have a nonce large enough to require more than 32 bytes.
        return keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))).fromLast20Bytes();
    }
}


================================================
File: /test/utils/mocks/MockGooCalculator.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol";

contract MockGooCalculator {
    using FixedPointMathLib for uint256;

    /// @notice Compute goo balance based on emission multiple, last balance, and days elapsed.
    /// @dev Must be kept up to date with the gooBalance function's corresponding emission balance calculations in ArtGobblers.sol.
    /// @dev Forked from https://github.com/artgobblers/art-gobblers/blob/2f19bc901ed2f1bfedeb6f113b073bfc3585386a/src/ArtGobblers.sol#L693-L708
    function computeGooBalance(
        uint256 emissionMultiple,
        uint256 lastBalanceWad,
        uint256 daysElapsedWad
    ) public pure returns (uint256) {
        unchecked {
            uint256 daysElapsedSquaredWad = daysElapsedWad.mulWadDown(daysElapsedWad); // Need to use wad math here.

            // prettier-ignore
            return lastBalanceWad + // The last recorded balance.

            // Don't need to do wad multiplication since we're
            // multiplying by a plain integer with no decimals.
            // Shift right by 2 is equivalent to division by 4.
            ((emissionMultiple * daysElapsedSquaredWad) >> 2) +

            daysElapsedWad.mulWadDown( // Terms are wads, so must mulWad.
                // No wad multiplication for emissionMultiple * lastBalance
                // because emissionMultiple is a plain integer with no decimals.
                // We multiply the sqrt's radicand by 1e18 because it expects ints.
                (emissionMultiple * lastBalanceWad * 1e18).sqrt()
            );
        }
    }
}


================================================
File: /test/utils/mocks/LinkToken.sol
================================================
// SPDX-License-Identifier: MIT

// adapter from dapptools-starter-kit
pragma solidity ^0.8.0;

import {ERC20} from "solmate/tokens/ERC20.sol";

interface ERC677Receiver {
    function onTokenTransfer(
        address _sender,
        uint256 _value,
        bytes memory _data
    ) external;
}

contract LinkToken is ERC20 {
    uint256 initialSupply = 1000000000000000000000000;

    constructor() ERC20("LinkToken", "LINK", 18) {
        _mint(msg.sender, initialSupply);
    }

    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    /**
     * @dev transfer token to a contract address with additional data if the recipient is a contact.
     * @param _to The address to transfer to.
     * @param _value The amount to be transferred.
     * @param _data The extra data to be passed to the receiving contract.
     */
    function transferAndCall(
        address _to,
        uint256 _value,
        bytes memory _data
    ) public virtual returns (bool success) {
        super.transfer(_to, _value);
        // emit Transfer(msg.sender, _to, _value, _data);
        emit Transfer(msg.sender, _to, _value, _data);
        if (isContract(_to)) {
            contractFallback(_to, _value, _data);
        }
        return true;
    }

    // PRIVATE

    function contractFallback(
        address _to,
        uint256 _value,
        bytes memory _data
    ) private {
        ERC677Receiver receiver = ERC677Receiver(_to);
        receiver.onTokenTransfer(msg.sender, _value, _data);
    }

    function isContract(address _addr) private view returns (bool hasCode) {
        uint256 length;
        assembly {
            length := extcodesize(_addr)
        }
        return length > 0;
    }
}


================================================
File: /test/utils/Utilities.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTest} from "ds-test/test.sol";
import {Vm} from "forge-std/Vm.sol";

import {LibRLP} from "./LibRLP.sol";

// common utilities for forge tests
contract Utilities is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);
    bytes32 internal nextUser = keccak256(abi.encodePacked("user address"));

    function getNextUserAddress() external returns (address payable) {
        // bytes32 to address conversion
        address payable user = payable(address(uint160(uint256(nextUser))));
        nextUser = keccak256(abi.encodePacked(nextUser));
        return user;
    }

    // create users with 100 ether balance
    function createUsers(uint256 userNum) external returns (address payable[] memory) {
        address payable[] memory users = new address payable[](userNum);
        for (uint256 i = 0; i < userNum; i++) {
            address payable user = this.getNextUserAddress();
            vm.deal(user, 100 ether);
            users[i] = user;
        }
        return users;
    }

    // move block.number forward by a given number of blocks
    function mineBlocks(uint256 numBlocks) external {
        uint256 targetBlock = block.number + numBlocks;
        vm.roll(targetBlock);
    }

    function predictContractAddress(address user, uint256 distanceFromCurrentNonce) external returns (address) {
        return LibRLP.computeAddress(user, vm.getNonce(user) + distanceFromCurrentNonce);
    }
}


================================================
File: /test/VRGDAs.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DSTestPlus} from "solmate/test/utils/DSTestPlus.sol";
import {Utilities} from "./utils/Utilities.sol";
import {console} from "./utils/Console.sol";
import {Vm} from "forge-std/Vm.sol";
import {ArtGobblers} from "../src/ArtGobblers.sol";
import {Goo} from "../src/Goo.sol";
import {Pages} from "../src/Pages.sol";
import {LinkToken} from "./utils/mocks/LinkToken.sol";
import {VRFCoordinatorMock} from "chainlink/v0.8/mocks/VRFCoordinatorMock.sol";

contract VRGDAsTest is DSTestPlus {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    uint256 constant ONE_THOUSAND_YEARS = 356 days * 1000;

    Utilities internal utils;
    address payable[] internal users;

    ArtGobblers private gobblers;
    VRFCoordinatorMock private vrfCoordinator;
    LinkToken private linkToken;

    Goo goo;
    Pages pages;

    bytes32 private keyHash;
    uint256 private fee;

    function setUp() public {
        utils = new Utilities();
        users = utils.createUsers(5);
        linkToken = new LinkToken();
        vrfCoordinator = new VRFCoordinatorMock(address(linkToken));

        goo = new Goo(
            // Gobblers:
            utils.predictContractAddress(address(this), 1),
            // Pages:
            utils.predictContractAddress(address(this), 2)
        );

        gobblers = new ArtGobblers(
            "root",
            block.timestamp,
            goo,
            address(0xBEEF),
            address(0xBEEF),
            address(vrfCoordinator),
            address(linkToken),
            keyHash,
            fee,
            "base",
            ""
        );

        pages = new Pages(block.timestamp, goo, address(0xBEEF), address(gobblers), "");
    }

    // function testFindGobblerOverflowPoint() public view {
    //     uint256 sold;
    //     while (true) {
    //         gobblers.getPrice(0 days, sold++);
    //     }
    // }

    // function testFindPagesOverflowPoint() public view {
    //     uint256 sold;
    //     while (true) {
    //         pages.getPrice(0 days, sold++);
    //     }
    // }

    function testNoOverflowForMostGobblers(uint256 timeSinceStart, uint256 sold) public {
        gobblers.getPrice(bound(timeSinceStart, 0 days, ONE_THOUSAND_YEARS), bound(sold, 0, 1731));
    }

    function testNoOverflowForAllGobblers(uint256 timeSinceStart, uint256 sold) public {
        gobblers.getPrice(bound(timeSinceStart, 3870 days, ONE_THOUSAND_YEARS), bound(sold, 0, 6391));
    }

    function testFailOverflowForBeyondLimitGobblers(uint256 timeSinceStart, uint256 sold) public {
        gobblers.getPrice(bound(timeSinceStart, 0 days, ONE_THOUSAND_YEARS), bound(sold, 6392, type(uint128).max));
    }

    function testGobblerPriceStrictlyIncreasesForMostGobblers() public {
        uint256 sold;
        uint256 previousPrice;

        while (sold <= 1731) {
            uint256 price = gobblers.getPrice(0 days, sold++);
            assertGt(price, previousPrice);
            previousPrice = price;
        }
    }

    function testNoOverflowForFirst8465Pages(uint256 timeSinceStart, uint256 sold) public {
        pages.getPrice(bound(timeSinceStart, 0 days, ONE_THOUSAND_YEARS), bound(sold, 0, 8465));
    }

    function testPagePriceStrictlyIncreasesFor8465Pages() public {
        uint256 sold;
        uint256 previousPrice;

        while (sold <= 8465) {
            uint256 price = pages.getPrice(0 days, sold++);
            assertGt(price, previousPrice);
            previousPrice = price;
        }
    }
}


================================================
File: /.gitmodules
================================================
[submodule "lib/ds-test"]
	path = lib/ds-test
	url = https://github.com/dapphub/ds-test
[submodule "lib/solmate"]
	path = lib/solmate
	url = https://github.com/Rari-Capital/solmate
[submodule "lib/forge-std"]
	path = lib/forge-std
	url = https://github.com/brockelmore/forge-std
[submodule "lib/chainlink"]
	path = lib/chainlink
	url = https://github.com/smartcontractkit/chainlink


================================================
File: /script/deploy/DeployRinkeby.s.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {DeployBase} from "./DeployBase.s.sol";

contract DeployRinkeby is DeployBase {
    address public immutable coldWallet = 0x126620598A797e6D9d2C280b5dB91b46F27A8330;

    address public immutable root = 0x1D18077167c1177253555e45B4b5448B11E30b4b;

    uint256 public immutable mintStart = 1656369768;

    string public constant gobblerBaseUri = "https://testnet.ag.xyz/api/nfts/gobblers/";
    string public constant gobblerUnrevealedUri = "https://testnet.ag.xyz/api/nfts/unrevealed";
    string public constant pagesBaseUri = "https://testnet.ag.xyz/api/nfts/pages/";

    constructor()
        DeployBase(
            // Team cold wallet:
            coldWallet,
            // Merkle root:
            keccak256(abi.encodePacked(root)),
            // Mint start:
            mintStart,
            // VRF coordinator:
            address(0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B),
            // LINK token:
            address(0x01BE23585060835E02B77ef475b0Cc51aA1e0709),
            // Chainlink hash:
            0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311,
            // Chainlink fee:
            0.1e18,
            // Gobbler base URI:
            gobblerBaseUri,
            // Gobbler unrevealed URI:
            gobblerUnrevealedUri,
            // Pages base URI:
            pagesBaseUri
        )
    {}
}


================================================
File: /script/deploy/DeployBase.s.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import "forge-std/Script.sol";

import {LibRLP} from "../../test/utils/LibRLP.sol";

import {GobblerReserve} from "../../src/utils/GobblerReserve.sol";

import {Goo} from "../../src/Goo.sol";
import {Pages} from "../../src/Pages.sol";
import {ArtGobblers} from "../../src/ArtGobblers.sol";

abstract contract DeployBase is Script {
    // Environment specific variables.
    address private immutable teamColdWallet;
    bytes32 private immutable merkleRoot;
    uint256 private immutable mintStart;
    address private immutable vrfCoordinator;
    address private immutable linkToken;
    bytes32 private immutable chainlinkKeyHash;
    uint256 private immutable chainlinkFee;
    string private gobblerBaseUri;
    string private gobblerUnrevealedUri;
    string private pagesBaseUri;

    // Deploy addresses.
    GobblerReserve public teamReserve;
    GobblerReserve public communityReserve;
    Goo public goo;
    ArtGobblers public artGobblers;
    Pages public pages;

    constructor(
        address _teamColdWallet,
        bytes32 _merkleRoot,
        uint256 _mintStart,
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _chainlinkKeyHash,
        uint256 _chainlinkFee,
        string memory _gobblerBaseUri,
        string memory _gobblerUnrevealedUri,
        string memory _pagesBaseUri
    ) {
        teamColdWallet = _teamColdWallet;
        merkleRoot = _merkleRoot;
        mintStart = _mintStart;
        vrfCoordinator = _vrfCoordinator;
        linkToken = _linkToken;
        chainlinkKeyHash = _chainlinkKeyHash;
        chainlinkFee = _chainlinkFee;
        gobblerBaseUri = _gobblerBaseUri;
        gobblerUnrevealedUri = _gobblerUnrevealedUri;
        pagesBaseUri = _pagesBaseUri;
    }

    function run() external {
        vm.startBroadcast();

        // Precomputed contract addresses, based on contract deploy nonces.
        // tx.origin is the address who will actually broadcast the contract creations below.
        address gobblerAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 3);
        address pageAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 4);

        // Deploy team and community reserves, owned by cold wallet.
        teamReserve = new GobblerReserve(ArtGobblers(gobblerAddress), teamColdWallet);
        communityReserve = new GobblerReserve(ArtGobblers(gobblerAddress), teamColdWallet);

        // Deploy goo contract.
        goo = new Goo(
            // Gobblers contract address:
            gobblerAddress,
            // Pages contract address:
            pageAddress
        );

        // Deploy gobblers contract,
        artGobblers = new ArtGobblers(
            merkleRoot,
            mintStart,
            goo,
            address(teamReserve),
            address(communityReserve),
            vrfCoordinator,
            linkToken,
            chainlinkKeyHash,
            chainlinkFee,
            gobblerBaseUri,
            gobblerUnrevealedUri
        );

        // Deploy pages contract.
        pages = new Pages(mintStart, goo, teamColdWallet, gobblerAddress, pagesBaseUri);

        vm.stopBroadcast();
    }
}


================================================
File: /foundry.toml
================================================
[default]
solc = "0.8.13"
optimizer_runs = 1000000
bytecode_hash = "none"
no_match_test = "FFI|LongRunning"

[intense]
fuzz_runs = 10000
no_match_test = "FFI"

[ffi]
ffi = true
no_match_test = "LongRunning"


================================================
File: /package.json
================================================
{
  "name": "art-gobblers",
  "author": "artgobblers",
  "version": "1.0.0",
  "description": "Art Gobblers scan the cosmos in search of art producing life.",
  "homepage": "https://github.com/FrankieIsLost/art-gobblers#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/FrankieIsLost/art-gobblers.git"
  },
  "scripts": {
    "prettier": "prettier --write **.sol",
    "prettier:list": "prettier --list-different **.sol",
    "prettier:check": "prettier --check **.sol",
    "solhint": "solhint --config ./.solhint.json 'src/**/*.sol' --fix",
    "solhint:check": "solhint --config ./.solhint.json 'src/**/*.sol'",
    "lint": "npm run prettier && npm run solhint",
    "lint:check": "npm run prettier:check && npm run solhint:check"
  },
  "devDependencies": {
    "prettier": "^2.5.1",
    "prettier-plugin-solidity": "^1.0.0-beta.19",
    "solhint": "^3.3.6"
  }
}


================================================
File: /README.md
================================================
<img align="right" width="150" height="150" top="100" src="./assets/gobbler.png">

# Art Gobblers • [![CI](https://github.com/artgobblers/art-gobblers/actions/workflows/tests.yml/badge.svg)](https://github.com/artgobblers/art-gobblers/actions/workflows/CI.yml)

Art Gobblers scan the cosmos in search of art producing life.

![Gobbler Lifecycle](assets/state-machines/gobbler-lifecycle.png)
![Legendary Gobbler Auctions](assets/state-machines/legendary-gobbler-auctions.png)
![Page Auctions](assets/state-machines/page-auctions.png)

## Contributing

You will need a copy of [Foundry](https://github.com/foundry-rs/foundry) installed before proceeding. See the [installation guide](https://github.com/foundry-rs/foundry#installation) for details.

### Setup

```sh
git clone https://github.com/artgobblers/art-gobblers.git
cd art-gobblers
```

### Run Tests

```sh
forge test
```

### Update Gas Snapshots

```sh
forge snapshot
```


================================================
File: /src/Pages.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {VRGDA} from "./utils/vrgda/VRGDA.sol";
import {LibString} from "./utils/lib/LibString.sol";
import {PagesERC721} from "./utils/token/PagesERC721.sol";
import {LogisticVRGDA} from "./utils/vrgda/LogisticVRGDA.sol";
import {PostSwitchVRGDA} from "./utils/vrgda/PostSwitchVRGDA.sol";

import {Goo} from "./Goo.sol";

/// @title Pages NFT
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Pages is an ERC721 that can hold custom art.
contract Pages is PagesERC721, LogisticVRGDA, PostSwitchVRGDA {
    using LibString for uint256;

    /*//////////////////////////////////////////////////////////////
                                ADDRESSES
    //////////////////////////////////////////////////////////////*/

    /// @notice The address of the goo ERC20 token contract.
    Goo public immutable goo;

    /// @notice The address which receives pages reserved for the community.
    address public immutable community;

    /*//////////////////////////////////////////////////////////////
                                  URIS
    //////////////////////////////////////////////////////////////*/

    /// @notice Base URI for minted pages.
    string public BASE_URI;

    /*//////////////////////////////////////////////////////////////
                            VRGDA INPUT STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Timestamp for the start of the VRGDA mint.
    uint256 public immutable mintStart;

    /// @notice Id of the most recently minted page.
    /// @dev Will be 0 if no pages have been minted yet.
    uint128 public currentId;

    /*//////////////////////////////////////////////////////////////
                          COMMUNITY PAGES STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice The number of pages minted to the community reserve.
    uint128 public numMintedForCommunity;

    /*//////////////////////////////////////////////////////////////
                            PRICING CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @dev The day the switch from a logistic to translated linear VRGDA is targeted to occur.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal constant SWITCH_DAY_WAD = 270e18;

    /// @notice The minimum amount of pages that must be sold for the VRGDA issuance
    /// schedule to switch from logistic to the "post switch" translated linear formula.
    /// @dev Computed off-chain by plugging the switch day into the uninverted pacing formula.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal constant SOLD_BY_SWITCH_WAD = 8598.35810341741976233e18;

    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event PagePurchased(address indexed user, uint256 indexed pageId, uint256 price);

    event CommunityPagesMinted(address indexed user, uint256 lastMintedPageId, uint256 numPages);

    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/

    error ReserveImbalance();

    error PriceExceededMax(uint256 currentPrice);

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(
        // Mint config:
        uint256 _mintStart,
        // Addresses:
        Goo _goo,
        address _community,
        address _artGobblers,
        // URIs:
        string memory _baseUri
    )
        VRGDA(
            4.2069e18, // Initial price.
            0.31e18 // Per period price decrease.
        )
        LogisticVRGDA(
            9000e18, // Asymptote.
            0.014e18 // Time scale.
        )
        PostSwitchVRGDA(
            SOLD_BY_SWITCH_WAD, // Sold by switch.
            SWITCH_DAY_WAD, // Target switch day.
            10e18 // Pages to target per day.
        )
        PagesERC721(_artGobblers, "Pages", "PAGE")
    {
        mintStart = _mintStart;

        goo = _goo;

        community = _community;

        BASE_URI = _baseUri;
    }

    /*//////////////////////////////////////////////////////////////
                              MINTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a page with goo, burning the cost.
    /// @param maxPrice Maximum price to pay to mint the page.
    /// @return pageId The id of the page that was minted.
    function mintFromGoo(uint256 maxPrice) external returns (uint256 pageId) {
        // Will revert if prior to mint start.
        uint256 currentPrice = pagePrice();

        // If the current price is above the user's specified max, revert.
        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);

        goo.burnForPages(msg.sender, currentPrice);

        unchecked {
            emit PagePurchased(msg.sender, pageId = ++currentId, currentPrice);

            _mint(msg.sender, pageId);
        }
    }

    /// @notice Calculate the mint cost of a page.
    /// @dev If the number of sales is below a pre-defined threshold, we use the
    /// VRGDA pricing algorithm, otherwise we use the post-switch pricing formula.
    /// @dev Reverts due to underflow if minting hasn't started yet. Done to save gas.
    function pagePrice() public view returns (uint256) {
        // We need checked math here to cause overflow
        // before minting has begun, preventing mints.
        uint256 timeSinceStart = block.timestamp - mintStart;

        unchecked {
            // The number of pages minted for the community reserve
            // cannot ever exceed 10% of the total supply of pages.
            return getPrice(timeSinceStart, currentId - numMintedForCommunity);
        }
    }

    function getTargetDayForNextSale(int256 tokens)
        internal
        view
        override(LogisticVRGDA, PostSwitchVRGDA)
        returns (int256)
    {
        return
            tokens < SOLD_BY_SWITCH_WAD
                ? LogisticVRGDA.getTargetDayForNextSale(tokens)
                : PostSwitchVRGDA.getTargetDayForNextSale(tokens);
    }

    /*//////////////////////////////////////////////////////////////
                      COMMUNITY PAGES MINTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a number of pages to the community reserve.
    /// @param numPages The number of pages to mint to the reserve.
    /// @dev Pages minted to the reserve cannot compromise more than 10% of the sum of the
    /// supply of goo minted pages and the supply of pages minted to the community reserve.
    function mintCommunityPages(uint256 numPages) external returns (uint256 lastMintedPageId) {
        unchecked {
            // Optimistically increment numMintedForCommunity, may be reverted below.
            // Overflow in this calculation is possible but numPages would have to
            // be so large that it would cause the loop to run out of gas quickly.
            uint256 newNumMintedForCommunity = numMintedForCommunity += uint128(numPages);

            // Ensure that after this mint pages minted to the community reserve won't compromise more than
            // 10% of the new total page supply. currentId is equivalent to the current total supply of pages.
            if (newNumMintedForCommunity > ((lastMintedPageId = currentId) + numPages) / 10) revert ReserveImbalance();

            // Mint the pages to the community reserve while updating lastMintedPageId.
            for (uint256 i = 0; i < numPages; i++) _mint(community, ++lastMintedPageId);

            currentId = uint128(lastMintedPageId); // Update currentId with the last minted page id.

            emit CommunityPagesMinted(msg.sender, lastMintedPageId, numPages);
        }
    }

    /*//////////////////////////////////////////////////////////////
                             TOKEN URI LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Returns a pages's URI if it has been minted.
    /// @param pageId The id of the page to get the URI for.
    function tokenURI(uint256 pageId) public view virtual override returns (string memory) {
        if (pageId > currentId) return "";

        return string(abi.encodePacked(BASE_URI, pageId.toString()));
    }
}


================================================
File: /src/Goo.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {ERC20} from "solmate/tokens/ERC20.sol";

/// @title Goo Token (GOO)
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Goo is the in-game token for ArtGobblers. It's a standard ERC20
/// token that can be burned and minted by the gobblers and pages contract.
contract Goo is ERC20("Goo", "GOO", 18) {
    /*//////////////////////////////////////////////////////////////
                                ADDRESSES
    //////////////////////////////////////////////////////////////*/

    /// @notice The address of the Art Gobblers contract.
    address public immutable artGobblers;

    /// @notice The address of the Pages contract.
    address public immutable pages;

    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/

    error Unauthorized();

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(address _artGobblers, address _pages) {
        artGobblers = _artGobblers;
        pages = _pages;
    }

    /*//////////////////////////////////////////////////////////////
                             MINT/BURN LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Requires caller address to match user address.
    modifier only(address user) {
        if (msg.sender != user) revert Unauthorized();

        _;
    }

    /// @notice Mint any amount of goo to a user. Can only be called by ArtGobblers.
    /// @param to The address of the user to mint goo to.
    /// @param amount The amount of goo to mint.
    function mintForGobblers(address to, uint256 amount) public only(artGobblers) {
        _mint(to, amount);
    }

    /// @notice Burn any amount of goo from a user. Can only be called by ArtGobblers.
    /// @param from The address of the user to burn goo from.
    /// @param amount The amount of goo to burn.
    function burnForGobblers(address from, uint256 amount) public only(artGobblers) {
        _burn(from, amount);
    }

    /// @notice Burn any amount of goo from a user. Can only be called by Pages.
    /// @param from The address of the user to burn goo from.
    /// @param amount The amount of goo to burn.
    function burnForPages(address from, uint256 amount) public only(pages) {
        _burn(from, amount);
    }
}


================================================
File: /src/ArtGobblers.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {Owned} from "solmate/auth/Owned.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol";
import {ERC1155, ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";

import {VRFConsumerBase} from "chainlink/v0.8/VRFConsumerBase.sol";

import {VRGDA} from "./utils/vrgda/VRGDA.sol";
import {LibString} from "./utils/lib/LibString.sol";
import {LogisticVRGDA} from "./utils/vrgda/LogisticVRGDA.sol";
import {MerkleProofLib} from "./utils/lib/MerkleProofLib.sol";
import {GobblersERC1155B} from "./utils/token/GobblersERC1155B.sol";

import {Goo} from "./Goo.sol";

/// @title Art Gobblers NFT
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Art Gobblers scan the cosmos in search of art producing life.
contract ArtGobblers is GobblersERC1155B, LogisticVRGDA, VRFConsumerBase, Owned, ERC1155TokenReceiver {
    using LibString for uint256;
    using FixedPointMathLib for uint256;

    /*//////////////////////////////////////////////////////////////
                                ADDRESSES
    //////////////////////////////////////////////////////////////*/

    /// @notice The address of the Goo ERC20 token contract.
    Goo public immutable goo;

    /// @notice The address which receives gobblers reserved for the team.
    address public immutable team;

    /// @notice The address which receives gobblers reserved for the community.
    address public immutable community;

    /*//////////////////////////////////////////////////////////////
                            SUPPLY CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Maximum number of mintable gobblers.
    uint256 public constant MAX_SUPPLY = 10000;

    /// @notice Maximum amount of gobblers mintable via mintlist.
    uint256 public constant MINTLIST_SUPPLY = 2000;

    /// @notice Maximum amount of mintable legendary gobblers.
    uint256 public constant LEGENDARY_SUPPLY = 10;

    /// @notice Maximum amount of gobblers split between the reserves.
    /// @dev Set to compromise 20% of the sum of goo mintable gobblers + reserved gobblers.
    uint256 public constant RESERVED_SUPPLY = (MAX_SUPPLY - MINTLIST_SUPPLY - LEGENDARY_SUPPLY) / 5;

    /// @notice Maximum amount of gobblers that can be minted via VRGDA.
    // prettier-ignore
    uint256 public constant MAX_MINTABLE = MAX_SUPPLY
        - MINTLIST_SUPPLY
        - LEGENDARY_SUPPLY
        - RESERVED_SUPPLY;

    /*//////////////////////////////////////////////////////////////
                           METADATA CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @notice The name displayed for the contract on Etherscan.
    string public constant name = "Art Gobblers";

    /// @notice URI for gobblers that have yet to be revealed.
    string public UNREVEALED_URI;

    /// @notice Base URI for minted gobblers.
    string public BASE_URI;

    /*//////////////////////////////////////////////////////////////
                              VRF CONSTANTS
    //////////////////////////////////////////////////////////////*/

    bytes32 internal immutable chainlinkKeyHash;

    uint256 internal immutable chainlinkFee;

    /*//////////////////////////////////////////////////////////////
                             MINTLIST STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Merkle root of mint mintlist.
    bytes32 public immutable merkleRoot;

    /// @notice Mapping to keep track of which addresses have claimed from mintlist.
    mapping(address => bool) public hasClaimedMintlistGobbler;

    /*//////////////////////////////////////////////////////////////
                            VRGDA INPUT STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Timestamp for the start of minting.
    uint256 public immutable mintStart;

    /// @notice Number of gobblers minted from goo.
    uint128 public numMintedFromGoo;

    /*//////////////////////////////////////////////////////////////
                         STANDARD GOBBLER STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Id of the most recently minted non legendary gobbler.
    /// @dev Will be 0 if no non legendary gobblers have been minted yet.
    uint128 public currentNonLegendaryId;

    /// @notice The number of gobblers minted to the reserves.
    uint256 public numMintedForReserves;

    /*//////////////////////////////////////////////////////////////
                     LEGENDARY GOBBLER AUCTION STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice The last LEGENDARY_SUPPLY ids are reserved for legendary gobblers.
    uint256 public constant FIRST_LEGENDARY_GOBBLER_ID = MAX_SUPPLY - LEGENDARY_SUPPLY + 1;

    /// @notice Legendary auctions begin each time a multiple of these many gobblers have been minted.
    /// @dev We add 1 to LEGENDARY_SUPPLY because legendary auctions begin only after the first interval.
    uint256 public constant LEGENDARY_AUCTION_INTERVAL = MAX_MINTABLE / (LEGENDARY_SUPPLY + 1);

    /// @notice Struct holding data required for legendary gobbler auctions.
    struct LegendaryGobblerAuctionData {
        // Start price of current legendary gobbler auction.
        uint128 startPrice;
        // Number of legendary gobblers sold so far.
        uint128 numSold;
    }

    /// @notice Data about the current legendary gobbler auction.
    LegendaryGobblerAuctionData public legendaryGobblerAuctionData;

    /*//////////////////////////////////////////////////////////////
                          GOBBLER REVEAL STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Struct holding data required for gobbler reveals.
    struct GobblerRevealsData {
        // Last random seed obtained from VRF.
        uint64 randomSeed;
        // Next reveal cannot happen before this timestamp.
        uint64 nextRevealTimestamp;
        // Id of latest gobbler which has been revealed so far.
        uint56 lastRevealedId;
        // Remaining gobblers to be revealed with the current seed.
        uint56 toBeRevealed;
        // Whether we are waiting to receive a seed from Chainlink.
        bool waitingForSeed;
    }

    /// @notice Data about the current state of gobbler reveals.
    GobblerRevealsData public gobblerRevealsData;

    /*//////////////////////////////////////////////////////////////
                             EMISSION STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Struct holding data required for goo emission calculations.
    struct EmissionData {
        // The sum of the multiples of all gobblers the user holds.
        uint64 emissionMultiple;
        // Balance at time of last deposit or withdrawal.
        uint128 lastBalance;
        // Timestamp of last deposit or withdrawal.
        uint64 lastTimestamp;
    }

    /// @notice Maps user addresses to their emission data.
    mapping(address => EmissionData) public getEmissionDataForUser;

    /*//////////////////////////////////////////////////////////////
                            ART FEEDING STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Maps gobbler ids to NFT contracts and their ids to the # of those NFT ids fed to the gobbler.
    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public getCopiesOfArtFedToGobbler;

    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event GooAdded(address indexed user, uint256 gooAdded);
    event GooRemoved(address indexed user, uint256 gooAdded);

    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);
    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);
    event LegendaryGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);
    event ReservedGobblersMinted(address indexed user, uint256 lastMintedGobblerId, uint256 numGobblersEach);

    event RandomnessRequested(address indexed user, uint256 toBeRevealed);
    event RandomnessFulfilled(uint256 randomness);

    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);

    event ArtFedToGobbler(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);

    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/

    error InvalidProof();
    error AlreadyClaimed();
    error MintStartPending();

    error SeedPending();
    error RevealsPending();
    error RequestTooEarly();
    error ZeroToBeRevealed();

    error ReserveImbalance();

    error OwnerMismatch(address owner);

    error NoRemainingLegendaryGobblers();
    error IncorrectGobblerAmount(uint256 cost);
    error CannotBurnLegendary(uint256 gobblerId);

    error PriceExceededMax(uint256 currentPrice);

    error NotEnoughRemainingToBeRevealed(uint256 totalRemainingToBeRevealed);

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(
        // Mint config:
        bytes32 _merkleRoot,
        uint256 _mintStart,
        // Addresses:
        Goo _goo,
        address _team,
        address _community,
        // Chainlink:
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _chainlinkKeyHash,
        uint256 _chainlinkFee,
        // URIs:
        string memory _baseUri,
        string memory _unrevealedUri
    )
        VRGDA(
            69.42e18, // Initial price.
            0.31e18 // Per period price decrease.
        )
        LogisticVRGDA(
            // Max mintable gobblers.
            int256(MAX_MINTABLE * 1e18),
            0.0023e18 // Time scale.
        )
        VRFConsumerBase(_vrfCoordinator, _linkToken)
        Owned(msg.sender) // Deployer starts as owner.
    {
        mintStart = _mintStart;
        merkleRoot = _merkleRoot;

        goo = _goo;
        team = _team;
        community = _community;

        chainlinkKeyHash = _chainlinkKeyHash;
        chainlinkFee = _chainlinkFee;

        BASE_URI = _baseUri;
        UNREVEALED_URI = _unrevealedUri;

        // Starting price for legendary gobblers is 69 gobblers.
        legendaryGobblerAuctionData.startPrice = 69;

        // Reveal for initial mint must wait 24 hours
        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);
    }

    /*//////////////////////////////////////////////////////////////
                          MINTLIST CLAIM LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Claim from mintlist, using a merkle proof.
    /// @param proof Merkle proof to verify the sender is mintlisted.
    /// @return gobblerId The id of the gobbler that was claimed.
    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {
        // If minting has not yet begun, revert.
        if (mintStart > block.timestamp) revert MintStartPending();

        // If the user has already claimed, revert.
        if (hasClaimedMintlistGobbler[msg.sender]) revert AlreadyClaimed();

        // If the user's proof is invalid, revert.
        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert InvalidProof();

        hasClaimedMintlistGobbler[msg.sender] = true; // Before mint to prevent reentrancy.

        unchecked {
            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLegendaryId);

            _mint(msg.sender, gobblerId, "");
        }
    }

    /*//////////////////////////////////////////////////////////////
                              MINTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a gobbler with goo, burning the cost.
    /// @param maxPrice Maximum price to pay to mint the gobbler.
    /// @return gobblerId The id of the gobbler that was minted.
    function mintFromGoo(uint256 maxPrice) external returns (uint256 gobblerId) {
        // No need to check mint cap, gobblerPrice()
        // will revert due to overflow if we reach it.
        // It will also revert prior to the mint start.
        uint256 currentPrice = gobblerPrice();

        // If the current price is above the user's specified max, revert.
        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);

        goo.burnForGobblers(msg.sender, currentPrice);

        unchecked {
            ++numMintedFromGoo; // Before mint to prevent reentrancy.

            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLegendaryId, currentPrice);

            _mint(msg.sender, gobblerId, "");
        }
    }

    /// @notice Gobbler pricing in terms of goo.
    /// @dev Will revert if called before minting starts
    /// or after all gobblers have been minted via VRGDA.
    function gobblerPrice() public view returns (uint256) {
        // We need checked math here to cause overflow
        // before minting has begun, preventing mints.
        uint256 timeSinceStart = block.timestamp - mintStart;

        return getPrice(timeSinceStart, numMintedFromGoo);
    }

    /*//////////////////////////////////////////////////////////////
                     LEGENDARY GOBBLER AUCTION LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a legendary gobbler by burning multiple standard gobblers.
    /// @param gobblerIds The ids of the standard gobblers to burn.
    /// @return gobblerId The id of the legendary gobbler that was minted.
    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {
        gobblerId = FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold; // Assign id.

        // If the gobbler id would be greater than the max supply, there are no remaining legendaries.
        if (gobblerId > MAX_SUPPLY) revert NoRemainingLegendaryGobblers();

        // This will revert if the auction hasn't started yet, no need to check here as well.
        uint256 cost = legendaryGobblerPrice();

        if (gobblerIds.length != cost) revert IncorrectGobblerAmount(cost);

        // Overflow should not occur in here, as most math is on emission multiples, which are inherently small.
        unchecked {
            uint256 burnedMultipleTotal; // The legendary's emissionMultiple will be 2x the sum of the gobblers burned.

            /*//////////////////////////////////////////////////////////////
                                    BATCH BURN LOGIC
            //////////////////////////////////////////////////////////////*/

            // Generate an amounts array locally to use in the event below.
            uint256[] memory amounts = new uint256[](gobblerIds.length);

            uint256 id; // Storing outside the loop saves ~7 gas per iteration.

            for (uint256 i = 0; i < gobblerIds.length; ++i) {
                id = gobblerIds[i];

                if (id >= FIRST_LEGENDARY_GOBBLER_ID) revert CannotBurnLegendary(id);

                require(getGobblerData[id].owner == msg.sender, "WRONG_FROM");

                burnedMultipleTotal += getGobblerData[id].emissionMultiple;

                getGobblerData[id].owner = address(0);

                amounts[i] = 1;
            }

            emit TransferBatch(msg.sender, msg.sender, address(0), gobblerIds, amounts);

            /*//////////////////////////////////////////////////////////////
                                 LEGENDARY MINTING LOGIC
            //////////////////////////////////////////////////////////////*/

            // The shift right by 1 is equivalent to multiplication by 2, used to make
            // the legendary's emissionMultiple 2x the sum of the multiples of the gobblers burned.
            // Must be done before minting as the transfer hook will update the user's emissionMultiple.
            getGobblerData[gobblerId].emissionMultiple = uint48(burnedMultipleTotal << 1);

            // Update the user's emission data in one big batch. We add burnedMultipleTotal to their
            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that
            // were burned and hence should have their multiples subtracted from the user's total multiple.
            getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender));
            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);
            getEmissionDataForUser[msg.sender].emissionMultiple += uint64(burnedMultipleTotal);

            // New start price is the max of 69 and cost * 2. Left shift by 1 is like multiplication by 2.
            legendaryGobblerAuctionData.startPrice = uint120(cost < 35 ? 69 : cost << 1);
            legendaryGobblerAuctionData.numSold += 1; // Increment the # of legendaries sold.

            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.
            emit LegendaryGobblerMinted(msg.sender, gobblerId, gobblerIds);

            _mint(msg.sender, gobblerId, "");
        }
    }

    /// @notice Calculate the legendary gobbler price in terms of gobblers, according to a linear decay function.
    /// @dev The price of a legendary gobbler decays as gobblers are minted. The first legendary auction begins when
    /// 1 LEGENDARY_AUCTION_INTERVAL worth of gobblers are minted, and the price decays linearly while the next interval of
    /// gobblers is minted. Every time an additional interval is minted, a new auction begins until all legendaries been sold.
    function legendaryGobblerPrice() public view returns (uint256) {
        // Retrieve and cache the auction's startPrice and numSold on the stack.
        uint256 startPrice = legendaryGobblerAuctionData.startPrice;
        uint256 numSold = legendaryGobblerAuctionData.numSold;

        uint256 numMintedAtStart; // The number of gobblers minted at the start of the auction.

        unchecked {
            // The number of gobblers minted at the start of the auction is computed by multiplying the # of
            // intervals that must pass before the next auction begins by the number of gobblers in each interval.
            numMintedAtStart = (numSold + 1) * LEGENDARY_AUCTION_INTERVAL;
        }

        // How many gobblers where minted since auction began. Cannot be
        // unchecked, we want this to revert if auction has not yet started.
        uint256 numMintedSinceStart = numMintedFromGoo - numMintedAtStart;

        unchecked {
            // If we've minted the full interval or beyond it, the price has decayed to 0.
            if (numMintedSinceStart >= LEGENDARY_AUCTION_INTERVAL) return 0;
            // Otherwise decay the price linearly based on what fraction of the interval has been minted.
            else return (startPrice * (LEGENDARY_AUCTION_INTERVAL - numMintedSinceStart)) / LEGENDARY_AUCTION_INTERVAL;
        }
    }

    /*//////////////////////////////////////////////////////////////
                                VRF LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Request a new random seed for revealing gobblers.
    /// @dev Can only be called every 24 hours at the earliest.
    function requestRandomSeed() external returns (bytes32) {
        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;

        // A new random seed cannot be requested before the next reveal timestamp.
        if (block.timestamp < nextRevealTimestamp) revert RequestTooEarly();

        // A random seed can only be requested when all gobblers from the previous seed have been revealed.
        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.
        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();

        unchecked {
            // Prevent revealing while we wait for the seed.
            gobblerRevealsData.waitingForSeed = true;

            // Compute the number of gobblers to be revealed with the seed.
            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;

            // Ensure that there are more than 0 gobblers to be revealed,
            // otherwise the contract could waste LINK revealing nothing.
            if (toBeRevealed == 0) revert ZeroToBeRevealed();

            // Lock in the number of gobblers to be revealed from seed.
            gobblerRevealsData.toBeRevealed = uint56(toBeRevealed);

            // We want at most one batch of reveals every 24 hours.
            // Timestamp overflow is impossible on human timescales.
            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);

            emit RandomnessRequested(msg.sender, toBeRevealed);
        }

        // Will revert if we don't have enough LINK to afford the request.
        return requestRandomness(chainlinkKeyHash, chainlinkFee);
    }

    /// @notice Callback from Chainlink VRF. Sets randomSeed.
    function fulfillRandomness(bytes32, uint256 randomness) internal override {
        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.
        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.

        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.

        emit RandomnessFulfilled(randomness);
    }

    /*//////////////////////////////////////////////////////////////
                          GOBBLER REVEAL LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Knuth shuffle to progressively reveal gobblers using entropy from random seed.
    /// @param numGobblers The number of gobblers to reveal.
    function revealGobblers(uint256 numGobblers) external {
        uint256 randomSeed = gobblerRevealsData.randomSeed;

        uint256 lastRevealedId = gobblerRevealsData.lastRevealedId;

        uint256 totalRemainingToBeRevealed = gobblerRevealsData.toBeRevealed;

        // Can't reveal if we're still waiting for a new seed.
        if (gobblerRevealsData.waitingForSeed) revert SeedPending();

        // Can't reveal more gobblers than are currently remaining to be revealed with the seed.
        if (numGobblers > totalRemainingToBeRevealed) revert NotEnoughRemainingToBeRevealed(totalRemainingToBeRevealed);

        // Implements a Knuth shuffle. If something in
        // here can overflow we've got bigger problems.
        unchecked {
            for (uint256 i = 0; i < numGobblers; ++i) {
                /*//////////////////////////////////////////////////////////////
                                      DETERMINE RANDOM SWAP
                //////////////////////////////////////////////////////////////*/

                // Number of ids that have not been revealed. Subtract 1
                // because we don't want to include any legendaries in the swap.
                uint256 remainingIds = FIRST_LEGENDARY_GOBBLER_ID - lastRevealedId - 1;

                // Randomly pick distance for swap.
                uint256 distance = randomSeed % remainingIds;

                // Current id is consecutive to last reveal.
                uint256 currentId = ++lastRevealedId;

                // Select swap id, adding distance to next reveal id.
                uint256 swapId = currentId + distance;

                /*//////////////////////////////////////////////////////////////
                                       GET INDICES FOR IDS
                //////////////////////////////////////////////////////////////*/

                // Get the index of the swap id.
                uint48 swapIndex = getGobblerData[swapId].idx == 0
                    ? uint48(swapId) // Hasn't been shuffled before.
                    : getGobblerData[swapId].idx; // Shuffled before.

                // Get the owner of the current id.
                address currentIdOwner = getGobblerData[currentId].owner;

                // Get the index of the current id.
                uint48 currentIndex = getGobblerData[currentId].idx == 0
                    ? uint48(currentId) // Hasn't been shuffled before.
                    : getGobblerData[currentId].idx; // Shuffled before.

                /*//////////////////////////////////////////////////////////////
                                  SWAP INDICES AND SET MULTIPLE
                //////////////////////////////////////////////////////////////*/

                // Determine the current id's new emission multiple.
                uint256 newCurrentIdMultiple = 9; // For beyond 7963.

                // The branchless expression below is equivalent to:
                //      if (swapIndex <= 3054) newCurrentIdMultiple = 6;
                // else if (swapIndex <= 5672) newCurrentIdMultiple = 7;
                // else if (swapIndex <= 7963) newCurrentIdMultiple = 8;
                assembly {
                    // prettier-ignore
                    newCurrentIdMultiple := sub(sub(sub(
                        newCurrentIdMultiple,
                        lt(swapIndex, 7964)),
                        lt(swapIndex, 5673)),
                        lt(swapIndex, 3055)
                    )
                }

                // Swap the index and multiple of the current id.
                getGobblerData[currentId].idx = swapIndex;
                getGobblerData[currentId].emissionMultiple = uint48(newCurrentIdMultiple);

                // Swap the index of the swap id.
                getGobblerData[swapId].idx = currentIndex;

                /*//////////////////////////////////////////////////////////////
                                   UPDATE CURRENT ID MULTIPLE
                //////////////////////////////////////////////////////////////*/

                // Update the emission data for the owner of the current id.
                getEmissionDataForUser[currentIdOwner].lastBalance = uint128(gooBalance(currentIdOwner));
                getEmissionDataForUser[currentIdOwner].lastTimestamp = uint64(block.timestamp);
                getEmissionDataForUser[currentIdOwner].emissionMultiple += uint64(newCurrentIdMultiple);

                // Update the random seed to choose a new distance for the next iteration.
                // It is critical that we cast to uint64 here, as otherwise the random seed
                // set after calling revealGobblers(1) thrice would differ from the seed set
                // after calling revealGobblers(3) a single time. This would enable an attacker
                // to choose from a number of different seeds and use whichever is most favorable.
                // Equivalent to randomSeed = uint64(uint256(keccak256(abi.encodePacked(randomSeed))))
                assembly {
                    mstore(0, randomSeed) // Store the random seed in scratch space.

                    // Moduloing by 1 << 64 (2 ** 64) is equivalent to a uint64 cast.
                    randomSeed := mod(keccak256(0, 32), shl(64, 1))
                }
            }

            // Update all relevant reveal state state.
            gobblerRevealsData.randomSeed = uint64(randomSeed);
            gobblerRevealsData.lastRevealedId = uint56(lastRevealedId);
            gobblerRevealsData.toBeRevealed = uint56(totalRemainingToBeRevealed - numGobblers);

            emit GobblersRevealed(msg.sender, numGobblers, lastRevealedId);
        }
    }

    /*//////////////////////////////////////////////////////////////
                                URI LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Returns a token's URI if it has been minted.
    /// @param gobblerId The id of the token to get the URI for.
    function uri(uint256 gobblerId) public view virtual override returns (string memory) {
        // Between 0 and lastRevealed are revealed normal gobblers.
        if (gobblerId <= gobblerRevealsData.lastRevealedId) {
            // 0 is not a valid id:
            if (gobblerId == 0) return "";

            return string(abi.encodePacked(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString()));
        }

        // Between lastRevealed + 1 and currentNonLegendaryId are minted but not revealed.
        if (gobblerId <= currentNonLegendaryId) return UNREVEALED_URI;

        // Between currentNonLegendaryId and FIRST_LEGENDARY_GOBBLER_ID are unminted.
        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID) return "";

        // Between FIRST_LEGENDARY_GOBBLER_ID and FIRST_LEGENDARY_GOBBLER_ID + numSold are minted legendaries.
        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold)
            return string(abi.encodePacked(BASE_URI, gobblerId.toString()));

        return ""; // Unminted legendaries and invalid token ids.
    }

    /*//////////////////////////////////////////////////////////////
                            ART FEEDING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Feed a gobbler a work of art.
    /// @param gobblerId The gobbler to feed the work of art.
    /// @param nft The ERC721 or ERC1155 contract of the work of art.
    /// @param id The id of the work of art.
    /// @param isERC1155 Whether the work of art is an ERC1155 token.
    function feedArt(
        uint256 gobblerId,
        address nft,
        uint256 id,
        bool isERC1155
    ) external {
        // Get the owner of the gobbler to feed.
        address owner = getGobblerData[gobblerId].owner;

        // The caller must own the gobbler they're feeding.
        if (owner != msg.sender) revert OwnerMismatch(owner);

        unchecked {
            // Increment the number of copies fed to the gobbler.
            // Counter overflow is unrealistic on human timescales.
            ++getCopiesOfArtFedToGobbler[gobblerId][nft][id];
        }

        emit ArtFedToGobbler(msg.sender, gobblerId, nft, id);

        isERC1155
            ? ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, "")
            : ERC721(nft).transferFrom(msg.sender, address(this), id);
    }

    /*//////////////////////////////////////////////////////////////
                             EMISSION LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Calculate a user's staked goo balance.
    /// @param user The user to query balance for.
    function gooBalance(address user) public view returns (uint256) {
        // If a user's goo balance is greater than
        // 2**256 - 1 we've got much bigger problems.
        unchecked {
            uint256 emissionMultiple = getEmissionDataForUser[user].emissionMultiple;
            uint256 lastBalanceWad = getEmissionDataForUser[user].lastBalance;

            // Stored with 18 decimals, such that if a day and a half elapsed this variable would equal 1.5e18.
            uint256 daysElapsedWad = ((block.timestamp - getEmissionDataForUser[user].lastTimestamp) * 1e18) / 1 days;

            uint256 daysElapsedSquaredWad = daysElapsedWad.mulWadDown(daysElapsedWad); // Need to use wad math here.

            // prettier-ignore
            return lastBalanceWad + // The last recorded balance.

            // Don't need to do wad multiplication since we're
            // multiplying by a plain integer with no decimals.
            // Shift right by 2 is equivalent to division by 4.
            ((emissionMultiple * daysElapsedSquaredWad) >> 2) +

            daysElapsedWad.mulWadDown( // Terms are wads, so must mulWad.
                // No wad multiplication for emissionMultiple * lastBalance
                // because emissionMultiple is a plain integer with no decimals.
                // We multiply the sqrt's radicand by 1e18 because it expects ints.
                (emissionMultiple * lastBalanceWad * 1e18).sqrt()
            );
        }
    }

    /// @notice Add goo to your emission balance.
    /// @param gooAmount The amount of goo to add.
    function addGoo(uint256 gooAmount) external {
        // Burn goo being added to gobbler.
        goo.burnForGobblers(msg.sender, gooAmount);

        unchecked {
            // If a user has enough goo to overflow their balance we've got big problems.
            getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender) + gooAmount);
            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);
        }

        emit GooAdded(msg.sender, gooAmount);
    }

    /// @notice Remove goo from your emission balance.
    /// @param gooAmount The amount of goo to remove.
    function removeGoo(uint256 gooAmount) external {
        // Will revert due to underflow if removed amount is larger than the user's current goo balance.
        getEmissionDataForUser[msg.sender].lastBalance = uint128(gooBalance(msg.sender) - gooAmount);
        getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);

        goo.mintForGobblers(msg.sender, gooAmount);

        emit GooRemoved(msg.sender, gooAmount);
    }

    /*//////////////////////////////////////////////////////////////
                     RESERVED GOBBLERS MINTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Mint a number of gobblers to the reserves.
    /// @param numGobblersEach The number of gobblers to mint to each reserve.
    /// @dev Gobblers minted to reserves cannot compromise more than 20% of the sum of
    /// the supply of goo minted gobblers and the supply of gobblers minted to reserves.
    function mintReservedGobblers(uint256 numGobblersEach) external returns (uint256 lastMintedGobblerId) {
        unchecked {
            // Optimistically increment numMintedForReserves, may be reverted below. Overflow in this
            // calculation is possible but numGobblersEach would have to be so large that it would cause the
            // loop in _batchMint to run out of gas quickly. Shift left by 1 is equivalent to multiplying by 2.
            uint256 newNumMintedForReserves = numMintedForReserves += (numGobblersEach << 1);

            // Ensure that after this mint gobblers minted to reserves won't compromise more than 20% of
            // the sum of the supply of goo minted gobblers and the supply of gobblers minted to reserves.
            if (newNumMintedForReserves > (numMintedFromGoo + newNumMintedForReserves) / 5) revert ReserveImbalance();
        }

        // Mint numGobblersEach gobblers to both the team and community reserve.
        lastMintedGobblerId = _batchMint(team, numGobblersEach, currentNonLegendaryId, "");
        lastMintedGobblerId = _batchMint(community, numGobblersEach, lastMintedGobblerId, "");

        // Note: There is reentrancy here. The _batchMint calls above can enable an
        // adversary to reenter before currentNonLegendaryId is updated, but since we
        // assume the reserves are both trusted addresses, we can safely ignore this risk.
        currentNonLegendaryId = uint128(lastMintedGobblerId); // Set currentNonLegendaryId.

        emit ReservedGobblersMinted(msg.sender, lastMintedGobblerId, numGobblersEach);
    }

    /*//////////////////////////////////////////////////////////////
                          CONVENIENCE FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /// @notice Convenience function to get emission emissionMultiple for a gobbler.
    /// @param gobblerId The gobbler to get emissionMultiple for.
    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {
        return getGobblerData[gobblerId].emissionMultiple;
    }

    /// @notice Convenience function to get emission emissionMultiple for a user.
    /// @param user The user to get emissionMultiple for.
    function getUserEmissionMultiple(address user) external view returns (uint256) {
        return getEmissionDataForUser[user].emissionMultiple;
    }

    /*//////////////////////////////////////////////////////////////
                             ERC1155B LOGIC
    //////////////////////////////////////////////////////////////*/

    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) public override {
        require(ids.length == amounts.length, "LENGTH_MISMATCH");

        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");

        // Storing these outside the loop saves ~15 gas per iteration.
        uint256 id;
        uint256 amount;

        unchecked {
            uint64 emissionsMultipleTotal; // Will use to set each user's multiple.

            for (uint256 i = 0; i < ids.length; i++) {
                id = ids[i];
                amount = amounts[i];

                // Can only transfer from the owner.
                require(from == getGobblerData[id].owner, "WRONG_FROM");

                // Can only transfer 1 with ERC1155B.
                require(amount == 1, "INVALID_AMOUNT");

                getGobblerData[id].owner = to;

                emissionsMultipleTotal += getGobblerData[id].emissionMultiple;
            }

            transferUserEmissionMultiple(from, to, emissionsMultipleTotal);
        }

        emit TransferBatch(msg.sender, from, to, ids, amounts);

        if (to.code.length != 0) {
            require(
                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==
                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,
                "UNSAFE_RECIPIENT"
            );
        } else require(to != address(0), "INVALID_RECIPIENT");
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) public override {
        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");

        require(from == getGobblerData[id].owner, "WRONG_FROM"); // Can only transfer from the owner.

        // Can only transfer 1 with ERC1155B.
        require(amount == 1, "INVALID_AMOUNT");

        getGobblerData[id].owner = to;

        transferUserEmissionMultiple(from, to, getGobblerData[id].emissionMultiple);

        emit TransferSingle(msg.sender, from, to, id, amount);

        if (to.code.length != 0) {
            require(
                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==
                    ERC1155TokenReceiver.onERC1155Received.selector,
                "UNSAFE_RECIPIENT"
            );
        } else require(to != address(0), "INVALID_RECIPIENT");
    }

    /*//////////////////////////////////////////////////////////////
                              HELPER LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @dev Transfer an amount of a user's emission's multiple to another user.
    /// @dev Should be done whenever a gobbler is transferred between two users.
    /// @param from The user to transfer the amount of emission multiple from.
    /// @param to The user to transfer the amount of emission multiple to.
    /// @param emissionMultiple The amount of emission multiple to transfer.
    function transferUserEmissionMultiple(
        address from,
        address to,
        uint64 emissionMultiple
    ) internal {
        unchecked {
            // Decrease the from user's emissionMultiple by the gobbler's emissionMultiple.
            getEmissionDataForUser[from].lastBalance = uint128(gooBalance(from));
            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);
            getEmissionDataForUser[from].emissionMultiple -= emissionMultiple;

            // Increase the to user's emissionMultiple by the gobbler's emissionMultiple.
            getEmissionDataForUser[to].lastBalance = uint128(gooBalance(to));
            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);
            getEmissionDataForUser[to].emissionMultiple += emissionMultiple;
        }
    }
}


================================================
File: /src/utils/GobblerReserve.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {Owned} from "solmate/auth/Owned.sol";
import {ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";

import {ArtGobblers} from "../ArtGobblers.sol";

/// @title Gobbler Reserve
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Reserves gobblers for an owner while keeping any goo produced.
contract GobblerReserve is Owned, ERC1155TokenReceiver {
    /*//////////////////////////////////////////////////////////////
                                ADDRESSES
    //////////////////////////////////////////////////////////////*/
    ArtGobblers public artGobblers;

    constructor(ArtGobblers _artGobblers, address _owner) Owned(_owner) {
        artGobblers = _artGobblers;
    }

    /*//////////////////////////////////////////////////////////////
                            WITHDRAWAL LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Withdraw gobblers from the reserve.
    /// @param to The address to transfer the gobblers to.
    /// @param ids The ids of the gobblers to transfer.
    function withdraw(address to, uint256[] calldata ids) public onlyOwner {
        unchecked {
            // Generating this in memory is pretty expensive
            // but this is not a hot path so we can afford it.
            uint256[] memory amounts = new uint256[](ids.length);
            for (uint256 i = 0; i < ids.length; i++) amounts[i] = 1;

            artGobblers.safeBatchTransferFrom(address(this), to, ids, amounts, "");
        }
    }
}


================================================
File: /src/utils/lib/SignedWadMath.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/// @title Signed Wad Math
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Efficient signed wad arithmetic.

/// @dev Will not revert on overflow, only use where overflow is not possible.
function toWadUnsafe(uint256 x) pure returns (int256 r) {
    assembly {
        // Multiply x by 1e18.
        r := mul(x, 1000000000000000000)
    }
}

/// @dev Will not revert on overflow, only use where overflow is not possible.
function unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {
    assembly {
        // Multiply x by y and divide by 1e18.
        r := sdiv(mul(x, y), 1000000000000000000)
    }
}

/// @dev Will return 0 instead of reverting if y is zero and will
/// not revert on overflow, only use where overflow is not possible.
function unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {
    assembly {
        // Multiply x by 1e18 and divide it by y.
        r := sdiv(mul(x, 1000000000000000000), y)
    }
}

function wadMul(int256 x, int256 y) pure returns (int256 r) {
    assembly {
        // Store x * y in r for now.
        r := mul(x, y)

        // Equivalent to require(x == 0 || (x * y) / x == y)
        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {
            revert(0, 0)
        }

        // Scale the result down by 1e18.
        r := sdiv(r, 1000000000000000000)
    }
}

function wadDiv(int256 x, int256 y) pure returns (int256 r) {
    assembly {
        // Store x * 1e18 in r for now.
        r := mul(x, 1000000000000000000)

        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))
        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {
            revert(0, 0)
        }

        // Divide r by y.
        r := sdiv(r, y)
    }
}

function wadExp(int256 x) pure returns (int256 r) {
    unchecked {
        // When the result is < 0.5 we return zero. This happens when
        // x <= floor(log(0.5e18) * 1e18) ~ -42e18
        if (x <= -42139678854452767551) return 0;

        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an
        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.
        if (x >= 135305999368893231589) revert("EXP_OVERFLOW");

        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96
        // for more intermediate precision and a binary basis. This base conversion
        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.
        x = (x << 78) / 5**18;

        // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers
        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.
        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).
        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;
        x = x - k * 54916777467707473351141471128;

        // k is in the range [-61, 195].

        // Evaluate using a (6, 7)-term rational approximation.
        // p is made monic, we'll multiply by a scale factor later.
        int256 y = x + 1346386616545796478920950773328;
        y = ((y * x) >> 96) + 57155421227552351082224309758442;
        int256 p = y + x - 94201549194550492254356042504812;
        p = ((p * y) >> 96) + 28719021644029726153956944680412240;
        p = p * x + (4385272521454847904659076985693276 << 96);

        // We leave p in 2**192 basis so we don't need to scale it back up for the division.
        int256 q = x - 2855989394907223263936484059900;
        q = ((q * x) >> 96) + 50020603652535783019961831881945;
        q = ((q * x) >> 96) - 533845033583426703283633433725380;
        q = ((q * x) >> 96) + 3604857256930695427073651918091429;
        q = ((q * x) >> 96) - 14423608567350463180887372962807573;
        q = ((q * x) >> 96) + 26449188498355588339934803723976023;

        assembly {
            // Div in assembly because solidity adds a zero check despite the unchecked.
            // The q polynomial won't have zeros in the domain as all its roots are complex.
            // No scaling is necessary because p is already 2**96 too large.
            r := sdiv(p, q)
        }

        // r should be in the range (0.09, 0.25) * 2**96.

        // We now need to multiply r by:
        // * the scale factor s = ~6.031367120.
        // * the 2**k factor from the range reduction.
        // * the 1e18 / 2**96 factor for base conversion.
        // We do this all at once, with an intermediate result in 2**213
        // basis, so the final right shift is always by a positive amount.
        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));
    }
}

function wadLn(int256 x) pure returns (int256 r) {
    unchecked {
        require(x > 0, "UNDEFINED");

        // We want to convert x from 10**18 fixed point to 2**96 fixed point.
        // We do this by multiplying by 2**96 / 10**18. But since
        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here
        // and add ln(2**96 / 10**18) at the end.

        assembly {
            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
            r := or(r, shl(4, lt(0xffff, shr(r, x))))
            r := or(r, shl(3, lt(0xff, shr(r, x))))
            r := or(r, shl(2, lt(0xf, shr(r, x))))
            r := or(r, shl(1, lt(0x3, shr(r, x))))
            r := or(r, lt(0x1, shr(r, x)))
        }

        // Reduce range of x to (1, 2) * 2**96
        // ln(2^k * x) = k * ln(2) + ln(x)
        int256 k = r - 96;
        x <<= uint256(159 - k);
        x = int256(uint256(x) >> 159);

        // Evaluate using a (8, 8)-term rational approximation.
        // p is made monic, we will multiply by a scale factor later.
        int256 p = x + 3273285459638523848632254066296;
        p = ((p * x) >> 96) + 24828157081833163892658089445524;
        p = ((p * x) >> 96) + 43456485725739037958740375743393;
        p = ((p * x) >> 96) - 11111509109440967052023855526967;
        p = ((p * x) >> 96) - 45023709667254063763336534515857;
        p = ((p * x) >> 96) - 14706773417378608786704636184526;
        p = p * x - (795164235651350426258249787498 << 96);

        // We leave p in 2**192 basis so we don't need to scale it back up for the division.
        // q is monic by convention.
        int256 q = x + 5573035233440673466300451813936;
        q = ((q * x) >> 96) + 71694874799317883764090561454958;
        q = ((q * x) >> 96) + 283447036172924575727196451306956;
        q = ((q * x) >> 96) + 401686690394027663651624208769553;
        q = ((q * x) >> 96) + 204048457590392012362485061816622;
        q = ((q * x) >> 96) + 31853899698501571402653359427138;
        q = ((q * x) >> 96) + 909429971244387300277376558375;
        assembly {
            // Div in assembly because solidity adds a zero check despite the unchecked.
            // The q polynomial is known not to have zeros in the domain.
            // No scaling required because p is already 2**96 too large.
            r := sdiv(p, q)
        }

        // r is in the range (0, 0.125) * 2**96

        // Finalization, we need to:
        // * multiply by the scale factor s = 5.549…
        // * add ln(2**96 / 10**18)
        // * add k * ln(2)
        // * multiply by 10**18 / 2**96 = 5**18 >> 78

        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192
        r *= 1677202110996718588342820967067443963516166;
        // add ln(2) * k * 5e18 * 2**192
        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;
        // add ln(2**96 / 10**18) * 5e18 * 2**192
        r += 600920179829731861736702779321621459595472258049074101567377883020018308;
        // base conversion: mul 2**18 / 2**192
        r >>= 174;
    }
}

/// @dev Will return 0 instead of reverting if y is zero.
function unsafeDiv(int256 x, int256 y) pure returns (int256 r) {
    assembly {
        // Divide x by y.
        r := sdiv(x, y)
    }
}


================================================
File: /src/utils/lib/MerkleProofLib.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/// @notice Gas optimized merkle proof verification library.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/MerkleProofLib.sol)
library MerkleProofLib {
    function verify(
        bytes32[] calldata proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool isValid) {
        assembly {
            let computedHash := leaf // The hash starts as the leaf hash.

            // Initialize data to the offset of the proof in the calldata.
            let data := proof.offset

            // Iterate over proof elements to compute root hash.
            for {
                // Left shifting by 5 is like multiplying by 32.
                let end := add(data, shl(5, proof.length))
            } lt(data, end) {
                data := add(data, 32) // Shift 1 word per cycle.
            } {
                // Load the current proof element.
                let loadedData := calldataload(data)

                // Slot where computedHash should be put in scratch space.
                // If computedHash > loadedData: slot 32, otherwise: slot 0.
                let computedHashSlot := shl(5, gt(computedHash, loadedData))

                // Store elements to hash contiguously in scratch space.
                // The xor puts loadedData in whichever slot computedHash is
                // not occupying, so 0 if computedHashSlot is 32, 32 otherwise.
                mstore(computedHashSlot, computedHash)
                mstore(xor(computedHashSlot, 32), loadedData)

                computedHash := keccak256(0, 64) // Hash both slots of scratch space.
            }

            isValid := eq(computedHash, root) // The proof is valid if the roots match.
        }
    }
}


================================================
File: /src/utils/lib/LibString.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/// @notice Efficient library for creating string representations of integers.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)
library LibString {
    function toString(uint256 n) internal pure returns (string memory str) {
        if (n == 0) return "0"; // Otherwise it'd output an empty string for 0.

        assembly {
            let k := 78 // Start with the max length a uint256 string could be.

            // We'll store our string at the first chunk of free memory.
            str := mload(0x40)

            // The length of our string will start off at the max of 78.
            mstore(str, k)

            // Update the free memory pointer to prevent overriding our string.
            // Add 128 to the str pointer instead of 78 because we want to maintain
            // the Solidity convention of keeping the free memory pointer word aligned.
            mstore(0x40, add(str, 128))

            // We'll populate the string from right to left.
            // prettier-ignore
            for {} n {} {
                // The ASCII digit offset for '0' is 48.
                let char := add(48, mod(n, 10))

                // Write the current character into str.
                mstore(add(str, k), char)

                k := sub(k, 1)
                n := div(n, 10)
            }

            // Shift the pointer to the start of the string.
            str := add(str, k)

            // Set the length of the string to the correct value.
            mstore(str, sub(78, k))
        }
    }
}


================================================
File: /src/utils/token/PagesERC721.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {ERC721TokenReceiver} from "solmate/tokens/ERC721.sol";

/// @notice ERC721 implementation optimized for Pages by pre-approving them to the ArtGobblers contract.
/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)
abstract contract PagesERC721 {
    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event Transfer(address indexed from, address indexed to, uint256 indexed id);

    event Approval(address indexed owner, address indexed spender, uint256 indexed id);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /*//////////////////////////////////////////////////////////////
                         METADATA STORAGE/LOGIC
    //////////////////////////////////////////////////////////////*/

    string public name;

    string public symbol;

    function tokenURI(uint256 id) public view virtual returns (string memory);

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    address public immutable artGobblers;

    constructor(
        address _artGobblers,
        string memory _name,
        string memory _symbol
    ) {
        name = _name;
        symbol = _symbol;
        artGobblers = _artGobblers;
    }

    /*//////////////////////////////////////////////////////////////
                      ERC721 BALANCE/OWNER STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(uint256 => address) internal _ownerOf;

    mapping(address => uint256) internal _balanceOf;

    function ownerOf(uint256 id) public view virtual returns (address owner) {
        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");
    }

    function balanceOf(address owner) public view virtual returns (uint256) {
        require(owner != address(0), "ZERO_ADDRESS");

        return _balanceOf[owner];
    }

    /*//////////////////////////////////////////////////////////////
                         ERC721 APPROVAL STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(uint256 => address) public getApproved;

    mapping(address => mapping(address => bool)) internal _isApprovedForAll;

    function isApprovedForAll(address owner, address operator) public view virtual returns (bool isApproved) {
        if (operator == artGobblers) return true; // Skip approvals for the ArtGobblers contract.

        return _isApprovedForAll[owner][operator];
    }

    /*//////////////////////////////////////////////////////////////
                              ERC721 LOGIC
    //////////////////////////////////////////////////////////////*/

    function approve(address spender, uint256 id) public virtual {
        address owner = _ownerOf[id];

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "NOT_AUTHORIZED");

        getApproved[id] = spender;

        emit Approval(owner, spender, id);
    }

    function setApprovalForAll(address operator, bool approved) public virtual {
        _isApprovedForAll[msg.sender][operator] = approved;

        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function transferFrom(
        address from,
        address to,
        uint256 id
    ) public virtual {
        require(from == _ownerOf[id], "WRONG_FROM");

        require(to != address(0), "INVALID_RECIPIENT");

        require(
            msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved[id],
            "NOT_AUTHORIZED"
        );

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        unchecked {
            _balanceOf[from]--;

            _balanceOf[to]++;
        }

        _ownerOf[id] = to;

        delete getApproved[id];

        emit Transfer(from, to, id);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id
    ) public virtual {
        transferFrom(from, to, id);

        if (to.code.length != 0)
            require(
                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==
                    ERC721TokenReceiver.onERC721Received.selector,
                "UNSAFE_RECIPIENT"
            );
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        bytes calldata data
    ) public virtual {
        transferFrom(from, to, id);

        if (to.code.length != 0)
            require(
                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==
                    ERC721TokenReceiver.onERC721Received.selector,
                "UNSAFE_RECIPIENT"
            );
    }

    /*//////////////////////////////////////////////////////////////
                              ERC165 LOGIC
    //////////////////////////////////////////////////////////////*/

    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return
            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165
            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721
            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL MINT/BURN LOGIC
    //////////////////////////////////////////////////////////////*/

    function _mint(address to, uint256 id) internal virtual {
        // Does not check the token has not been already minted
        // or is being minted to address(0) because ids in Pages.sol
        // are set using a monotonically increasing counter and only
        // minted to safe addresses or msg.sender who cannot be zero.

        // Counter overflow is incredibly unrealistic.
        unchecked {
            _balanceOf[to]++;
        }

        _ownerOf[id] = to;

        emit Transfer(address(0), to, id);
    }
}


================================================
File: /src/utils/token/GobblersERC1155B.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol";

/// @notice ERC1155B implementation optimized for ArtGobblers by using the ownerOf storage slot to store attribute data.
/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/tokens/ERC1155B.sol)
abstract contract GobblersERC1155B {
    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event TransferSingle(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 id,
        uint256 amount
    );

    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] amounts
    );

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    event URI(string value, uint256 indexed id);

    /*//////////////////////////////////////////////////////////////
                             ERC1155 STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(address => mapping(address => bool)) public isApprovedForAll;

    /*//////////////////////////////////////////////////////////////
                        GOBBLERS/ERC1155B STORAGE
    //////////////////////////////////////////////////////////////*/

    /// @notice Struct holding gobbler data.
    struct GobblerData {
        // The current owner of the gobbler.
        address owner;
        // Index of token after shuffle.
        uint48 idx;
        // Multiple on goo issuance.
        uint48 emissionMultiple;
    }

    mapping(uint256 => GobblerData) public getGobblerData;

    function ownerOf(uint256 id) public view virtual returns (address owner) {
        return getGobblerData[id].owner;
    }

    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 bal) {
        address idOwner = getGobblerData[id].owner;

        assembly {
            // We avoid branching by using assembly to take
            // the bool output of eq() and use it as a uint.
            bal := eq(idOwner, owner)
        }
    }

    /*//////////////////////////////////////////////////////////////
                             METADATA LOGIC
    //////////////////////////////////////////////////////////////*/

    function uri(uint256 id) public view virtual returns (string memory);

    /*//////////////////////////////////////////////////////////////
                              ERC1155 LOGIC
    //////////////////////////////////////////////////////////////*/

    function setApprovalForAll(address operator, bool approved) public virtual {
        isApprovedForAll[msg.sender][operator] = approved;

        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) public virtual;

    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) public virtual;

    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)
        public
        view
        virtual
        returns (uint256[] memory balances)
    {
        require(owners.length == ids.length, "LENGTH_MISMATCH");

        balances = new uint256[](owners.length);

        // Unchecked because the only math done is incrementing
        // the array index counter which cannot possibly overflow.
        unchecked {
            for (uint256 i = 0; i < owners.length; ++i) {
                balances[i] = balanceOf(owners[i], ids[i]);
            }
        }
    }

    /*//////////////////////////////////////////////////////////////
                           INTERNAL MINT LOGIC
    //////////////////////////////////////////////////////////////*/

    function _mint(
        address to,
        uint256 id,
        bytes memory data
    ) internal virtual {
        getGobblerData[id].owner = to;

        // Does not check if the token was already minted because new ids in
        // ArtGobblers.sol are set using a monotonically increasing counter.

        emit TransferSingle(msg.sender, address(0), to, id, 1);

        if (to.code.length != 0) {
            require(
                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, 1, data) ==
                    ERC1155TokenReceiver.onERC1155Received.selector,
                "UNSAFE_RECIPIENT"
            );
        } else require(to != address(0), "INVALID_RECIPIENT");
    }

    function _batchMint(
        address to,
        uint256 amount,
        uint256 lastMintedId,
        bytes memory data
    ) internal returns (uint256) {
        // Allocate arrays before entering the loop.
        uint256[] memory ids = new uint256[](amount);
        uint256[] memory amounts = new uint256[](amount);

        // Counter overflow is unrealistic on human timescales.
        unchecked {
            for (uint256 i = 0; i < amount; ++i) {
                ids[i] = ++lastMintedId; // Increment id while setting.

                amounts[i] = 1; // ERC1155B amounts are always 1.

                getGobblerData[lastMintedId].owner = to;
            }
        }

        emit TransferBatch(msg.sender, address(0), to, ids, amounts);

        if (to.code.length != 0) {
            require(
                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==
                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,
                "UNSAFE_RECIPIENT"
            );
        } else require(to != address(0), "INVALID_RECIPIENT");

        return lastMintedId; // Return the new last minted id.
    }
}


================================================
File: /src/utils/vrgda/PostSwitchVRGDA.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {unsafeWadDiv} from "../lib/SignedWadMath.sol";

import {VRGDA} from "./VRGDA.sol";

/// @title "Post Switch" Variable Rate Gradual Dutch Auction
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Abstract VRGDA with a (translated) linear issuance curve.
abstract contract PostSwitchVRGDA is VRGDA {
    /*//////////////////////////////////////////////////////////////
                           PRICING PARAMETERS
    //////////////////////////////////////////////////////////////*/

    /// @dev The number of tokens sold at the time of the switch.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable soldBySwitch;

    /// @dev The day soldBySwitch tokens were targeted to sell by.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable switchDay;

    /// @dev The total number of tokens to target selling each day.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable perDay;

    constructor(
        int256 _soldBySwitch,
        int256 _switchDay,
        int256 _perDay
    ) {
        soldBySwitch = _soldBySwitch;
        switchDay = _switchDay;
        perDay = _perDay;
    }

    /*//////////////////////////////////////////////////////////////
                              PRICING LOGIC
    //////////////////////////////////////////////////////////////*/

    function getTargetDayForNextSale(int256 sold) internal view virtual override returns (int256) {
        unchecked {
            return unsafeWadDiv(sold - soldBySwitch, perDay) + switchDay;
        }
    }
}


================================================
File: /src/utils/vrgda/LogisticVRGDA.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {wadExp, wadLn, unsafeDiv, unsafeWadDiv} from "../lib/SignedWadMath.sol";

import {VRGDA} from "./VRGDA.sol";

/// @title Logistic Variable Rate Gradual Dutch Auction
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Abstract VRGDA with a logistic issuance curve.
abstract contract LogisticVRGDA is VRGDA {
    /*//////////////////////////////////////////////////////////////
                           PRICING PARAMETERS
    //////////////////////////////////////////////////////////////*/

    /// @dev Controls the curve's maximum value which
    /// controls the maximum number of tokens to sell.
    /// @dev Represented as a 36 decimal fixed point number.
    int256 internal immutable logisticScale;

    /// @dev Time scale controls the steepness of the logistic curve,
    /// which effects how quickly we will reach the curve's asymptote.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable timeScale;

    /// @dev The initial value the uninverted logistic formula would output.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable initialLogisticValue;

    constructor(int256 _maxMintable, int256 _timeScale) {
        // We need to double _maxMintable to account for initialLogisticValue
        // and use 18 decimals to avoid wad multiplication in getTargetSaleDay.
        logisticScale = _maxMintable * 2e18;

        initialLogisticValue = _maxMintable;

        timeScale = _timeScale;
    }

    /*//////////////////////////////////////////////////////////////
                              PRICING LOGIC
    //////////////////////////////////////////////////////////////*/

    function getTargetDayForNextSale(int256 sold) internal view virtual override returns (int256) {
        unchecked {
            return -unsafeWadDiv(wadLn(unsafeDiv(logisticScale, sold + initialLogisticValue) - 1e18), timeScale);
        }
    }
}


================================================
File: /src/utils/vrgda/VRGDA.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {wadExp, wadLn, wadMul, unsafeWadMul, toWadUnsafe} from "../lib/SignedWadMath.sol";

/// @title Variable Rate Gradual Dutch Auction
/// @author FrankieIsLost <frankie@paradigm.xyz>
/// @author transmissions11 <t11s@paradigm.xyz>
/// @notice Sell tokens roughly according to an issuance schedule.
abstract contract VRGDA {
    /*//////////////////////////////////////////////////////////////
                            VRGDA PARAMETERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Initial price of each token, to be scaled according to sales rate.
    /// @dev Represented as an 18 decimal fixed point number.
    int256 public immutable initialPrice;

    /// @dev Precomputed constant that allows us to rewrite a pow() as an exp().
    /// @dev Represented as an 18 decimal fixed point number.
    int256 internal immutable decayConstant;

    constructor(int256 _initialPrice, int256 periodPriceDecrease) {
        initialPrice = _initialPrice;

        decayConstant = wadLn(1e18 - periodPriceDecrease);
    }

    /*//////////////////////////////////////////////////////////////
                              PRICING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Calculate the price of a token according to the VRGDA formula.
    /// @param timeSinceStart The time since actions began, in seconds.
    /// @param sold The number of tokens that have been sold so far.
    function getPrice(uint256 timeSinceStart, uint256 sold) public view returns (uint256) {
        unchecked {
            // prettier-ignore
            return uint256(wadMul(initialPrice, wadExp(unsafeWadMul(decayConstant,
                // Theoretically calling toWadUnsafe with timeSinceStart and sold can overflow without
                // detection, but under any reasonable circumstance they will never be large enough.
                (toWadUnsafe(timeSinceStart) / 1 days) - getTargetDayForNextSale(toWadUnsafe(sold))
            ))));
        }
    }

    /// @dev Given the number of tokens sold so far, return the target day the next token should be sold by.
    /// @param sold The number of tokens that have been sold so far, where 0 means none, scaled by 1e18.
    /// @return The target day that the next token should be sold by, scaled by 1e18, where the day
    /// is relative, such that 0 means the token should be sold immediately when auctions begin.
    function getTargetDayForNextSale(int256 sold) internal view virtual returns (int256);
}



    /// @notice Calculate the price of a token according to the VRGDA formula.
    /// @param timeSinceStart The time since actions began, in seconds.
    /// @param sold The number of tokens that have been sold so far.
    function getPrice(uint256 timeSinceStart, uint256 sold) public view returns (uint256) {
        unchecked {
            // prettier-ignore
            return uint256(wadMul(initialPrice, wadExp(unsafeWadMul(decayConstant,
                // Theoretically calling toWadUnsafe with timeSinceStart and sold can overflow without
                // detection, but under any reasonable circumstance they will never be large enough.
                (toWadUnsafe(timeSinceStart) / 1 days) - getTargetDayForNextSale(toWadUnsafe(sold))
            ))));
        }
    }

    /// @dev Given the number of tokens sold so far, return the target day the next token should be sold by.
    /// @param sold The number of tokens that have been sold so far, where 0 means none, scaled by 1e18.
    /// @return The target day that the next token should be sold by, scaled by 1e18, where the day
    /// is relative, such that 0 means the token should be sold immediately when auctions begin.
    function getTargetDayForNextSale(int256 sold) internal view virtual returns (int256);
}


